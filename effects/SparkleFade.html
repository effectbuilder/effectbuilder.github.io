<!DOCTYPE html><html>
<head>
    <title>ORGB: Sparkle Fade</title>
    <meta description="Fading in and fade out with sparkles.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="off_time" label="Off Time (ms)" type="number" min="0" max="100000" step="100" default="500">
    <meta property="fade_in_time" label="Fade In Time (ms)" type="number" min="1" max="100000" step="100" default="3000">
    <meta property="fade_out_time" label="Fade Out Time (ms)" type="number" min="1" max="100000" step="100" default="10000">
    <meta property="random_colors" label="Random Colors" type="boolean" default="true">
    <meta property="user_color" label="Color" type="color" default="#ffffff">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="sparklefade-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('sparklefade-canvas');
const ctx = canvas.getContext('2d');

// --- ADDED: Disable image smoothing ---
ctx.imageSmoothingEnabled = false;
ctx.mozImageSmoothingEnabled = false;
ctx.webkitImageSmoothingEnabled = false;

const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
const imageData = ctx.createImageData(canvasWidth, canvasHeight);
const pixels = imageData.data;

// Effect state variables
let currentState = "off"; // off, fadeIn, on, fadeOut
let state_timer = 0;
let baseColor = [255, 255, 255];
let ledInfo = []; // Stores the state for each pixel
// --- MODIFIED: Initialize with defaults ---
let lastRandomColors = typeof random_colors !== 'undefined' ? random_colors : true;
let lastUserColor = typeof user_color !== 'undefined' ? user_color : '#ffffff';
let initialized = false; // Flag for initial setup

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex || hex.length < 7) return [255, 255, 255];
     try {
        return [parseInt(hex.slice(1, 3), 16), parseInt(hex.slice(3, 5), 16), parseInt(hex.slice(5, 7), 16)];
     } catch(e) {
         console.error("Invalid hex:", hex, e);
         return [255,255,255];
     }
}

function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

function lerpColor(c1, c2, f) {
    const factor = Math.max(0, Math.min(1, f)); // Clamp factor
    return [
        c1[0] * (1 - factor) + c2[0] * factor,
        c1[1] * (1 - factor) + c2[1] * factor,
        c1[2] * (1 - factor) + c2[2] * factor
    ];
}

// -------------------------------------------------------------------
// EFFECT STATE MANAGEMENT
// -------------------------------------------------------------------

function resetLedInfo() {
    ledInfo = [];
    const numPixels = canvasWidth * canvasHeight;
    for(let i=0; i < numPixels; i++) {
        ledInfo.push({
            color: [0,0,0],
            fadeStartTime: 0,
            fadeDuration: 1, // Avoid division by zero
            fading: false
        });
    }
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    // --- MODIFIED: Use performance.now() for more precision if available ---
    const now = performance.now();
    const deltaTime = lastTime === 0 ? 16 : (now - lastTime); // Milliseconds, default to ~60fps
    lastTime = now;

    if (isNaN(deltaTime) || deltaTime <= 0) {
        requestAnimationFrame(update);
        return;
    }

    // --- ADDED: Fallbacks for meta properties ---
    const currentOffTime = typeof off_time !== 'undefined' ? off_time : 500;
    const currentFadeInTime = typeof fade_in_time !== 'undefined' ? Math.max(1, fade_in_time) : 3000; // Ensure > 0
    const currentFadeOutTime = typeof fade_out_time !== 'undefined' ? Math.max(1, fade_out_time) : 10000; // Ensure > 0
    const currentRandomColors = typeof random_colors !== 'undefined' ? random_colors : true;
    const currentUserColor = typeof user_color !== 'undefined' ? user_color : '#ffffff';

    // --- ADDED: Initialize on first run ---
     if (!initialized) {
        resetLedInfo();
        baseColor = currentRandomColors ? randomRgb() : hexToRgb(currentUserColor);
        lastRandomColors = currentRandomColors; // Sync initial state
        lastUserColor = currentUserColor;     // Sync initial state
        initialized = true;
    }


    if (ledInfo.length !== canvasWidth * canvasHeight) {
        resetLedInfo();
    }

    // Check for color setting changes
    if (currentRandomColors !== lastRandomColors || (!currentRandomColors && currentUserColor !== lastUserColor)) {
        // If switching to random or changing user color, update baseColor *immediately*
        // for the next cycle, but let the current fade finish.
        // The actual color switch happens at the start of "fadeIn".
        lastRandomColors = currentRandomColors;
        lastUserColor = currentUserColor;
        // Don't change baseColor mid-fade
    }


    state_timer += deltaTime;

    // --- State Machine ---
    if (currentState === "off") {
        if (state_timer >= currentOffTime) {
            currentState = "fadeIn";
            state_timer = 0;
            // Set new color at the beginning of the fade-in cycle
            baseColor = currentRandomColors ? randomRgb() : hexToRgb(currentUserColor);
             // Reset fading flags for all LEDs for the sparkle effect
            for (let i = 0; i < ledInfo.length; i++) {
                ledInfo[i].fading = false; // Reset for next sparkle phase
                ledInfo[i].color = [0,0,0]; // Ensure LEDs start black
            }
        }
    }
    else if (currentState === "fadeIn") {
        if (state_timer >= currentFadeInTime) {
            currentState = "on"; // Transition to ON state (solid color)
            state_timer = 0;
             // Ensure all LEDs are at baseColor now
            for(let i = 0; i < ledInfo.length; i++){
                ledInfo[i].color = [...baseColor]; // Copy baseColor
            }
        }
    }
     // --- MODIFIED: Separate 'on' state (solid color) and 'fadeOut' (sparkle) ---
    else if (currentState === "on") {
         // --- ADDED: Need a duration for the 'on' state before fading out ---
         // Let's make 'on' state duration relatively short before sparkle begins
         const onDuration = 500; // e.g., half a second solid color
        if (state_timer >= onDuration) {
            currentState = "fadeOut"; // Start the sparkle fade
            state_timer = 0; // Reset timer for fadeOut phase
            // Set up random fade times for sparkle effect
            for (let i = 0; i < ledInfo.length; i++) {
                 // Start fading at slightly different times
                ledInfo[i].fadeStartTime = now + (Math.random() * currentFadeOutTime * 0.5); // Start within first half
                // Duration varies
                ledInfo[i].fadeDuration = (Math.random() * currentFadeOutTime * 0.5) + (currentFadeOutTime * 0.5); // Last between 50% and 100% of fade time
                ledInfo[i].fading = true; // Mark as fading
                 ledInfo[i].color = [...baseColor]; // Ensure start color is correct
            }
        }
    }
    else if (currentState === "fadeOut") {
        let allFadedOut = true;
        for (let i = 0; i < ledInfo.length; i++) {
             // Check if current time is past the individual LED's fade start time
            if (ledInfo[i].fading && now >= ledInfo[i].fadeStartTime) {
                 const elapsed = now - ledInfo[i].fadeStartTime;
                 const factor = Math.min(1.0, elapsed / ledInfo[i].fadeDuration);
                 ledInfo[i].color = lerpColor(baseColor, [0, 0, 0], factor);
            } else if (ledInfo[i].fading) {
                // If fading hasn't started yet, keep base color
                ledInfo[i].color = [...baseColor];
            }

            // Check if *any* color component is still > 0
            if (ledInfo[i].color[0] > 1 || ledInfo[i].color[1] > 1 || ledInfo[i].color[2] > 1) {
                allFadedOut = false;
            } else {
                 // Once faded, clamp to black and mark not fading
                 ledInfo[i].color = [0,0,0];
                 // Don't reset fading flag here, wait for state transition
            }
        }

        if (allFadedOut) {
            currentState = "off";
            state_timer = 0;
            // Reset fading flags now that the state is changing
             for (let i = 0; i < ledInfo.length; i++) {
                ledInfo[i].fading = false;
            }
        }
    }


    // --- Render ---
     // Clear background (optional, depends if you want fade from black or fade over previous frame)
     // If clearing:
     /*
     for(let i = 0; i < pixels.length; i += 4) {
        pixels[i] = 0; pixels[i+1] = 0; pixels[i+2] = 0; pixels[i+3] = 255;
     }
     */

    if (currentState === "off") {
        // Ensure canvas is black during off state
         for(let i = 0; i < pixels.length; i += 4) {
             pixels[i] = 0; pixels[i+1] = 0; pixels[i+2] = 0; pixels[i+3] = 255;
         }
    } else if (currentState === "fadeIn") {
        const factor = Math.min(1.0, state_timer / currentFadeInTime);
        const finalColor = lerpColor([0,0,0], baseColor, factor);
        const r = Math.round(finalColor[0]);
        const g = Math.round(finalColor[1]);
        const b = Math.round(finalColor[2]);
        for(let i = 0; i < pixels.length; i += 4) {
            pixels[i] = r; pixels[i+1] = g; pixels[i+2] = b; pixels[i+3] = 255;
        }
    } else if (currentState === "on") {
         const r = Math.round(baseColor[0]);
         const g = Math.round(baseColor[1]);
         const b = Math.round(baseColor[2]);
         for(let i = 0; i < pixels.length; i += 4) {
            pixels[i] = r; pixels[i+1] = g; pixels[i+2] = b; pixels[i+3] = 255;
        }
    } else if (currentState === "fadeOut") {
        // Render each LED based on its individual fade state
        for (let i = 0; i < ledInfo.length; i++) {
            const index = i * 4;
            const finalColor = ledInfo[i].color;
            pixels[index] = Math.round(finalColor[0]);
            pixels[index+1] = Math.round(finalColor[1]);
            pixels[index+2] = Math.round(finalColor[2]);
            pixels[index+3] = 255;
        }
    }

    ctx.putImageData(imageData, 0, 0);

    requestAnimationFrame(update);
}

// Initial call
resetLedInfo(); // Initialize LED info array
requestAnimationFrame(update);
</script>
</html>