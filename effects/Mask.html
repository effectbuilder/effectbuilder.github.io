<!DOCTYPE html><html>
<head>
    <title>ORGB: Mask</title>
    <meta description="A simple mask for using in layers.">
    <meta publisher="JosÃ© Miranda (Port and improvements)">

    <meta property="x_pos" label="X Position" type="number" min="0.0" max="1.0" step="0.01" default="0.25">
    <meta property="y_pos" label="Y Position" type="number" min="0.0" max="1.0" step="0.01" default="0.25">
    <meta property="width" label="Width" type="number" min="0.0" max="1.0" step="0.01" default="0.5">
    <meta property="height" label="Height" type="number" min="0.0" max="1.0" step="0.01" default="0.5">
    <meta property="invert_colors" label="Invert Colors" type="boolean" default="false">
    <meta property="color_inside" label="Inside Color" type="color" default="#ffffff">
    <meta property="color_outside" label="Outside Color" type="color" default="#000000">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="mask-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('mask-canvas');
const ctx = canvas.getContext('2d');

// --- ADDED: Disable image smoothing ---
ctx.imageSmoothingEnabled = false;
ctx.mozImageSmoothingEnabled = false;
ctx.webkitImageSmoothingEnabled = false;

const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
// --- ADDED: ImageData buffer ---
const imageData = ctx.createImageData(canvasWidth, canvasHeight);
const pixels = imageData.data;

// --- ADDED: Helper to parse hex ---
function hexToRgb(hex) {
    if (!hex || hex.length < 7) return [0, 0, 0];
    try {
        return [parseInt(hex.slice(1, 3), 16), parseInt(hex.slice(3, 5), 16), parseInt(hex.slice(5, 7), 16)];
     } catch(e) { console.error("Invalid hex:", hex, e); return [0,0,0]; }
}

// -------------------------------------------------------------------
// EFFECT LOGIC
// -------------------------------------------------------------------

// --- MODIFIED: Returns RGB array ---
function getPixelColor(x, y, w, h) {
    // --- ADDED: Fallbacks for meta properties ---
    const currentXPos = typeof x_pos !== 'undefined' ? x_pos : 0.25;
    const currentYPos = typeof y_pos !== 'undefined' ? y_pos : 0.25;
    const currentWidth = typeof width !== 'undefined' ? width : 0.5;
    const currentHeight = typeof height !== 'undefined' ? height : 0.5;
    const currentInvert = typeof invert_colors !== 'undefined' ? invert_colors : false;
    const currentInside = typeof color_inside !== 'undefined' ? color_inside : '#ffffff';
    const currentOutside = typeof color_outside !== 'undefined' ? color_outside : '#000000';

    const normX = x / w;
    const normY = y / h;

    const is_inside = (normX >= currentXPos && normX < (currentXPos + currentWidth) &&
                       normY >= currentYPos && normY < (currentYPos + currentHeight));

    const insideRgb = hexToRgb(currentInside);
    const outsideRgb = hexToRgb(currentOutside);

    if (is_inside) {
        return currentInvert ? outsideRgb : insideRgb;
    } else {
        return currentInvert ? insideRgb : outsideRgb;
    }
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastSettings = "";
function update() {
    // --- ADDED: Fallbacks for meta properties used in settings check ---
    const currentXPos = typeof x_pos !== 'undefined' ? x_pos : 0.25;
    const currentYPos = typeof y_pos !== 'undefined' ? y_pos : 0.25;
    const currentWidth = typeof width !== 'undefined' ? width : 0.5;
    const currentHeight = typeof height !== 'undefined' ? height : 0.5;
    const currentInvert = typeof invert_colors !== 'undefined' ? invert_colors : false;
    const currentInside = typeof color_inside !== 'undefined' ? color_inside : '#ffffff';
    const currentOutside = typeof color_outside !== 'undefined' ? color_outside : '#000000';

    const currentSettings = "" + currentXPos + currentYPos + currentWidth + currentHeight + currentInvert + currentInside + currentOutside;

    // Only redraw the canvas if a setting has changed
    if (currentSettings !== lastSettings) {
        lastSettings = currentSettings;

        // --- MODIFIED: Use putImageData ---
        for (let y = 0; y < canvasHeight; y++) {
            for (let x = 0; x < canvasWidth; x++) {
                const [r, g, b] = getPixelColor(x, y, canvasWidth, canvasHeight); // Uses fallbacks
                const index = (y * canvasWidth + x) * 4;
                pixels[index] = r;
                pixels[index + 1] = g;
                pixels[index + 2] = b;
                pixels[index + 3] = 255; // Alpha
            }
        }
        ctx.putImageData(imageData, 0, 0); // Draw the buffer
    }

    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);

</script>
</html>