<!DOCTYPE html>
<html>
<head>
    <title>Particle Swarm</title>
    <meta description="A swarm of particles creating fluid motion based on simplex noise, reacting to your audio. Based on Particle Swarm [Magnetic Field recreation], by Bass Groothedde (https://codepen.io/ImagineProgramming/pen/LpOJzM)" />
    <meta publisher="Jose Miranda" />

    <meta property="particleCount" label="Particle Count" type="number" default="450" min="100" max="5000">
    <meta property="speed" label="Swarm Speed" type="number" default="20" min="1" max="100">
    <meta property="trailAmount" label="Trail Amount" type="number" default="80" min="0" max="100">
    <meta property="particleOpacity" label="Particle Opacity" type="number" default="100" min="10" max="100">
    <meta property="colorMode" label="Color Mode" type="list" values="Color Cycle,Static,America,Bumblebee,C9,Cloud,Fire and Ice,Forest,Lava,Ocean,Party,Pastel,Sakura,Synthwave,Vaporwave" default="Synthwave">
    <meta property="staticColor" label="Static Color" type="color" default="#007755">
    <meta property="soundResponsive" label="Sound Responsive" type="boolean" default="true">
    <meta property="responsiveness" label="Responsiveness" type="number" default="100" min="1" max="100">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="swarm-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------
const canvas = document.getElementById('swarm-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
const bounds = { x: canvasWidth, y: canvasHeight };

// --- ADDED: Disable image smoothing ---
ctx.imageSmoothingEnabled = false;
ctx.mozImageSmoothingEnabled = false;
ctx.webkitImageSmoothingEnabled = false;

const bufferCanvas = document.createElement('canvas');
bufferCanvas.width = canvasWidth;
bufferCanvas.height = canvasHeight;
const bufferCtx = bufferCanvas.getContext('2d');

// --- ADDED: Disable image smoothing ---
bufferCtx.imageSmoothingEnabled = false;
bufferCtx.mozImageSmoothingEnabled = false;
bufferCtx.webkitImageSmoothingEnabled = false;

let particles = [];
let hue = 0;
let time = 0;
let lastColorMode = "Synthwave"; // Variable to track color mode changes

const palettes = {
    "Vaporwave": [ {h: 328, s: 100}, {h: 278, s: 100}, {h: 193, s: 99}, {h: 156, s: 100} ],
    "Synthwave": [ {h: 300, s: 100}, {h: 180, s: 100}, {h: 320, s: 100} ],
    "Fire and Ice": [ {h: 0, s: 100}, {h: 30, s: 100}, {h: 200, s: 100}, {h: 240, s: 100} ],
    "Ocean":     [ {h: 240, s: 100}, {h: 210, s: 100}, {h: 180, s: 100}, {h: 195, s: 100} ],
    "Lava":      [ {h: 0, s: 100}, {h: 15, s: 100}, {h: 30, s: 100}, {h: 55, s: 100} ],
    "Forest":    [ {h: 120, s: 100}, {h: 130, s: 80}, {h: 90, s: 60}, {h: 45, s: 50} ],
    "Cloud":     [ {h: 240, s: 20}, {h: 220, s: 30}, {h: 200, s: 40}, {h: 0, s: 0} ],
    "Party":     [ {h: 0, s: 100}, {h: 120, s: 100}, {h: 240, s: 100}, {h: 60, s: 100}, {h: 300, s: 100}, {h: 180, s: 100} ],
    "Pastel":    [ {h: 35, s: 100}, {h: 0, s: 100}, {h: 25, s: 100}, {h: 350, s: 100} ],
    "America":   [ {h: 0, s: 100}, {h: 225, s: 100}, {h: 0, s: 0} ],
    "Bumblebee": [ {h: 55, s: 100} ],
    "Sakura":    [ {h: 350, s: 100}, {h: 345, s: 100}, {h: 330, s: 100}, {h: 0, s: 0} ],
    "C9":        [ {h: 0, s: 100}, {h: 120, s: 100}, {h: 240, s: 100}, {h: 39, s: 100}, {h: 0, s: 0} ]
};

// -------------------------------------------------------------------
// UTILITIES: Vector, PRNG, Perlin Noise, Color
// -------------------------------------------------------------------

class Vector3D {
    constructor(x, y, z) { this.set(x, y, z); }
    set(x, y, z) { this.x = x; this.y = y; this.z = z; return this; }
    add(other) { if (typeof other === "number") { this.x += other; this.y += other; this.z += other; } else { this.x += other.x; this.y += other.y; this.z += other.z; } return this; }
    sub(other) { if (typeof other === "number") { this.x -= other; this.y -= other; this.z -= other; } else { this.x -= other.x; this.y -= other.y; this.z -= other.z; } return this; }
    mul(other) { if (typeof other === "number") { this.x *= other; this.y *= other; this.z *= other; } else { this.x *= other.x; this.y *= other.y; this.z *= other.z; } return this; }
    move(dest) { if (dest instanceof Vector3D) { dest.x = this.x; dest.y = this.y; dest.z = this.z; } return this; }
    wrap2d(bounds) {
        if (this.x > bounds.x) { this.x = 0; return true; } if (this.x < 0) { this.x = bounds.x; return true; }
        if (this.y > bounds.y) { this.y = 0; return true; } if (this.y < 0) { this.y = bounds.y; return true; }
    }
    clone() { return new Vector3D(this.x, this.y, this.z); }
    dot3d(x, y, z) { return ((this.x * x) + (this.y * y) + (this.z * z)); }
}

function simplePRNG(seed) {
    let _seed = seed % 2147483647; if (_seed <= 0) _seed += 2147483646;
    return {
        next: function() { return _seed = _seed * 16807 % 2147483647; },
        random: function(min = 0, max = 1) { const r = (this.next() - 1) / 2147483646; return min + r * (max - min); }
    };
}
const rctx = simplePRNG(Date.now());

class Perlin {
    constructor() {
        this.grad3 = [new Vector3D(1, 1, 0), new Vector3D(-1, 1, 0), new Vector3D(1, -1, 0), new Vector3D(-1, -1, 0), new Vector3D(1, 0, 1), new Vector3D(-1, 0, 1), new Vector3D(1, 0, -1), new Vector3D(-1, 0, -1), new Vector3D(0, 1, 1), new Vector3D(0, -1, 1), new Vector3D(0, 1, -1), new Vector3D(0, -1, -1)];
        this.p = [0x97, 0xa0, 0x89, 0x5b, 0x5a, 0x0f, 0x83, 0x0d, 0xc9, 0x5f, 0x60, 0x35, 0xc2, 0xe9, 0x07, 0xe1, 0x8c, 0x24, 0x67, 0x1e, 0x45, 0x8e, 0x08, 0x63, 0x25, 0xf0, 0x15, 0x0a, 0x17, 0xbe, 0x06, 0x94, 0xf7, 0x78, 0xea, 0x4b, 0x00, 0x1a, 0xc5, 0x3e, 0x5e, 0xfc, 0xdb, 0xcb, 0x75, 0x23, 0x0b, 0x20, 0x39, 0xb1, 0x21, 0x58, 0xed, 0x95, 0x38, 0x57, 0xae, 0x14, 0x7d, 0x88, 0xab, 0xa8, 0x44, 0xaf, 0x4a, 0xa5, 0x47, 0x86, 0x8b, 0x30, 0x1b, 0xa6, 0x4d, 0x92, 0x9e, 0xe7, 0x53, 0x6f, 0xe5, 0x7a, 0x3c, 0xd3, 0x85, 0xe6, 0xdc, 0x69, 0x5c, 0x29, 0x37, 0x2e, 0xf5, 0x28, 0xf4, 0x66, 0x8f, 0x36, 0x41, 0x19, 0x3f, 0xa1, 0x01, 0xd8, 0x50, 0x49, 0xd1, 0x4c, 0x84, 0xbb, 0xd0, 0x59, 0x12, 0xa9, 0xc8, 0xc4, 0x87, 0x82, 0x74, 0xbc, 0x9f, 0x56, 0xa4, 0x64, 0x6d, 0xc6, 0xad, 0xba, 0x03, 0x40, 0x34, 0xd9, 0xe2, 0xfa, 0x7c, 0x7b, 0x05, 0xca, 0x26, 0x93, 0x76, 0x7e, 0xff, 0x52, 0x55, 0xd4, 0xcf, 0xce, 0x3b, 0xe3, 0x2f, 0x10, 0x3a, 0x11, 0xb6, 0xbd, 0x1c, 0x2a, 0xdf, 0xb7, 0xaa, 0xd5, 0x77, 0xf8, 0x98, 0x02, 0x2c, 0x9a, 0xa3, 0x46, 0xdd, 0x99, 0x65, 0x9b, 0xa7, 0x2b, 0xac, 0x09, 0x81, 0x16, 0x27, 0xfd, 0x13, 0x62, 0x6c, 0x6e, 0x4f, 0x71, 0xe0, 0xe8, 0xb2, 0xb9, 0x70, 0x68, 0xda, 0xf6, 0x61, 0xe4, 0xfb, 0x22, 0xf2, 0xc1, 0xee, 0xd2, 0x90, 0x0c, 0xbf, 0xb3, 0xa2, 0xf1, 0x51, 0x33, 0x91, 0xeb, 0xf9, 0x0e, 0xef, 0x6b, 0x31, 0xc0, 0xd6, 0x1f, 0xb5, 0xc7, 0x6a, 0x9d, 0xb8, 0x54, 0xcc, 0xb0, 0x73, 0x79, 0x32, 0x2d, 0x7f, 0x04, 0x96, 0xfe, 0x8a, 0xec, 0xcd, 0x5d, 0xde, 0x72, 0x43, 0x1d, 0x18, 0x48, 0xf3, 0x8d, 0x80, 0xc3, 0x4e, 0x42, 0xd7, 0x3d, 0x9c, 0xb4];
        this.permutation = new Array(512); this.gradP = new Array(512);
        this.F3 = 1 / 3; this.G3 = 1 / 6;
    }
    init(prng) {
        for (let i = 0; i < 256; i += 1) {
            const randval = this.p[i] ^ prng();
            this.permutation[i] = this.permutation[i + 256] = randval;
            this.gradP[i] = this.gradP[i + 256] = this.grad3[randval % this.grad3.length];
        }
    }
    simplex3d(x, y, z) {
        let n0, n1, n2, n3, i1, j1, k1, i2, j2, k2, x1, y1, z1, x2, y2, z2, x3, y3, z3, gi0, gi1, gi2, gi3, t0, t1, t2, t3;
        const s = (x + y + z) * this.F3, i = Math.floor(x + s), j = Math.floor(y + s), k = Math.floor(z + s);
        const t = (i + j + k) * this.G3, x0 = x - i + t, y0 = y - j + t, z0 = z - k + t;
        if (x0 >= y0) {
            if (y0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
            else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; }
            else { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; }
        } else {
            if (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; }
            else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; }
            else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
        }
        x1 = x0 - i1 + this.G3; y1 = y0 - j1 + this.G3; z1 = z0 - k1 + this.G3;
        x2 = x0 - i2 + 2 * this.G3; y2 = y0 - j2 + 2 * this.G3; z2 = z0 - k2 + 2 * this.G3;
        x3 = x0 - 1 + 3 * this.G3; y3 = y0 - 1 + 3 * this.G3; z3 = z0 - 1 + 3 * this.G3;
        let ii = i & 255, jj = j & 255, kk = k & 255;
        gi0 = this.gradP[ii + this.permutation[jj + this.permutation[kk]]];
        gi1 = this.gradP[ii + i1 + this.permutation[jj + j1 + this.permutation[kk + k1]]];
        gi2 = this.gradP[ii + i2 + this.permutation[jj + j2 + this.permutation[kk + k2]]];
        gi3 = this.gradP[ii + 1 + this.permutation[jj + 1 + this.permutation[kk + 1]]];
        t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0; t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
        t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2; t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
        n0 = t0 < 0 ? 0 : (t0 *= t0, t0 * t0 * gi0.dot3d(x0, y0, z0)); n1 = t1 < 0 ? 0 : (t1 *= t1, t1 * t1 * gi1.dot3d(x1, y1, z1));
        n2 = t2 < 0 ? 0 : (t2 *= t2, t2 * t2 * gi2.dot3d(x2, y2, z2)); n3 = t3 < 0 ? 0 : (t3 *= t3, t3 * t3 * gi3.dot3d(x3, y3, z3));
        return 32 * (n0 + n1 + n2 + n3);
    }
}
const p = new Perlin();
p.init(() => rctx.random(0, 255));

function hexToHsl(hex) {
    if (!hex) return { h: 0, s: 0, l: 0 }; // Fallback for undefined
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (!result) return { h: 0, s: 0, l: 0 }; // Fallback for invalid hex
    let r = parseInt(result[1], 16) / 255;
    let g = parseInt(result[2], 16) / 255;
    let b = parseInt(result[3], 16) / 255;
    let max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if (max == min) { h = s = 0; } 
    else {
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h * 360, s: s * 100, l: l * 100 };
}

// -------------------------------------------------------------------
// PARTICLE LOGIC
// -------------------------------------------------------------------

class Particle {
    constructor(generator, bounds, prng) {
        this.p = new Vector3D(); this.t = new Vector3D(); this.v = new Vector3D();
        this.g = generator; this.b = bounds; this.r = prng;
        this.hue = 0; this.saturation = 100;
        this.reset();
    }

    reset() {
        this.p.x = this.t.x = Math.floor(this.r.random(0, this.b.x));
        this.p.y = this.t.y = Math.floor(this.r.random(0, this.b.y));
        this.v.set(0, 0, 0); this.i = 0; this.l = this.r.random(1000, 10000);

        // --- ADDED: Fallbacks for meta properties ---
        const currentColorMode = typeof colorMode !== 'undefined' ? colorMode : "Synthwave";
        const currentStaticColor = typeof staticColor !== 'undefined' ? staticColor : "#007755";

        if (currentColorMode === 'Static') {
            const hsl = hexToHsl(currentStaticColor);
            this.hue = hsl.h;
            this.saturation = hsl.s;
        } else if (palettes[currentColorMode]) {
            const currentPalette = palettes[currentColorMode];
            const color = currentPalette[Math.floor(this.r.random(0, currentPalette.length))];
            this.hue = color.h;
            this.saturation = color.s;
        } else {
            // Fallback if colorMode is 'Color Cycle' or invalid
            this.hue = 0; // Will be overwritten in 'Color Cycle' render path
            this.saturation = 100;
        }
    }

    step(time, currentSpeed, audioAmp) {
        if (this.i++ > this.l) { this.reset(); }

        // --- ADDED: Fallback for meta property ---
        const currentResponsiveness = typeof responsiveness !== 'undefined' ? responsiveness : 100;

        const xx = this.p.x / 100; const yy = this.p.y / 100;
        const zz = time * 0.01; // Decouple noise evolution from speed
        const a = this.r.random(0, Math.PI * 2);
        const rnd = this.r.random(0, 1) / 4;
        let noiseX = this.g.simplex3d(xx, yy, -zz); let noiseY = this.g.simplex3d(xx, yy, zz);
        let force = audioAmp > 0.01 ? 1.0 + audioAmp * (currentResponsiveness / 10) : 1.0;
        this.v.x += (rnd * Math.sin(a) + noiseX) * force;
        this.v.y += (rnd * Math.cos(a) + noiseY) * force;
        
        this.p.move(this.t); 
        const moveVector = this.v.clone().mul(currentSpeed / 40.0); 
        this.p.add(moveVector); 
        this.v.mul(0.94); 
        
        if (this.p.wrap2d(this.b)) { this.p.move(this.t); }
    }

    render(context) {
        context.moveTo(this.t.x, this.t.y);
        context.lineTo(this.p.x, this.p.y);
    }
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

function update() {
    // --- REMOVED: Guard clause that broke browser execution ---
    // if (typeof engine === 'undefined' || !engine.audio || !engine.audio.freq) {
    //     requestAnimationFrame(update); return;
    // }

    // --- ADDED: Fallbacks for meta properties ---
    const currentParticleCount = typeof particleCount !== 'undefined' ? particleCount : 450;
    const currentColorMode = typeof colorMode !== 'undefined' ? colorMode : "Synthwave";
    const currentSoundResponsive = typeof soundResponsive !== 'undefined' ? soundResponsive : true;
    const currentTrailAmount = typeof trailAmount !== 'undefined' ? trailAmount : 80;
    const currentParticleOpacity = typeof particleOpacity !== 'undefined' ? particleOpacity : 100;
    const currentSpeed = typeof speed !== 'undefined' ? speed : 20;
    const currentStaticColor = typeof staticColor !== 'undefined' ? staticColor : "#007755";

    time++;
    
    if (currentColorMode !== lastColorMode) {
        for (const particle of particles) {
            particle.reset();
        }
        lastColorMode = currentColorMode;
    }

    while (particles.length < currentParticleCount) { particles.push(new Particle(p, bounds, rctx)); }
    while (particles.length > currentParticleCount) { particles.pop(); }

    let audioAmp = 0;
    // --- MODIFIED: Added check for engine object ---
    if (currentSoundResponsive && typeof engine !== 'undefined' && engine.audio && engine.audio.freq) {
        const audioData = new Int8Array(engine.audio.freq);
        let totalAmp = 0;
        for (let i = 0; i < audioData.length; i++) { totalAmp += Math.abs(audioData[i]); }
        audioAmp = totalAmp / (audioData.length * 128.0);
    }

    // --- Drawing Logic ---
    bufferCtx.globalCompositeOperation = 'source-over';
    const fadeAlpha = 1.0 - (currentTrailAmount / 100.0);
    bufferCtx.fillStyle = `rgba(0, 0, 0, ${fadeAlpha})`;
    bufferCtx.fillRect(0, 0, canvasWidth, canvasHeight);
    
    bufferCtx.globalCompositeOperation = 'lighter';
    bufferCtx.lineWidth = 1;
    const opacity = currentParticleOpacity / 100;

    if (currentColorMode === 'Color Cycle') {
        bufferCtx.strokeStyle = `hsla(${hue}, 75%, 50%, ${opacity})`;
        bufferCtx.beginPath();
        for (const particle of particles) {
            particle.step(time, currentSpeed, audioAmp);
            particle.render(bufferCtx);
        }
        bufferCtx.stroke();
    } else { // Static and Palette Modes
        const colorGroups = new Map();
        for (const particle of particles) {
            particle.step(time, currentSpeed, audioAmp);
            const colorKey = `${particle.hue},${particle.saturation}`;
            if (!colorGroups.has(colorKey)) {
                colorGroups.set(colorKey, []);
            }
            colorGroups.get(colorKey).push(particle);
        }

        for (const [colorKey, particlesInGroup] of colorGroups.entries()) {
            const [h, s] = colorKey.split(',');
            let l = 50;
            if (currentColorMode === 'Static') {
                 l = hexToHsl(currentStaticColor).l;
            }
            bufferCtx.strokeStyle = `hsla(${h}, ${s}%, ${l}%, ${opacity})`;
            bufferCtx.beginPath();
            for (const particle of particlesInGroup) {
                particle.render(bufferCtx);
            }
            bufferCtx.stroke();
        }
    }

    ctx.globalCompositeOperation = 'source-over';
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
    ctx.drawImage(bufferCanvas, 0, 0);

    hue = (hue + 0.5) % 360;
    requestAnimationFrame(update);
}

// Initial call to start the animation
ctx.fillStyle = '#000000'; ctx.fillRect(0, 0, canvasWidth, canvasHeight);
bufferCtx.fillStyle = '#000000'; bufferCtx.fillRect(0, 0, canvasWidth, canvasHeight);
requestAnimationFrame(update);

</script>
</html>