<!DOCTYPE html><html>
<head>
    <title>ORGB: Bubble Collision</title>
    <meta description="Bubbles spawn with speed and direction, bouncing off walls and each other.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="speed" label="Speed" type="number" min="1" max="100" default="100">
    <meta property="max_bubbles" label="Max Bubbles" type="number" min="1" max="50" default="10">
    <meta property="bubble_size" label="Bubble Size" type="number" min="1" max="50" default="20">
    <meta property="spawn_rate" label="Spawn Rate" type="number" min="1" max="1000" default="350">
    <meta property="palette" label="Color Palette" type="list" values="Vaporwave,Ocean,Sunset,Forest,Fire,Rainbow Puke" default="Rainbow Puke">
    <meta property="random_colors" label="Random Colors" type="boolean" default="false">
    <meta property="background_color" label="Background" type="color" default="#000000" min="0" max="360">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="bubble-collision-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('bubble-collision-canvas');
const ctx = canvas.getContext('2d');

// --- ADDED: Disable image smoothing ---
ctx.imageSmoothingEnabled = false;
ctx.mozImageSmoothingEnabled = false;
ctx.webkitImageSmoothingEnabled = false;

const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

// Array to hold active bubble objects
let bubbles = [];

// A timer to control bubble spawning
let spawnTimer = 0;

// Store the previous state of the meta properties to detect changes
// --- MODIFIED: Initialize with defaults ---
let lastSpeed = typeof speed !== 'undefined' ? speed : 100;
let lastMaxBubbles = typeof max_bubbles !== 'undefined' ? max_bubbles : 10;
let lastBubbleSize = typeof bubble_size !== 'undefined' ? bubble_size : 20;
let lastSpawnRate = typeof spawn_rate !== 'undefined' ? spawn_rate : 350;
let lastPalette = typeof palette !== 'undefined' ? palette : "Rainbow Puke";
let lastRandomColors = typeof random_colors !== 'undefined' ? random_colors : false;
let lastBackgroundColor = typeof background_color !== 'undefined' ? background_color : "#000000";


// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

/** Converts a hex color string to an RGB array. */
function hexToRgb(hex) {
    if (!hex) return [0, 0, 0];
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return [r, g, b];
}

/** Returns a random RGB color array. */
function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

// -------------------------------------------------------------------
// BUBBLE LOGIC
// -------------------------------------------------------------------

// Define some color palettes for the visualizer
const colorPalettes = {
    "Vaporwave": ["#FF71CE", "#B967FF", "#01CDFE", "#05FFA1", "#FFFB96"],
    "Ocean": ["#00007F", "#0000FF", "#00FFFF", "#00AAFF"],
    "Sunset": ["#FF2100", "#AB006D", "#C01C52", "#D53737", "#EA531B", "#FF6E00"],
    "Forest": ["#113C16", "#2D7F39", "#56A661", "#80D08A", "#AAD8B1"],
    "Fire": ["#FF0000", "#FF6A00", "#FFD700", "#FFFF00", "#FF8C00"],
    "Rainbow Puke": ["#FF0000", "#FF7F00", "#FFFF00", "#00FF00", "#0000FF", "#4B0082", "#9400D3"]
};

/** Resets the animation and state variables. */
function resetAnimation() {
    bubbles = [];
    spawnTimer = 0;
    // --- ADDED: Use fallbacks when resetting last state ---
    lastSpeed = typeof speed !== 'undefined' ? speed : 100;
    lastMaxBubbles = typeof max_bubbles !== 'undefined' ? max_bubbles : 10;
    lastBubbleSize = typeof bubble_size !== 'undefined' ? bubble_size : 20;
    lastSpawnRate = typeof spawn_rate !== 'undefined' ? spawn_rate : 350;
    lastPalette = typeof palette !== 'undefined' ? palette : "Rainbow Puke";
    lastRandomColors = typeof random_colors !== 'undefined' ? random_colors : false;
    lastBackgroundColor = typeof background_color !== 'undefined' ? background_color : "#000000";
}

/** Creates and initializes a new bubble object. */
function initBubble() {
    // --- ADDED: Use fallbacks for meta properties ---
    const currentRandomColors = typeof random_colors !== 'undefined' ? random_colors : false;
    const currentPalette = typeof palette !== 'undefined' ? palette : "Rainbow Puke";
    const currentBubbleSize = typeof bubble_size !== 'undefined' ? bubble_size : 20;
    const currentSpeed = typeof speed !== 'undefined' ? speed : 100;

    let color;

    if (currentRandomColors) {
        color = randomRgb();
    } else {
        // Use the selected palette
        const paletteColors = colorPalettes[currentPalette] || colorPalettes["Rainbow Puke"]; // Fallback palette
        const randomColorHex = paletteColors[Math.floor(Math.random() * paletteColors.length)];
        color = hexToRgb(randomColorHex);
    }

    // Assign a random size based on bubble_size
    const randomRadius = currentBubbleSize * (0.5 + Math.random() * 0.75); // More variance, max 1.25x base size

    // Assign velocity, inversely proportional to size, scaled by speed
    const angle = Math.random() * Math.PI * 2;
    // Scale speed factor based on radius relative to base size
    const sizeFactor = Math.max(0.1, randomRadius / currentBubbleSize);
    const initialSpeed = (currentSpeed / 5) / sizeFactor; // Adjusted speed scaling


    bubbles.push({
        id: Math.random(),
        x: Math.random() * canvasWidth,
        y: Math.random() * canvasHeight,
        radius: randomRadius,
        color: color,
        velocity: {
            x: Math.cos(angle) * initialSpeed,
            y: Math.sin(angle) * initialSpeed
        }
    });
}


/** Updates the position and checks for collisions for each bubble. */
function updateBubbles(deltaTime) {
    for (let i = 0; i < bubbles.length; i++) {
        const bubble = bubbles[i];

        bubble.x += bubble.velocity.x * deltaTime;
        bubble.y += bubble.velocity.y * deltaTime;

        // Wall collision
        if (bubble.x - bubble.radius < 0) {
            bubble.velocity.x = Math.abs(bubble.velocity.x); // Ensure positive velocity
            bubble.x = bubble.radius;
        } else if (bubble.x + bubble.radius > canvasWidth) {
            bubble.velocity.x = -Math.abs(bubble.velocity.x); // Ensure negative velocity
            bubble.x = canvasWidth - bubble.radius;
        }
        if (bubble.y - bubble.radius < 0) {
            bubble.velocity.y = Math.abs(bubble.velocity.y); // Ensure positive velocity
            bubble.y = bubble.radius;
        } else if (bubble.y + bubble.radius > canvasHeight) {
            bubble.velocity.y = -Math.abs(bubble.velocity.y); // Ensure negative velocity
            bubble.y = canvasHeight - bubble.radius;
        }
    }
}


/** Checks for and resolves collisions between bubbles. */
function checkCollisions() {
    for (let i = 0; i < bubbles.length; i++) {
        for (let j = i + 1; j < bubbles.length; j++) {
            const b1 = bubbles[i];
            const b2 = bubbles[j];

            const dx = b1.x - b2.x;
            const dy = b1.y - b2.y;
            const distanceSq = dx * dx + dy * dy; // Use squared distance for check
            const radiiSumSq = (b1.radius + b2.radius) * (b1.radius + b2.radius);

            if (distanceSq < radiiSumSq && distanceSq > 0) { // Check distanceSq > 0 to avoid self-collision issues
                 const distance = Math.sqrt(distanceSq);

                // Prevent sticking
                const overlap = (b1.radius + b2.radius) - distance;
                const moveX = (dx / distance) * overlap * 0.5; // Move each half the overlap
                const moveY = (dy / distance) * overlap * 0.5;
                b1.x += moveX;
                b1.y += moveY;
                b2.x -= moveX;
                b2.y -= moveY;

                // Elastic collision response
                const normalX = dx / distance;
                const normalY = dy / distance;

                // Relative velocity
                const relVelX = b1.velocity.x - b2.velocity.x;
                const relVelY = b1.velocity.y - b2.velocity.y;

                // Velocity component along the normal
                const dotProduct = relVelX * normalX + relVelY * normalY;

                // Calculate impulse scalar (simplified for equal mass)
                 const impulse = (2 * dotProduct) / 2; // (m1+m2 = 2 assuming m=1)

                // Apply impulse
                b1.velocity.x -= impulse * normalX;
                b1.velocity.y -= impulse * normalY;
                b2.velocity.x += impulse * normalX;
                b2.velocity.y += impulse * normalY;
            }
        }
    }
}


/** Renders all bubbles to the canvas. */
function renderBubbles() {
    // --- ADDED: Fallback for background color ---
    const currentBackgroundColor = typeof background_color !== 'undefined' ? background_color : "#000000";
    const backgroundRgb = hexToRgb(currentBackgroundColor);

    ctx.fillStyle = `rgb(${backgroundRgb[0]}, ${backgroundRgb[1]}, ${backgroundRgb[2]})`;
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);

    for (const bubble of bubbles) {
        ctx.beginPath();
        ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
        const [r, g, b] = bubble.color;
        // --- FIXED: Use Math.round for color values ---
        ctx.fillStyle = `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
        ctx.fill();
    }
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    // --- ADDED: Use fallbacks for meta properties ---
    const currentSpeed = typeof speed !== 'undefined' ? speed : 100;
    const currentMaxBubbles = typeof max_bubbles !== 'undefined' ? max_bubbles : 10;
    const currentBubbleSize = typeof bubble_size !== 'undefined' ? bubble_size : 20;
    const currentSpawnRate = typeof spawn_rate !== 'undefined' ? spawn_rate : 350;
    const currentPalette = typeof palette !== 'undefined' ? palette : "Rainbow Puke";
    const currentRandomColors = typeof random_colors !== 'undefined' ? random_colors : false;
    const currentBackgroundColor = typeof background_color !== 'undefined' ? background_color : "#000000";


    // Check if any controls have changed and reset if needed
    if (currentSpeed !== lastSpeed || currentMaxBubbles !== lastMaxBubbles || currentBubbleSize !== lastBubbleSize ||
        currentSpawnRate !== lastSpawnRate || currentPalette !== lastPalette || currentRandomColors !== lastRandomColors ||
        currentBackgroundColor !== lastBackgroundColor) {
        resetAnimation(); // This function now correctly uses fallbacks
    }

    // Spawn new bubbles
    spawnTimer += deltaTime;
    // Spawn rate calculation: Higher value means faster spawning. Rate 100 = 1 per second.
    const spawnInterval = 1 / (currentSpawnRate / 100);
    if (bubbles.length < currentMaxBubbles && spawnTimer > spawnInterval) {
        initBubble();
        spawnTimer = 0; // Reset timer after spawning
    }

    updateBubbles(deltaTime);
    checkCollisions();

    renderBubbles();

    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);
</script>
</html>