<!DOCTYPE html><html>
<head>
    <title>ORGB: Mosaic</title>
    <meta description="Tiles randomly spawning across your devices.">
    <meta publisher="JosÃ© Miranda (Port and improvements)">

    <meta property="speed" label="Fade Speed" type="number" min="1" max="200" default="50">
    <meta property="rarity" label="Rarity (higher is rarer)" type="number" min="10" max="2000" default="100">
    <meta property="random_colors" label="Random Colors" type="boolean" default="true">

    <meta property="color1" label="Color 1" type="color" min="0" max="360" default="#ff0000">
    <meta property="color2" label="Color 2" type="color" min="0" max="360" default="#00ff00">
    <meta property="color3" label="Color 3" type="color" min="0" max="360" default="#0000ff">
    <meta property="color4" label="Color 4" type="color" min="0" max="360" default="#ffff00">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="mosaic-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('mosaic-canvas');
const ctx = canvas.getContext('2d');

// --- ADDED: Disable image smoothing ---
ctx.imageSmoothingEnabled = false;
ctx.mozImageSmoothingEnabled = false;
ctx.webkitImageSmoothingEnabled = false;

const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
const imageData = ctx.createImageData(canvasWidth, canvasHeight);
const pixels = imageData.data;

// This array will store the state for each pixel ("tile")
let tiles = [];

// --- MODIFIED: Initialize with defaults ---
let lastSpeed = typeof speed !== 'undefined' ? speed : 50;
let lastRarity = typeof rarity !== 'undefined' ? rarity : 100;
let lastRandomColors = typeof random_colors !== 'undefined' ? random_colors : true;
let lastColor1 = typeof color1 !== 'undefined' ? color1 : "#ff0000";
let lastColor2 = typeof color2 !== 'undefined' ? color2 : "#00ff00";
let lastColor3 = typeof color3 !== 'undefined' ? color3 : "#0000ff";
let lastColor4 = typeof color4 !== 'undefined' ? color4 : "#ffff00";


// -------------------------------------------------------------------
// HELPER FUNCTIONS
// -------------------------------------------------------------------

/** Converts a HEX color string to an HSL object */
function hexToHsl(hex) {
    if (!hex || hex.length < 7) return { h: 0, s: 0, l: 0 };
     try {
        let r = parseInt(hex.slice(1, 3), 16) / 255;
        let g = parseInt(hex.slice(3, 5), 16) / 255;
        let b = parseInt(hex.slice(5, 7), 16) / 255;

        let max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0; // achromatic
        } else {
            let d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return { h: h * 360, s: s * 100, l: l * 100 };
     } catch (e) {
         console.error("Invalid hex:", hex, e);
         return { h: 0, s: 0, l: 0 };
     }
}

/** Converts HSL color values to an RGB array. h(0-360), s(0-100), l(0-100) */
function hslToRgb(h, s, l) {
    h /= 360; s /= 100; l /= 100;
    let r, g, b;
    if (s === 0) {
        r = g = b = l; // achromatic
    } else {
        const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }
    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

function getRandomColor() {
    // --- ADDED: Fallbacks for colors ---
    const currentRandomColors = typeof random_colors !== 'undefined' ? random_colors : true;
    const c1 = typeof color1 !== 'undefined' ? color1 : "#ff0000";
    const c2 = typeof color2 !== 'undefined' ? color2 : "#00ff00";
    const c3 = typeof color3 !== 'undefined' ? color3 : "#0000ff";
    const c4 = typeof color4 !== 'undefined' ? color4 : "#ffff00";

    const userColors = [c1, c2, c3, c4].filter(c => c && c !== ''); // Filter empty strings

    if (currentRandomColors) {
        return { h: Math.random() * 360, s: 100 };
    } else if (userColors.length > 0) {
        return hexToHsl(userColors[Math.floor(Math.random() * userColors.length)]);
    }
    return { h: 0, s: 0, l: 50 }; // Failsafe (mid-gray HSL)
}

/** Resets and initializes the state for every pixel */
function resetTiles() {
    tiles = [];
    for (let i = 0; i < canvasWidth * canvasHeight; i++) {
        tiles.push({
            h: 0,       // Hue
            s: 100,     // Saturation
            l: 0,       // Lightness (brightness, 0-100)
            fade_speed: Math.random() * 0.5 + 0.75 // Random fade speed (0.75 - 1.25)
        });
    }
     // --- ADDED: Use fallbacks when resetting last state ---
    lastSpeed = typeof speed !== 'undefined' ? speed : 50;
    lastRarity = typeof rarity !== 'undefined' ? rarity : 100;
    lastRandomColors = typeof random_colors !== 'undefined' ? random_colors : true;
    lastColor1 = typeof color1 !== 'undefined' ? color1 : "#ff0000";
    lastColor2 = typeof color2 !== 'undefined' ? color2 : "#00ff00";
    lastColor3 = typeof color3 !== 'undefined' ? color3 : "#0000ff";
    lastColor4 = typeof color4 !== 'undefined' ? color4 : "#ffff00";
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    // --- ADDED: Fallbacks for meta properties ---
    const currentSpeed = typeof speed !== 'undefined' ? speed : 50;
    const currentRarity = typeof rarity !== 'undefined' ? rarity : 100;
    const currentRandomColors = typeof random_colors !== 'undefined' ? random_colors : true;
    const c1 = typeof color1 !== 'undefined' ? color1 : "#ff0000";
    const c2 = typeof color2 !== 'undefined' ? color2 : "#00ff00";
    const c3 = typeof color3 !== 'undefined' ? color3 : "#0000ff";
    const c4 = typeof color4 !== 'undefined' ? color4 : "#ffff00";

    // Check for changes in meta properties and re-initialize if needed
    if (tiles.length !== canvasWidth * canvasHeight || currentSpeed !== lastSpeed || currentRarity !== lastRarity ||
        currentRandomColors !== lastRandomColors || c1 !== lastColor1 || c2 !== lastColor2 ||
        c3 !== lastColor3 || c4 !== lastColor4)
    {
        resetTiles(); // Uses fallbacks internally now
    }

    // Rarity 10 = 1/10 chance, Rarity 2000 = 1/2000 chance per frame per pixel
    const spawnChance = 1 / Math.max(10, currentRarity); // Ensure rarity >= 10
    // Fade amount per second at speed 50. Scale linearly with speed.
    const baseFadePerSecond = 50;
    const fade_amount = baseFadePerSecond * (currentSpeed / 50) * deltaTime;


    // Update each tile's state and render to ImageData
    for (let i = 0; i < tiles.length; i++) {
        const tile = tiles[i];

        // If a tile has faded out, check if it should re-light
        if (tile.l <= 0) {
            tile.l = 0;
            // A random chance to trigger
            if (Math.random() < spawnChance) {
                tile.l = 50; // Re-light the tile to 50% lightness (full color)
                tile.fade_speed = Math.random() * 0.5 + 0.75; // Assign a new random fade speed

                // Assign a new color (getRandomColor uses fallbacks internally)
                const newColor = getRandomColor();
                tile.h = newColor.h;
                tile.s = newColor.s;
            }
        } else {
            // If the tile is lit, fade it out using its unique speed
            tile.l -= fade_amount * tile.fade_speed;
            tile.l = Math.max(0, tile.l); // Clamp lightness at 0
        }

        // Convert HSL to RGB and set the pixel data
        const [r, g, b] = hslToRgb(tile.h, tile.s, tile.l);

        const index = i * 4;
        pixels[index] = r;
        pixels[index + 1] = g;
        pixels[index + 2] = b;
        pixels[index + 3] = 255; // Alpha
    }

    // Draw the completed frame to the canvas
    ctx.putImageData(imageData, 0, 0);

    requestAnimationFrame(update);
}

// Initial setup and animation start
resetTiles(); // Call reset initially to populate tiles array
requestAnimationFrame(update);
</script>
</html>