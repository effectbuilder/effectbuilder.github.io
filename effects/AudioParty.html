<!DOCTYPE html>
<html>

<head>
    <title>Audio Party</title>
    <meta charset="UTF-8">
    <meta description="Movement, color change, and effects driven by audio frequency zones.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="base_pattern" label="Base Pattern" type="combobox" default="Waves" values="Waves,Radial,Conic,Checkered">
    <meta property="color_scheme" label="Color Scheme" type="combobox" default="Classic Rainbow" values="Classic Rainbow,Rainbow,Party,Cloud,Sunset,BPM,Heat,Lava,Ocean,Synthwave,Forest,Two-Color,Monochrome">
    <meta property="color1" label="Color 1" type="color" default="#ff0000">
    <meta property="color2" label="Color 2" type="color" default="#0000ff">
    <meta property="speed" label="Motion Speed" type="number" min="1" max="100" default="15">
    <meta property="color_change_speed" label="Color Change Speed" type="number" min="1" max="50" default="25">
    <meta property="rotation_speed" label="Rotation Speed" type="number" min="-100" max="100" default="0">

    <meta property="divisions" label="Divisions / Frequency" type="number" min="1" max="32" step="1" default="2">
    <meta property="pattern_size" label="Pattern Size" type="number" min="2" max="100" default="20">
    <meta property="smooth_patterns" label="Smooth Checkers" type="boolean" default="true">

    <meta property="motion_zone_stop" label="Audio Zone: Motion End" type="number" min="0" max="199" step="1" default="50">
    <meta property="color_zone_stop" label="Audio Zone: Color End" type="number" min="0" max="200" step="1" default="150">
    <meta property="effect_threshold_percent" label="Audio Zone: Effect Threshold (%)" type="number" min="0" max="100" step="1" default="5">

    <meta property="enable_horizontal_bars" label="Effect: Enable Horizontal Bars" type="boolean" default="true">
    <meta property="enable_vertical_bars" label="Effect: Enable Vertical Bars" type="boolean" default="true">
    <meta property="enable_shockwave" label="Effect: Enable Shockwave" type="boolean" default="true">
    <meta property="shockwave_thickness" label="Effect: Shockwave Thickness" type="number" min="1" max="50" default="20">
    <meta property="shockwave_color" label="Effect: Shockwave Color" type="color" default="#ffffff">
    <meta property="enable_blink" label="Effect: Enable Blink/Explosion" type="boolean" default="true">
    <meta property="enable_glitch" label="Effect: Enable Glitch" type="boolean" default="true">
    <meta property="glitch_intensity" label="Effect: Glitch Intensity" type="number" min="1" max="100" default="25">

    <meta property="noise_mode" label="Noise: Mode" type="combobox" default="Normal" values="Normal,Psychedelic">
    <meta property="psychedelic_preset" label="Noise: Psychedelic Preset" type="combobox" default="Medium" values="Soft,Medium,Intense">
    <meta property="noise_frequency_percent" label="Noise: Frequency (%)" type="number" min="0" max="100" default="30">
    <meta property="noise_scale" label="Noise: Scale" type="number" min="1" max="100" default="50">
    <meta property="noise_is_rgb" label="Noise: Color Noise" type="boolean" default="true">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="audioparty-canvas" width="320" height="200"></canvas>
</body>

<script>
    // -------------------------------------------------------------------
    // SETUP
    // -------------------------------------------------------------------

    const canvas = document.getElementById('audioparty-canvas');
    const ctx = canvas.getContext('2d');
    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;

    // --- ADDED: Disable image smoothing ---
    ctx.imageSmoothingEnabled = false;
    ctx.mozImageSmoothingEnabled = false;
    ctx.webkitImageSmoothingEnabled = false;

    // Effect state variables
    let x_shift = 0.0;
    let color_shift = 0.0;
    let rotation_angle = 0.0;
    let effect_progress = 1.0;
    let effect_idx = 0;
    let other_effect_cycler = -1;
    let progress = 0.0;
    // Pre-allocate reused objects for better performance
    const imageData = ctx.createImageData(canvasWidth, canvasHeight);
    const data = imageData.data;

    // Cache trigonometric calculations
    let cachedCos = 1, cachedSin = 0;
    let lastRotationAngle = 0;
    
    // --- ADDED: Psychedelic preset variables ---
    let psychedelic_frequency = 1200, psychedelic_amplitude = 39000;
    let psychedelic_lacunarity = 7500, psychedelic_persistence = 5000;
    let psychedelic_octaves = 2;


    // -------------------------------------------------------------------
    // COLOR UTILITIES
    // -------------------------------------------------------------------

    function hsvToRgb(h, s, v) {
        let r, g, b;
        const i = Math.floor(h * 6);
        const f = h * 6 - i;
        const p = v * (1 - s);
        const q = v * (1 - f * s);
        const t = v * (1 - (1 - f) * s);
        switch (i % 6) {
            case 0: r = v, g = t, b = p; break; case 1: r = q, g = v, b = p; break;
            case 2: r = p, g = v, b = t; break; case 3: r = p, g = q, b = v; break;
            case 4: r = t, g = p, b = v; break; case 5: r = v, g = p, b = q; break;
        }
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    function hexToRgb(hex) {
        if (!hex) return [255, 0, 0]; // Default to red if undefined
        const r = parseInt(hex.slice(1, 3), 16) || 0;
        const g = parseInt(hex.slice(3, 5), 16) || 0;
        const b = parseInt(hex.slice(5, 7), 16) || 0;
        return [r, g, b];
    }

    function screenBlend(base, blend) {
        const r = 1 - (1 - base[0] / 255) * (1 - blend[0] / 255);
        const g = 1 - (1 - base[1] / 255) * (1 - blend[1] / 255);
        const b = 1 - (1 - base[2] / 255) * (1 - blend[2] / 255);
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    function lerpColor(color1, color2, factor) {
        const r = color1[0] * (1 - factor) + color2[0] * factor;
        const g = color1[1] * (1 - factor) + color2[1] * factor;
        const b = color1[2] * (1 - factor) + color2[2] * factor;
        return [Math.round(r), Math.round(g), Math.round(b)];
    }

    // -------------------------------------------------------------------
    // EFFECT LOGIC
    // -------------------------------------------------------------------

    const seededRandom = s => {
        s = Math.sin(s) * 43758.5453;
        return s - Math.floor(s);
    };

    // -------------------------------------------------------------------
    // SIMPLEX NOISE ALGORITHM
    // -------------------------------------------------------------------
    const SimplexNoise = (function () {
        const F3 = 1.0 / 3.0, G3 = 1.0 / 6.0;
        const grad3 = new Float32Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1]);
        const p = new Uint8Array(256);
        for (let i = 0; i < 256; i++) p[i] = i;
        for (let i = 255; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[p[i], p[j]] = [p[j], p[i]]; }
        const perm = new Uint8Array(512);
        const permMod12 = new Uint8Array(512);
        for (let i = 0; i < 512; i++) { perm[i] = p[i & 255]; permMod12[i] = perm[i] % 12; }

        return {
            noise3D: function (xin, yin, zin) {
                let n0, n1, n2, n3;
                const s = (xin + yin + zin) * F3;
                const i = Math.floor(xin + s), j = Math.floor(yin + s), k = Math.floor(zin + s);
                const t = (i + j + k) * G3;
                const X0 = i - t, Y0 = j - t, Z0 = k - t;
                const x0 = xin - X0, y0 = yin - Y0, z0 = zin - Z0;
                let i1, j1, k1, i2, j2, k2;
                if (x0 >= y0) {
                    if (y0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
                    else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; }
                    else { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; }
                } else {
                    if (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; }
                    else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; }
                    else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
                }
                const x1 = x0 - i1 + G3, y1 = y0 - j1 + G3, z1 = z0 - k1 + G3;
                const x2 = x0 - i2 + 2.0 * G3, y2 = y0 - j2 + 2.0 * G3, z2 = z0 - k2 + 2.0 * G3;
                const x3 = x0 - 1.0 + 3.0 * G3, y3 = y0 - 1.0 + 3.0 * G3, z3 = z0 - 1.0 + 3.0 * G3;
                const ii = i & 255, jj = j & 255, kk = k & 255;
                const gi0 = permMod12[ii + perm[jj + perm[kk]]];
                const gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]];
                const gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]];
                const gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]];
                let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
                if (t0 < 0) n0 = 0.0;
                else { t0 *= t0; n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0 + grad3[gi0 + 2] * z0); }
                let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
                if (t1 < 0) n1 = 0.0;
                else { t1 *= t1; n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1 + grad3[gi1 + 2] * z1); }
                let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
                if (t2 < 0) n2 = 0.0;
                else { t2 *= t2; n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2 + grad3[gi2 + 2] * z2); }
                let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
                if (t3 < 0) n3 = 0.0;
                else { t3 *= t3; n3 = t3 * t3 * (grad3[gi3] * x3 + grad3[gi3 + 1] * y3 + grad3[gi3 + 2] * z3); }
                return 32.0 * (n0 + n1 + n2 + n3);
            },
            fractal: function (octaves, x, y, z, freq, amp, lac, per) {
                let val = 0;
                for (let i = 0; i < octaves; i++) {
                    val += this.noise3D(x * freq, y * freq, z * freq) * amp;
                    freq *= lac;
                    amp *= per;
                }
                return val;
            }
        };
    })();

    function getColor(x, y, w, h, params) {
        const {
            cos_a, sin_a, divisions, x_shift, color_shift,
            effect_progress, effect_idx, glitch_intensity, noise_scale, noise_is_rgb,
            shockwave_thickness, shockwave_color_rgb,
            frequency, amplitude, lacunarity, persistence, octaves, progress,
            base_pattern, pattern_size, smooth_patterns, color_scheme,
            rgb_color1, rgb_color2
        } = params;

        const centerX = w * 0.5;
        const centerY = h * 0.5;
        const translatedX = x - centerX;
        const translatedY = y - centerY;

        const rotatedX = translatedX * cos_a - translatedY * sin_a;
        const rotatedY = translatedX * sin_a + translatedY * cos_a;

        let finalX = rotatedX + centerX;
        let finalY = rotatedY + centerY;

        if (effect_progress < 1 && effect_idx === 7) {
            const line_seed = y * 1234.5;
            const random_offset = (seededRandom(line_seed) - 0.5) * 2;
            const intensity_factor = (glitch_intensity * 0.01) * w * 0.2;
            const current_intensity = intensity_factor * (1 - effect_progress);
            finalX += random_offset * current_intensity;
        }

        // Calculate the intensity 's' based on the selected base pattern
        let s;
        switch (base_pattern) {
            case "Radial": {
                const dist = Math.sqrt(translatedX * translatedX + translatedY * translatedY);
                const maxDist = w / 2;
                const p = (dist / maxDist - x_shift * 0.1);
                s = 0.5 * (1 + Math.sin(p * 2 * Math.PI * divisions));
                break;
            }
            case "Conic": {
                const angle = Math.atan2(translatedY, translatedX);
                const normalizedAngle = (angle + Math.PI) / (2 * Math.PI);
                const p = (normalizedAngle + x_shift * 0.1);
                s = 0.5 * (1 + Math.sin(p * 2 * Math.PI * divisions));
                break;
            }
            case "Checkered": {
                const size = pattern_size > 1 ? pattern_size : 20;
                const animSize = size + Math.sin(x_shift * 0.2) * (size / 2);
                if (smooth_patterns) {
                    const p_x = (finalX / animSize) * Math.PI;
                    const p_y = (finalY / animSize) * Math.PI;
                    s = 0.5 * (1 + Math.sin(p_x) * Math.sin(p_y));
                } else {
                    const checkX = Math.floor(finalX / animSize);
                    const checkY = Math.floor(finalY / animSize);
                    s = ((checkX + checkY) % 2 === 0) ? 1.0 : 0.0;
                }
                break;
            }
            case "Waves":
            default: {
                s = 0.5 * (1 + Math.sin((finalX * divisions * Math.PI) / w + x_shift));
                break;
            }
        }

        let waveColor;
        switch (color_scheme) {
            case "Classic Rainbow": {
                const hue = (0.5 + 0.5 * Math.sin(finalY / h * 2 + color_shift));
                waveColor = hsvToRgb(hue, 1, 1);
                break;
            }
            case "Party": {
                const gradient_progress = (((finalY / h) * 6 + color_shift) % 6 + 6) % 6;
                const colorIndex = Math.floor(gradient_progress);
                const partyColors = [[255, 0, 0], [0, 255, 0], [0, 0, 255], [255, 255, 0], [0, 255, 255], [255, 0, 255]];
                waveColor = partyColors[colorIndex];
                break;
            }
            case "Cloud": {
                const gradient_progress = (0.5 * (1 + Math.sin(finalY / h * 2 + color_shift)));
                if (gradient_progress < 0.5) {
                    waveColor = lerpColor([0, 0, 30], [0, 100, 255], gradient_progress * 2); // Dark Blue to Blue
                } else {
                    waveColor = lerpColor([0, 100, 255], [255, 255, 255], (gradient_progress - 0.5) * 2); // Blue to White
                }
                break;
            }
            case "Sunset": {
                const gradient_progress = (0.5 * (1 + Math.sin(finalY / h * 2 + color_shift)));
                if (gradient_progress < 0.33) {
                    waveColor = lerpColor([40, 0, 70], [255, 0, 0], gradient_progress / 0.33); // Dark Purple to Red
                } else if (gradient_progress < 0.66) {
                    waveColor = lerpColor([255, 0, 0], [255, 165, 0], (gradient_progress - 0.33) / 0.33); // Red to Orange
                } else {
                    waveColor = lerpColor([255, 165, 0], [255, 255, 0], (gradient_progress - 0.66) / 0.34); // Orange to Yellow
                }
                break;
            }
            case "BPM": {
                const gradient_progress = (0.5 * (1 + Math.sin(finalY / h * 2 + color_shift)));
                if (gradient_progress < 0.33) {
                    waveColor = lerpColor([255, 0, 0], [255, 255, 0], gradient_progress / 0.33); // Red to Yellow
                } else if (gradient_progress < 0.66) {
                    waveColor = lerpColor([255, 255, 0], [0, 255, 0], (gradient_progress - 0.33) / 0.33); // Yellow to Green
                } else {
                    waveColor = lerpColor([0, 255, 0], [0, 255, 255], (gradient_progress - 0.66) / 0.34); // Green to Cyan
                }
                break;
            }
            case "Heat": {
                const gradient_progress = (0.5 * (1 + Math.sin(finalY / h * 2 + color_shift)));
                if (gradient_progress < 0.5) {
                    waveColor = lerpColor([0, 0, 0], [255, 0, 0], gradient_progress * 2); // Black to Red
                } else {
                    waveColor = lerpColor([255, 0, 0], [255, 255, 0], (gradient_progress - 0.5) * 2); // Red to Yellow
                }
                break;
            }
            case "Lava": {
                const gradient_progress = (0.5 * (1 + Math.sin(finalY / h * 2 + color_shift)));
                if (gradient_progress < 0.5) {
                    waveColor = lerpColor([0, 0, 0], [200, 40, 0], gradient_progress * 2); // Black to Dark Red
                } else {
                    waveColor = lerpColor([200, 40, 0], [255, 165, 0], (gradient_progress - 0.5) * 2); // Dark Red to Orange
                }
                break;
            }
            case "Ocean": {
                const gradient_progress = (0.5 * (1 + Math.sin(finalY / h * 2 + color_shift)));
                if (gradient_progress < 0.5) {
                    waveColor = lerpColor([0, 0, 255], [0, 100, 255], gradient_progress * 2); // Blue to Medium Blue
                } else {
                    waveColor = lerpColor([0, 100, 255], [0, 255, 100], (gradient_progress - 0.5) * 2); // Medium Blue to Aqua
                }
                break;
            }
            case "Two-Color": {
                const blendFactor = (0.5 * (1 + Math.sin((finalY / h * 2) + color_shift)));
                waveColor = lerpColor(rgb_color1, rgb_color2, blendFactor);
                break;
            }
            case "Synthwave": {
                const gradient_progress = (0.5 * (1 + Math.sin(finalY / h * 2 + color_shift)));
                if (gradient_progress < 0.5) {
                    waveColor = lerpColor([255, 0, 255], [0, 255, 255], gradient_progress * 2); // Magenta to Cyan
                } else {
                    waveColor = lerpColor([0, 255, 255], [255, 105, 180], (gradient_progress - 0.5) * 2); // Cyan to Hot Pink
                }
                break;
            }
            case "Forest": {
                const gradient_progress = (0.5 * (1 + Math.sin(finalY / h * 2 + color_shift)));
                if (gradient_progress < 0.5) {
                    waveColor = lerpColor([139, 69, 19], [0, 100, 0], gradient_progress * 2); // Brown to Dark Green
                } else {
                    waveColor = lerpColor([0, 100, 0], [144, 238, 144], (gradient_progress - 0.5) * 2); // Dark Green to Light Green
                }
                break;
            }
            case "Monochrome": {
                const blendFactor = (0.5 * (1 + Math.sin((finalY / h * 2) + color_shift)));
                waveColor = lerpColor([0, 0, 0], [255, 255, 255], blendFactor);
                break;
            }
            case "Rainbow":
            default: {
                const hue = ((finalY / h) + color_shift * 0.1) % 1.0;
                waveColor = hsvToRgb(hue, 1, 1);
                break;
            }
        }

        let baseColor = lerpColor([0, 0, 0], waveColor, s);

        if (s > 0.001 && effect_progress < 1 && (effect_idx === 4 || effect_idx === 8) && noise_is_rgb) {
            let noiseColor = [0, 0, 0];
            if (effect_idx === 4) {
                const blockSize = 1 + Math.floor(noise_scale / 40);
                const blockX = Math.floor((finalX + x_shift * w) / blockSize);
                const blockY = Math.floor((finalY + color_shift * h) / blockSize);
                const seed = (blockX * 16807 + blockY * 37) & 0x7fffffff;
                noiseColor = [Math.floor(seededRandom(seed) * 255), Math.floor(seededRandom(seed * 1.3) * 255), Math.floor(seededRandom(seed * 1.7) * 255)];
            } else if (effect_idx === 8) {
                const maxFrequency = 5000;
                const minFrequency = 50;
                const reversedScale = 100 - noise_scale;
                const psychedelicFrequency = minFrequency + (reversedScale / 100) * (maxFrequency - minFrequency);
                const noiseVal = SimplexNoise.fractal(2, finalX / w, finalY / h, progress, psychedelicFrequency / 10000, 39000 / 10000, 7500 / 10000, 5000 / 10000);
                const frac = (1 + Math.abs(noiseVal)) * 0.5;
                const noiseHue = 360 * frac;
                noiseColor = hsvToRgb(noiseHue / 360, 1, 1);
            }
            const blendedNoiseWave = screenBlend(noiseColor, waveColor);
            baseColor = lerpColor([0, 0, 0], blendedNoiseWave, s);
        }

        let finalColor = baseColor;
        if (effect_progress < 1) {
            let effectColor = [0, 0, 0];
            switch (effect_idx) {
                case 0: case 1: case 2: case 3:
                    const bar_width = 2;
                    if ((effect_idx <= 1 && Math.abs(finalX - (effect_idx === 0 ? effect_progress * w : w - effect_progress * w)) <= bar_width) ||
                        (effect_idx >= 2 && Math.abs(finalY - (effect_idx === 2 ? effect_progress * h : h - effect_progress * h)) <= bar_width)) {
                        effectColor = [255, 255, 255];
                    }
                    break;
                case 5:
                    effectColor = [255, 255, 255].map(c => c * (1 - effect_progress));
                    break;
                case 6:
                    const dist = Math.sqrt(translatedX * translatedX + translatedY * translatedY);
                    if (Math.abs(dist - (effect_progress * w / 2)) < shockwave_thickness) {
                        effectColor = shockwave_color_rgb;
                    }
                    break;
            }
            finalColor = screenBlend(finalColor, effectColor);
        }

        return finalColor;
    }

    // -------------------------------------------------------------------
    // MAIN ANIMATION LOOP
    // -------------------------------------------------------------------

    let lastTime = 0;
    function update(currentTime) {
        if (!currentTime) currentTime = 0; // Fix for first frame
        const deltaTime = (currentTime - lastTime) / 1000 || (1/60);
        lastTime = currentTime;

        if (isNaN(deltaTime)) { window.requestAnimationFrame(update); return; }

        // --- ADDED: Fallbacks for meta properties ---
        const currentPsychedelicPreset = typeof psychedelic_preset !== 'undefined' ? psychedelic_preset : "Medium";
        const currentSpeed = typeof speed !== 'undefined' ? speed : 15;
        const currentColorChangeSpeed = typeof color_change_speed !== 'undefined' ? color_change_speed : 25;
        const currentRotationSpeed = typeof rotation_speed !== 'undefined' ? rotation_speed : 0;
        const currentMotionZoneStop = typeof motion_zone_stop !== 'undefined' ? motion_zone_stop : 50;
        const currentColorZoneStop = typeof color_zone_stop !== 'undefined' ? color_zone_stop : 150;
        const currentEffectThresholdPercent = typeof effect_threshold_percent !== 'undefined' ? effect_threshold_percent : 5;
        const currentEnableHorizontalBars = typeof enable_horizontal_bars !== 'undefined' ? enable_horizontal_bars : true;
        const currentEnableVerticalBars = typeof enable_vertical_bars !== 'undefined' ? enable_vertical_bars : true;
        const currentEnableShockwave = typeof enable_shockwave !== 'undefined' ? enable_shockwave : true;
        const currentEnableBlink = typeof enable_blink !== 'undefined' ? enable_blink : true;
        const currentEnableGlitch = typeof enable_glitch !== 'undefined' ? enable_glitch : true;
        const currentNoiseMode = typeof noise_mode !== 'undefined' ? noise_mode : "Normal";
        const currentDivisions = typeof divisions !== 'undefined' ? divisions : 2;
        const currentGlitchIntensity = typeof glitch_intensity !== 'undefined' ? glitch_intensity : 25;
        const currentNoiseScale = typeof noise_scale !== 'undefined' ? noise_scale : 50;
        const currentNoiseIsRGB = typeof noise_is_rgb !== 'undefined' ? noise_is_rgb : true;
        const currentShockwaveThickness = typeof shockwave_thickness !== 'undefined' ? shockwave_thickness : 20;
        const currentShockwaveColor = typeof shockwave_color !== 'undefined' ? shockwave_color : "#ffffff";
        const currentBasePattern = typeof base_pattern !== 'undefined' ? base_pattern : "Waves";
        const currentPatternSize = typeof pattern_size !== 'undefined' ? pattern_size : 20;
        const currentSmoothPatterns = typeof smooth_patterns !== 'undefined' ? smooth_patterns : true;
        const currentColorScheme = typeof color_scheme !== 'undefined' ? color_scheme : "Classic Rainbow";
        const currentColor1 = typeof color1 !== 'undefined' ? color1 : "#ff0000";
        const currentColor2 = typeof color2 !== 'undefined' ? color2 : "#0000ff";

        switch (currentPsychedelicPreset) {
            case "Soft": psychedelic_frequency = 500; psychedelic_amplitude = 10000; psychedelic_lacunarity = 1000; psychedelic_persistence = 1000; psychedelic_octaves = 1; break;
            case "Medium": psychedelic_frequency = 1200; psychedelic_amplitude = 39000; psychedelic_lacunarity = 7500; psychedelic_persistence = 5000; psychedelic_octaves = 2; break;
            case "Intense": psychedelic_frequency = 3000; psychedelic_amplitude = 50000; psychedelic_lacunarity = 10000; psychedelic_persistence = 8000; psychedelic_octaves = 3; break;
            default: psychedelic_frequency = 1200; psychedelic_amplitude = 39000; psychedelic_lacunarity = 7500; psychedelic_persistence = 5000; psychedelic_octaves = 2; break;
        }

        // --- MODIFIED: Added audio data fallback ---
        const audioData = (typeof engine !== 'undefined' && engine.audio && engine.audio.freq)
                          ? new Int8Array(engine.audio.freq)
                          : new Int8Array(200).fill(0);
                          
        const effect_threshold = currentEffectThresholdPercent / 100.0;
        const motionDelta = currentSpeed * deltaTime;
        const colorDelta = currentColorChangeSpeed * deltaTime;

        rotation_angle += (currentRotationSpeed / 100) * 90 * deltaTime;
        progress += 0.1 * currentSpeed * deltaTime;

        for (let i = 0; i < currentMotionZoneStop; i++) {
            if (audioData[i] > audioData[i + 1]) {
                x_shift += (audioData[i] / 128.0) * motionDelta * ((i % 2 === 0) ? 1 : -1);
                break;
            }
        }
        for (let i = currentMotionZoneStop; i < currentColorZoneStop; i++) {
            if (audioData[i] > audioData[i + 1]) {
                color_shift += (audioData[i] / 128.0) * colorDelta * ((i % 2 === 0) ? 1 : -1);
                break;
            }
        }

        if (effect_progress >= 1) {
            let maxLevel = 0;
            for (let i = currentColorZoneStop; i < 200; i++) {
                const level = Math.abs(audioData[i]) / 128.0;
                if (level > maxLevel) maxLevel = level;
            }

            if (maxLevel > effect_threshold) {
                const availableEffects = [];
                if (currentEnableHorizontalBars) { availableEffects.push(0, 1); }
                if (currentEnableVerticalBars) { availableEffects.push(2, 3); }
                if (currentEnableShockwave) { availableEffects.push(6); }
                if (currentEnableBlink) { availableEffects.push(5); }
                if (currentEnableGlitch) { availableEffects.push(7); }
                if (currentNoiseMode === "Normal") { availableEffects.push(4); }
                else if (currentNoiseMode === "Psychedelic") { availableEffects.push(8); }

                if (availableEffects.length > 0) {
                    other_effect_cycler = (other_effect_cycler + 1) % availableEffects.length;
                    effect_idx = availableEffects[other_effect_cycler];
                    effect_progress = 0;
                }
            }
        }

        if (effect_progress < 1) {
            if (effect_idx === 4 || effect_idx === 8) {
                effect_progress += 1.5 * deltaTime;
            } else {
                effect_progress += 0.5 * deltaTime;
            }
        } else {
            effect_progress = 1.0;
        }

        if (rotation_angle !== lastRotationAngle) {
            const angle_rad = rotation_angle * Math.PI / 180.0;
            cachedCos = Math.cos(angle_rad);
            cachedSin = Math.sin(angle_rad);
            lastRotationAngle = rotation_angle;
        }

        const params = {
            rotation_angle, cos_a: cachedCos, sin_a: cachedSin, divisions: currentDivisions, x_shift,
            color_shift, effect_progress, effect_idx, glitch_intensity: currentGlitchIntensity, noise_scale: currentNoiseScale,
            noise_is_rgb: currentNoiseIsRGB, shockwave_thickness: currentShockwaveThickness, shockwave_color_rgb: hexToRgb(currentShockwaveColor),
            frequency: psychedelic_frequency, amplitude: psychedelic_amplitude,
            lacunarity: psychedelic_lacunarity, persistence: psychedelic_persistence,
            octaves: psychedelic_octaves, progress, base_pattern: currentBasePattern, pattern_size: currentPatternSize, smooth_patterns: currentSmoothPatterns,
            color_scheme: currentColorScheme, rgb_color1: hexToRgb(currentColor1), rgb_color2: hexToRgb(currentColor2)
        };

        let idx = 0;
        for (let y = 0; y < canvasHeight; y++) {
            for (let x = 0; x < canvasWidth; x++) {
                const rgb = getColor(x, y, canvasWidth, canvasHeight, params);
                data[idx++] = rgb[0];
                data[idx++] = rgb[1];
                data[idx++] = rgb[2];
                data[idx++] = 255;
            }
        }
        ctx.putImageData(imageData, 0, 0);

        window.requestAnimationFrame(update);
    }

    window.requestAnimationFrame(update);

</script>

</html>