<!DOCTYPE html><html>
<head>
    <title>ORGB: Crossing Beams</title>
    <meta description="Two beams that move horizontally and vertically.">
    <meta publisher="JosÃ© Miranda (Port and improvements)">

    <meta property="speed" label="Master Speed" type="number" min="1" max="10" default="5">
    <meta property="h_speed" label="Horizontal Speed" type="number" min="1" max="100" default="50">
    <meta property="v_speed" label="Vertical Speed" type="number" min="1" max="100" default="50">
    <meta property="glow" label="Glow" type="number" min="1" max="100" default="50">
    <meta property="thickness" label="Thickness" type="number" min="0" max="100" default="5"> <meta property="random_colors" label="Random Colors" type="boolean" default="false">
    <meta property="color1" label="Horizontal Beam" type="color" default="#ff0000">
    <meta property="color2" label="Vertical Beam" type="color" default="#0000ff">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="crossingbeams-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('crossingbeams-canvas');
const ctx = canvas.getContext('2d');

ctx.imageSmoothingEnabled = false;
ctx.mozImageSmoothingEnabled = false;
ctx.webkitImageSmoothingEnabled = false;

const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
const imageData = ctx.createImageData(canvasWidth, canvasHeight);
const pixels = imageData.data;

// Effect state variables
let progress = 0.0;
let hsv1 = { h: 0, s: 1, v: 1 }; // H Beam
let hsv2 = { h: 240, s: 1, v: 1 }; // V Beam

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToHsv(hex) {
    if (!hex) return { h: 0, s: 0, v: 1 };
    let r = parseInt(hex.slice(1, 3), 16) / 255;
    let g = parseInt(hex.slice(3, 5), 16) / 255;
    let b = parseInt(hex.slice(5, 7), 16) / 255;

    let max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, v = max;
    let d = max - min;
    s = max === 0 ? 0 : d / max;

    if (max === min) { h = 0; }
    else {
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h * 360, s: s, v: v };
}

function hsvToRgb(h, s, v) { // h = 0-360, s = 0-1, v = 0-1
    let r, g, b;
    const hueNorm = (h % 360) / 60;
    const i = Math.floor(hueNorm);
    const f = hueNorm - i;
    const p = v * (1 - s);
    const q = v * (1 - f * s);
    const t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v, g = t, b = p; break; case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break; case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break; case 5: r = v, g = p, b = q; break;
    }
    return [r * 255, g * 255, b * 255];
}


function screenBlend(c1, c2) {
    return [
        (1 - (1 - c1[0] / 255) * (1 - c2[0] / 255)) * 255,
        (1 - (1 - c1[1] / 255) * (1 - c2[1] / 255)) * 255,
        (1 - (1 - c1[2] / 255) * (1 - c2[2] / 255)) * 255
    ];
}

// -------------------------------------------------------------------
// MAIN LOGIC
// -------------------------------------------------------------------

function getPixelBrightness(distance, coreThicknessPx, maxDist, glowAmount) {
    let brightness = 0;
    const decayFactor = 0.999 - (glowAmount / 100) * 0.04;

    if (distance <= coreThicknessPx) {
        brightness = 1.0 - (distance / (coreThicknessPx + 1)); // Avoid division by zero if thickness is 0
    } else {
        const glowDistance = distance - coreThicknessPx;
        brightness = Math.pow(decayFactor, glowDistance);
    }
    return Math.max(0, Math.min(1, brightness));
}


function getColor(x, y, w, h) {
    const currentHSpeed = typeof h_speed !== 'undefined' ? h_speed : 50;
    const currentVSpeed = typeof v_speed !== 'undefined' ? v_speed : 50;
    const currentThickness = typeof thickness !== 'undefined' ? thickness : 5;
    const currentGlow = typeof glow !== 'undefined' ? glow : 50;

    const x_progress = 0.5 * (1 + Math.sin(0.01 * currentHSpeed * progress));
    const y_progress = 0.5 * (1 + Math.sin(0.01 * currentVSpeed * progress));

    const beam_x = x_progress * w;
    const beam_y = y_progress * h;

    const distance_x = Math.abs(beam_x - x);
    const distance_y = Math.abs(beam_y - y);

    const coreThicknessPxX = Math.max(1, (currentThickness / 100) * (w / 2)); // Ensure at least 1px thickness
    const coreThicknessPxY = Math.max(1, (currentThickness / 100) * (h / 2));

    const x_brightness = getPixelBrightness(distance_x, coreThicknessPxX, w / 2, currentGlow);
    const y_brightness = getPixelBrightness(distance_y, coreThicknessPxY, h / 2, currentGlow);

    const color1_rgb = hsvToRgb(hsv1.h, hsv1.s, hsv1.v * x_brightness);
    const color2_rgb = hsvToRgb(hsv2.h, hsv2.s, hsv2.v * y_brightness);

    const final_color = screenBlend(color1_rgb, color2_rgb);

    return [
        Math.max(0, Math.min(255, Math.round(final_color[0]))),
        Math.max(0, Math.min(255, Math.round(final_color[1]))),
        Math.max(0, Math.min(255, Math.round(final_color[2])))
    ];
}


// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
let lastColor1 = "", lastColor2 = "";
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    const currentSpeed = typeof speed !== 'undefined' ? speed : 5;
    const currentRandomColors = typeof random_colors !== 'undefined' ? random_colors : false;
    const c1 = typeof color1 !== 'undefined' ? color1 : "#ff0000";
    const c2 = typeof color2 !== 'undefined' ? color2 : "#0000ff";

    progress += currentSpeed * deltaTime;

    if (currentRandomColors) {
        // --- MODIFIED: Increased hue change speed ---
        const hueChangeRate = 50; // Degrees per second at speed=5, adjust as needed
        hsv1.h = (hsv1.h + currentSpeed / 5 * hueChangeRate * deltaTime) % 360;
        hsv2.h = (hsv2.h + currentSpeed / 5 * hueChangeRate * deltaTime * 1.3) % 360; // Slightly different speed for V beam
        hsv1.s = 1; hsv1.v = 1;
        hsv2.s = 1; hsv2.v = 1;
    } else {
        if(c1 !== lastColor1) { hsv1 = hexToHsv(c1); lastColor1 = c1; }
        if(c2 !== lastColor2) { hsv2 = hexToHsv(c2); lastColor2 = c2; }
    }

    for (let y = 0; y < canvasHeight; y++) {
        for (let x = 0; x < canvasWidth; x++) {
            const [r, g, b] = getColor(x, y, canvasWidth, canvasHeight);
            const index = (y * canvasWidth + x) * 4;
            pixels[index] = r;
            pixels[index + 1] = g;
            pixels[index + 2] = b;
            pixels[index + 3] = 255; // Alpha
        }
    }
    ctx.putImageData(imageData, 0, 0);

    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);

</script>
</html>