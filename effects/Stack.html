<!DOCTYPE html><html>
<head>
    <title>ORGB: Stack</title>
    <meta description="Fills and stacks your devices with a solid color.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="speed" label="Speed" type="number" min="1" max="200" default="50">
    <meta property="direction" label="Matrix Direction" type="list" values="Horizontal,Vertical" default="Horizontal">
    <meta property="random_colors" label="Random Colors" type="boolean" default="false">
    <meta property="user_color" label="Color" type="color" default="#ffffff">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="stack-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('stack-canvas');
const ctx = canvas.getContext('2d');

// --- ADDED: Disable image smoothing ---
ctx.imageSmoothingEnabled = false;
ctx.mozImageSmoothingEnabled = false;
ctx.webkitImageSmoothingEnabled = false;

const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
const imageData = ctx.createImageData(canvasWidth, canvasHeight);
const pixels = imageData.data;

// Effect state variables
let progress = 0.0; // Position within the current step (0 to 1)
let stop_point = 0; // Index where the moving edge currently is
let activeColor = [255, 255, 255];
// --- MODIFIED: Initialize with defaults ---
let lastDirection = typeof direction !== 'undefined' ? direction : "Horizontal";
let lastUserColor = typeof user_color !== 'undefined' ? user_color : '#ffffff';
let lastRandomColors = typeof random_colors !== 'undefined' ? random_colors : false;
let initialized = false; // Flag for initial setup

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex || hex.length < 7) return [255, 255, 255];
    try {
        return [parseInt(hex.slice(1, 3), 16), parseInt(hex.slice(3, 5), 16), parseInt(hex.slice(5, 7), 16)];
    } catch(e) { console.error("Invalid hex:", hex, e); return [255,255,255]; }
}

function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

function applyBrightness(rgb, brightness) {
    const b = Math.max(0, Math.min(1, brightness));
    return [rgb[0] * b, rgb[1] * b, rgb[2] * b];
}

// -------------------------------------------------------------------
// EFFECT LOGIC
// -------------------------------------------------------------------

function resetState(w, h) {
    // --- ADDED: Fallbacks used in reset ---
    const currentDirection = typeof direction !== 'undefined' ? direction : "Horizontal";
    const currentRandomColors = typeof random_colors !== 'undefined' ? random_colors : false;
    const currentUserColor = typeof user_color !== 'undefined' ? user_color : '#ffffff';

    const size = currentDirection === "Horizontal" ? w : h;
    stop_point = size > 0 ? size : 0; // Start fully "empty" (stop_point at max index + 1)
    progress = 0.0;

    if (currentRandomColors) {
        activeColor = randomRgb();
    } else {
        activeColor = hexToRgb(currentUserColor);
    }
     // Update trackers
    lastDirection = currentDirection;
    lastRandomColors = currentRandomColors;
    lastUserColor = currentUserColor;
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;

function update(currentTime) {
    // --- MODIFIED: Use performance.now() ---
    const now = performance.now();
    const deltaTime = lastTime === 0 ? 0.016 : (now - lastTime) / 1000; // Delta in seconds
    lastTime = now;

    if (isNaN(deltaTime) || deltaTime <= 0) {
        requestAnimationFrame(update);
        return;
    }

    // --- ADDED: Fallbacks for meta properties ---
    const currentSpeed = typeof speed !== 'undefined' ? speed : 50;
    const currentDirection = typeof direction !== 'undefined' ? direction : "Horizontal";
    const currentRandomColors = typeof random_colors !== 'undefined' ? random_colors : false;
    const currentUserColor = typeof user_color !== 'undefined' ? user_color : '#ffffff';

     // --- ADDED: Initialize on first run ---
     if (!initialized) {
        resetState(canvasWidth, canvasHeight); // Uses fallbacks internally
        initialized = true;
    }

    // --- Update State ---

    // Check if direction or color properties have changed
    if (currentDirection !== lastDirection) {
        resetState(canvasWidth, canvasHeight); // Reset includes updating trackers
    }
    else if (currentRandomColors !== lastRandomColors || (!currentRandomColors && currentUserColor !== lastUserColor)) {
         // Only change color if settings changed, don't reset progress/stop_point
        if (currentRandomColors) {
            activeColor = randomRgb();
        } else {
            activeColor = hexToRgb(currentUserColor);
        }
        lastRandomColors = currentRandomColors;
        lastUserColor = currentUserColor;
    }


    const size = currentDirection === "Horizontal" ? canvasWidth : canvasHeight;
    // Speed 1-200 -> Adjust progress increment scaling
    progress += (currentSpeed / 50.0) * deltaTime; // Speed 50 = 1 step/sec base

    // If progress >= 1, a step is completed
    if (progress >= 1.0) {
        const stepsCompleted = Math.floor(progress);
        stop_point -= stepsCompleted; // Move the stop point back
        progress %= 1.0; // Keep fractional part

        // If stack is full, reset
        if (stop_point <= 0) {
            resetState(canvasWidth, canvasHeight); // Full reset
            // Ensure stop_point is correct after reset
            stop_point = currentDirection === "Horizontal" ? canvasWidth : canvasHeight;
        }
         // Pick new color on step completion if random
         else if (currentRandomColors) {
            activeColor = randomRgb();
        }
    }

    // --- Render with ImageData ---
    const isHorizontal = currentDirection === "Horizontal";

    // Clear buffer (optional, can be slightly faster to just overwrite)
    /*
    for (let i = 0; i < pixels.length; i += 4) {
        pixels[i] = 0; pixels[i + 1] = 0; pixels[i + 2] = 0; pixels[i + 3] = 255;
    }
    */

    // Calculate the exact floating point position of the moving edge
    const movingPos = stop_point - progress;

    for (let i = 0; i < size; i++) { // Iterate through the primary dimension (width or height)
        let r=0, g=0, b=0; // Default to black (empty)

        if (i >= stop_point) { // Solid part of the stack
            r = activeColor[0];
            g = activeColor[1];
            b = activeColor[2];
        } else if (i > movingPos - 1 && i < movingPos + 1) { // Anti-aliasing zone (around moving edge)
             // Brightness based on proximity to the exact edge position
             // If i is just below movingPos, brightness fades from 0 to 1
             // If i is just above movingPos, brightness fades from 1 to 0
            const dist = movingPos - i; // positive if edge is ahead, negative if behind
            let brightness = 0;
            if (dist > 0 && dist <= 1) { // Pixel is right behind the moving edge
                brightness = dist; // Fades in (0 to 1)
            } else if (dist <= 0 && dist > -1) { // Pixel is right at/ahead of the edge
                 brightness = 1.0 + dist; // Fades out (1 to 0)
            }
            const fadedColor = applyBrightness(activeColor, brightness);
            r = fadedColor[0];
            g = fadedColor[1];
            b = fadedColor[2];
        }
        // else: Pixel is in the empty area (remains black)


        // Apply color to the corresponding row or column
        if (isHorizontal) {
            // Apply to column i
            for (let y = 0; y < canvasHeight; y++) {
                const pixelIndex = (y * canvasWidth + i) * 4;
                pixels[pixelIndex] = Math.round(r);
                pixels[pixelIndex + 1] = Math.round(g);
                pixels[pixelIndex + 2] = Math.round(b);
                pixels[pixelIndex + 3] = 255;
            }
        } else {
            // Apply to row i
            for (let x = 0; x < canvasWidth; x++) {
                const pixelIndex = (i * canvasWidth + x) * 4;
                pixels[pixelIndex] = Math.round(r);
                pixels[pixelIndex + 1] = Math.round(g);
                pixels[pixelIndex + 2] = Math.round(b);
                pixels[pixelIndex + 3] = 255;
            }
        }
    }

    ctx.putImageData(imageData, 0, 0);

    requestAnimationFrame(update);
}

// --- REMOVED: Initial call moved into update ---
// resetState(canvasWidth, canvasHeight);
requestAnimationFrame(update);
</script>
</html>