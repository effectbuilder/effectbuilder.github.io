<!DOCTYPE html><html>
<head>
    <title>ORGB: Fractal Motion</title>
    <meta description="A psychedelic, customizable fractal wave.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="speed" label="Speed" type="number" min="20" max="500" default="500">
    <meta property="thickness" label="Thickness" type="number" min="2" max="20" default="20">
    <meta property="frequency" label="Base Frequency" type="number" min="1" max="300" default="300">
    <meta property="amplitude" label="Base Amplitude" type="number" min="1" max="300" default="300">
    <meta property="random_colors" label="Random Colors" type="boolean" default="false">
    <meta property="user_color" label="Color" type="color" default="#ffffff" min="0" max="360">
    <meta property="background_color" label="Background" type="color" default="#000000" min="0" max="360">

    <meta property="m1" label="Freq m1" type="number" min="1" max="10000" default="560">
    <meta property="m2" label="Amp m2" type="number" min="1" max="10000" default="10000">
    <meta property="m3" label="Freq m3" type="number" min="1" max="10000" default="960">
    <meta property="m4" label="Time m4" type="number" min="1" max="1000" default="200">
    <meta property="m5" label="Amp m5" type="number" min="1" max="10000" default="7000">
    <meta property="m6" label="Freq m6" type="number" min="1" max="10000" default="6200">
    <meta property="m7" label="Time m7" type="number" min="1" max="100" default="30">
    <meta property="m8" label="Amp m8" type="number" min="1" max="10000" default="1">
    <meta property="m9" label="Freq m9" type="number" min="1" max="10000" default="1">
    <meta property="m10" label="Time m10" type="number" min="1" max="10000" default="1">
    <meta property="m11" label="Amp m11" type="number" min="1" max="10000" default="1">
    <meta property="m12" label="Final Amp m12" type="number" min="1" max="100" default="1">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="fractalmotion-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('fractalmotion-canvas');
const ctx = canvas.getContext('2d');

// --- ADDED: Disable image smoothing ---
ctx.imageSmoothingEnabled = false;
ctx.mozImageSmoothingEnabled = false;
ctx.webkitImageSmoothingEnabled = false;

const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
const imageData = ctx.createImageData(canvasWidth, canvasHeight);
const pixels = imageData.data;

// Effect state variables
let progress = 0.0;
let random_tick = 0.0;
let random_color = [255, 255, 255];
let next_random_color = [255, 0, 0];

// --- MODIFIED: Initialize with defaults ---
let lastRandomColors = typeof random_colors !== 'undefined' ? random_colors : false;
let lastUserColor = typeof user_color !== 'undefined' ? user_color : '#ffffff';
let lastBackgroundColor = typeof background_color !== 'undefined' ? background_color : '#000000';
let initialized = false; // Flag for initial color setup

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex || hex.length < 7) return [0, 0, 0];
     try {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return [r, g, b];
     } catch (e) {
         console.error("Invalid hex color:", hex, e);
         return [0,0,0]; // Fallback
     }
}

function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

function lerpColor(c1, c2, f) {
    // Clamp factor f between 0 and 1
    const factor = Math.max(0, Math.min(1, f));
    return [
        c1[0] * (1 - factor) + c2[0] * factor,
        c1[1] * (1 - factor) + c2[1] * factor,
        c1[2] * (1 - factor) + c2[2] * factor
    ];
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    // --- ADDED: Fallbacks for meta properties ---
    const currentSpeed = typeof speed !== 'undefined' ? speed : 500;
    const currentThickness = typeof thickness !== 'undefined' ? thickness : 20;
    const currentFrequency = typeof frequency !== 'undefined' ? frequency : 300;
    const currentAmplitude = typeof amplitude !== 'undefined' ? amplitude : 300;
    const currentRandomColors = typeof random_colors !== 'undefined' ? random_colors : false;
    const currentUserColor = typeof user_color !== 'undefined' ? user_color : '#ffffff';
    const currentBackgroundColor = typeof background_color !== 'undefined' ? background_color : '#000000';
    const currentM1 = typeof m1 !== 'undefined' ? m1 : 560;
    const currentM2 = typeof m2 !== 'undefined' ? m2 : 10000;
    const currentM3 = typeof m3 !== 'undefined' ? m3 : 960;
    const currentM4 = typeof m4 !== 'undefined' ? m4 : 200;
    const currentM5 = typeof m5 !== 'undefined' ? m5 : 7000;
    const currentM6 = typeof m6 !== 'undefined' ? m6 : 6200;
    const currentM7 = typeof m7 !== 'undefined' ? m7 : 30;
    const currentM8 = typeof m8 !== 'undefined' ? m8 : 1;
    const currentM9 = typeof m9 !== 'undefined' ? m9 : 1;
    const currentM10 = typeof m10 !== 'undefined' ? m10 : 1;
    const currentM11 = typeof m11 !== 'undefined' ? m11 : 1;
    const currentM12 = typeof m12 !== 'undefined' ? m12 : 1;

     // --- ADDED: Initialize color on first run ---
     if (!initialized) {
        if (currentRandomColors) {
            random_color = randomRgb();
            next_random_color = randomRgb();
            random_tick = 0;
        }
        lastRandomColors = currentRandomColors; // Sync initial state
        lastUserColor = currentUserColor;     // Sync initial state
        lastBackgroundColor = currentBackgroundColor;
        initialized = true;
    }


    const delta = (currentSpeed / 50.0) * deltaTime; // Use fallback speed

    // Update animation progress
    progress += 0.1 * delta;

    // Update random color transition
    if (currentRandomColors !== lastRandomColors || currentUserColor !== lastUserColor || currentBackgroundColor !== lastBackgroundColor) {
        // If switching to random, reset colors
        if (currentRandomColors && !lastRandomColors) {
             random_color = randomRgb();
             next_random_color = randomRgb();
             random_tick = 0;
        }
        lastRandomColors = currentRandomColors;
        lastUserColor = currentUserColor;
        lastBackgroundColor = currentBackgroundColor;
    }

    if (currentRandomColors) {
        random_tick += 0.005 * delta;
        if (random_tick >= 1.0) {
            random_color = next_random_color;
            next_random_color = randomRgb();
            random_tick %= 1.0; // Wrap tick around using modulo
        }
    }

    // Render with ImageData
    const backgroundRgb = hexToRgb(currentBackgroundColor); // Use fallback background
    const activeColor = currentRandomColors ? lerpColor(random_color, next_random_color, random_tick) : hexToRgb(currentUserColor); // Use fallback user color

    // --- MODIFIED: Use fallback variables for calculation ---
    const f = currentFrequency / 10000.0;
    const inv_val_mult = 0.01;
    const amp_val = currentAmplitude * inv_val_mult;
    const m1_val = currentM1 * inv_val_mult, m2_val = currentM2 * inv_val_mult, m3_val = currentM3 * inv_val_mult;
    const m4_val = currentM4 * inv_val_mult, m5_val = currentM5 * inv_val_mult, m6_val = currentM6 * inv_val_mult;
    const m7_val = currentM7 * inv_val_mult, m8_val = currentM8 * inv_val_mult, m9_val = currentM9 * inv_val_mult;
    const m10_val = currentM10 * inv_val_mult, m11_val = currentM11 * inv_val_mult, m12_val = currentM12 * inv_val_mult;
    const t = -progress * (currentSpeed / 100.0); // Use fallback speed here too

    const safeThickness = Math.max(1, currentThickness); // Prevent division by zero

    for (let y = 0; y < canvasHeight; y++) {
        for (let x = 0; x < canvasWidth; x++) {
            let wave_y = Math.sin(x * f);
            wave_y += Math.sin(x * f * m1_val + t) * m2_val;
            wave_y += Math.sin(x * f * m3_val + t * m4_val) * m5_val;
            wave_y += Math.sin(x * f * m6_val + t * m7_val) * m8_val;
            wave_y += Math.sin(x * f * m9_val + t * m10_val) * m11_val;
            wave_y *= 0.1 * amp_val * m12_val;

            wave_y = (1 + wave_y) * 0.5 * canvasHeight; // Map wave to canvas height

            const distance = Math.abs(wave_y - y);
            const pixelIndex = (y * canvasWidth + x) * 4;

            if (distance > safeThickness) {
                pixels[pixelIndex] = Math.round(backgroundRgb[0]);
                pixels[pixelIndex + 1] = Math.round(backgroundRgb[1]);
                pixels[pixelIndex + 2] = Math.round(backgroundRgb[2]);
            } else {
                // Lerp factor is 1 when distance is 0, 0 when distance is thickness
                const factor = 1.0 - (distance / safeThickness);
                const finalColor = lerpColor(backgroundRgb, activeColor, factor);
                pixels[pixelIndex] = Math.round(finalColor[0]);
                pixels[pixelIndex + 1] = Math.round(finalColor[1]);
                pixels[pixelIndex + 2] = Math.round(finalColor[2]);
            }
            pixels[pixelIndex + 3] = 255; // Alpha
        }
    }

    ctx.putImageData(imageData, 0, 0);

    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);
</script>
</html>