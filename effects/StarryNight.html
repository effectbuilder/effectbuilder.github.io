<!DOCTYPE html><html>
<head>
    <title>ORGB: Starry Night</title>
    <meta description="Selects a random LED and fades it in and out.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="star_density" label="Star Density (%)" type="number" min="10" max="90" default="50">
    <meta property="fade_in_speed" label="Fade In Speed" type="number" min="1" max="100" default="50">
    <meta property="fade_out_speed" label="Fade Out Speed" type="number" min="1" max="100" default="50">
    <meta property="star_on_time" label="Star On Time" type="number" min="1" max="100" default="50">

    <meta property="background_color" label="Background Color" type="color" default="#000000">
    <meta property="background_brightness" label="Background Brightness (%)" type="number" min="0" max="100" default="20">

    <meta property="random_colors" label="Random Star Colors" type="boolean" default="true">
    <meta property="color1" label="Star Color 1" type="color" default="#ffffff">
    <meta property="color2" label="Star Color 2" type="color" default="#ffff00">
    <meta property="color3" label="Star Color 3" type="color" default="#00ffff">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="starrynight-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('starrynight-canvas');
const ctx = canvas.getContext('2d');

// --- ADDED: Disable image smoothing ---
ctx.imageSmoothingEnabled = false;
ctx.mozImageSmoothingEnabled = false;
ctx.webkitImageSmoothingEnabled = false;

const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
const imageData = ctx.createImageData(canvasWidth, canvasHeight);
const pixels = imageData.data;

let stars = []; // This will store the state for each star

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex || hex.length < 7) return [255, 255, 255];
     try {
        return [parseInt(hex.slice(1, 3), 16), parseInt(hex.slice(3, 5), 16), parseInt(hex.slice(5, 7), 16)];
     } catch(e) {
         console.error("Invalid hex:", hex, e);
         return [255,255,255];
     }
}

function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

function lerpColor(c1, c2, f) {
    const factor = Math.max(0, Math.min(1, f));
    return [
        c1[0] * (1 - factor) + c2[0] * factor,
        c1[1] * (1 - factor) + c2[1] * factor,
        c1[2] * (1 - factor) + c2[2] * factor
    ];
}

function applyBrightness(rgb, brightness) {
     const b = Math.max(0, Math.min(1, brightness));
    return [rgb[0] * b, rgb[1] * b, rgb[2] * b];
}

function getStarColor() {
    const currentRandomColors = typeof random_colors !== 'undefined' ? random_colors : true;
    const c1 = typeof color1 !== 'undefined' ? color1 : "#ffffff";
    const c2 = typeof color2 !== 'undefined' ? color2 : "#ffff00";
    const c3 = typeof color3 !== 'undefined' ? color3 : "#00ffff";

    const userColors = [c1, c2, c3].filter(c => c && c !== '');
    if (currentRandomColors) {
        return randomRgb();
    } else if (userColors.length > 0) {
        return hexToRgb(userColors[Math.floor(Math.random() * userColors.length)]);
    }
    return [255, 255, 255]; // Failsafe white
}

// -------------------------------------------------------------------
// STAR LOGIC
// -------------------------------------------------------------------

function initializeStars() {
    const currentStarDensity = typeof star_density !== 'undefined' ? star_density : 50;
    const currentRandomColors = typeof random_colors !== 'undefined' ? random_colors : true; // Needed for initial color
    const c1 = typeof color1 !== 'undefined' ? color1 : "#ffffff"; // Needed for initial color
    const c2 = typeof color2 !== 'undefined' ? color2 : "#ffff00"; // Needed for initial color
    const c3 = typeof color3 !== 'undefined' ? color3 : "#00ffff"; // Needed for initial color

    stars = [];
    const totalPixels = canvasWidth * canvasHeight;
    const starCount = Math.floor(totalPixels * (currentStarDensity / 100.0));

    for(let i = 0; i < starCount; i++) {
        stars.push({
            state: "off",
            pixelIndex: -1,
            color: getStarColor(), // Use function with fallbacks
            stateStartTime: 0,
            onDuration: 1000,
            fadeDuration: 1000
        });
    }
     // Update 'last' variables after initialization
    lastDensity = currentStarDensity;
    lastRandomColors = currentRandomColors;
    lastColor1 = c1; lastColor2 = c2; lastColor3 = c3;
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
// Use initial defaults for 'last' variables
let lastDensity = typeof star_density !== 'undefined' ? star_density : 50;
let lastRandomColors = typeof random_colors !== 'undefined' ? random_colors : true;
let lastColor1 = typeof color1 !== 'undefined' ? color1 : '#ffffff';
let lastColor2 = typeof color2 !== 'undefined' ? color2 : '#ffff00';
let lastColor3 = typeof color3 !== 'undefined' ? color3 : '#00ffff';
let lastBackgroundColor = typeof background_color !== 'undefined' ? background_color : '#000000';
let lastBackgroundBrightness = typeof background_brightness !== 'undefined' ? background_brightness : 20;
let lastFadeInSpeed = typeof fade_in_speed !== 'undefined' ? fade_in_speed : 50;
let lastFadeOutSpeed = typeof fade_out_speed !== 'undefined' ? fade_out_speed : 50;
let lastStarOnTime = typeof star_on_time !== 'undefined' ? star_on_time : 50;
let initialized = false;


function update(currentTime) {
    const now = performance.now();
    const deltaTime = lastTime === 0 ? 16 : (now - lastTime); // Milliseconds
    lastTime = now;

    if (isNaN(deltaTime) || deltaTime <= 0) {
        requestAnimationFrame(update);
        return;
    }

    // --- ADDED: Fallbacks for meta properties ---
    const currentStarDensity = typeof star_density !== 'undefined' ? star_density : 50;
    const currentFadeInSpeed = typeof fade_in_speed !== 'undefined' ? Math.max(1, fade_in_speed) : 50;
    const currentFadeOutSpeed = typeof fade_out_speed !== 'undefined' ? Math.max(1, fade_out_speed) : 50;
    const currentStarOnTime = typeof star_on_time !== 'undefined' ? Math.max(1, star_on_time) : 50;
    const currentBackgroundColor = typeof background_color !== 'undefined' ? background_color : '#000000';
    const currentBackgroundBrightness = typeof background_brightness !== 'undefined' ? background_brightness : 20;
    const currentRandomColors = typeof random_colors !== 'undefined' ? random_colors : true;
    const c1 = typeof color1 !== 'undefined' ? color1 : '#ffffff';
    const c2 = typeof color2 !== 'undefined' ? color2 : '#ffff00';
    const c3 = typeof color3 !== 'undefined' ? color3 : '#00ffff';

     // --- ADDED: Initialize on first run ---
     if (!initialized) {
        initializeStars(); // Uses fallbacks internally
        // Sync 'last' variables
        lastDensity = currentStarDensity;
        lastRandomColors = currentRandomColors;
        lastColor1 = c1; lastColor2 = c2; lastColor3 = c3;
        lastBackgroundColor = currentBackgroundColor;
        lastBackgroundBrightness = currentBackgroundBrightness;
        lastFadeInSpeed = currentFadeInSpeed;
        lastFadeOutSpeed = currentFadeOutSpeed;
        lastStarOnTime = currentStarOnTime;
        initialized = true;
    }


    // Re-initialize if relevant settings change
    if(currentStarDensity !== lastDensity || currentRandomColors !== lastRandomColors ||
       c1 !== lastColor1 || c2 !== lastColor2 || c3 !== lastColor3 ||
       currentFadeInSpeed !== lastFadeInSpeed || currentFadeOutSpeed !== lastFadeOutSpeed ||
       currentStarOnTime !== lastStarOnTime)
    {
        initializeStars(); // Uses fallbacks internally
        // Update 'last' trackers after re-init
        lastDensity = currentStarDensity;
        lastRandomColors = currentRandomColors;
        lastColor1 = c1; lastColor2 = c2; lastColor3 = c3;
        lastFadeInSpeed = currentFadeInSpeed;
        lastFadeOutSpeed = currentFadeOutSpeed;
        lastStarOnTime = currentStarOnTime;
    }

     // Update background trackers if they change
     if (currentBackgroundColor !== lastBackgroundColor) lastBackgroundColor = currentBackgroundColor;
     if (currentBackgroundBrightness !== lastBackgroundBrightness) lastBackgroundBrightness = currentBackgroundBrightness;


    const backgroundRgb = applyBrightness(hexToRgb(currentBackgroundColor), currentBackgroundBrightness / 100.0);

    // --- Update Star States ---
    const activePixelIndices = new Set();
    stars.forEach(s => { if (s.pixelIndex !== -1) activePixelIndices.add(s.pixelIndex); });

    // Base durations scaled by sliders (1-100), higher speed = shorter duration
    const baseFadeDuration = 4000; // 4 seconds base fade at speed 50
    const baseOnDuration = 2000;   // 2 seconds base on time at speed 50

    for(const star of stars) {
        if(star.state === "off") {
            // Activation chance - adjust factors as needed
            const activeRatio = activePixelIndices.size / (canvasWidth * canvasHeight);
            const chance = (0.0005 + (1 - activeRatio) * 0.01) * (deltaTime / 16); // Lower base chance
            if (Math.random() < chance) {
                let newPixelIndex = -1;
                let attempts = 0;
                const maxAttempts = 50;
                do {
                    newPixelIndex = Math.floor(Math.random() * canvasWidth * canvasHeight);
                    attempts++;
                    if (attempts > maxAttempts) { newPixelIndex = -1; break; }
                } while (activePixelIndices.has(newPixelIndex));

                if (newPixelIndex !== -1) {
                    star.pixelIndex = newPixelIndex;
                    activePixelIndices.add(newPixelIndex);

                    star.state = "fadeIn";
                    star.stateStartTime = now;
                    star.fadeDuration = (baseFadeDuration * (50 / currentFadeInSpeed)) * (0.75 + Math.random() * 0.5);
                }
            }
        }
        else if (star.state === "fadeIn") {
            if (now - star.stateStartTime >= star.fadeDuration) {
                star.state = "on";
                star.stateStartTime = now;
                star.onDuration = (baseOnDuration * (50 / currentStarOnTime)) * (0.75 + Math.random() * 0.5); // Use correct variable
            }
        }
        else if (star.state === "on") {
            if(now - star.stateStartTime >= star.onDuration) {
                star.state = "fadeOut";
                star.stateStartTime = now;
                star.fadeDuration = (baseFadeDuration * (50 / currentFadeOutSpeed)) * (0.75 + Math.random() * 0.5);
            }
        }
        else if (star.state === "fadeOut") {
            if(now - star.stateStartTime >= star.fadeDuration) {
                star.state = "off";
                activePixelIndices.delete(star.pixelIndex);
                star.pixelIndex = -1;
                star.color = getStarColor(); // Uses fallbacks internally
            }
        }
    }

    // --- Render ---
    for(let i = 0; i < pixels.length; i += 4) {
        pixels[i] = Math.round(backgroundRgb[0]);
        pixels[i+1] = Math.round(backgroundRgb[1]);
        pixels[i+2] = Math.round(backgroundRgb[2]);
        pixels[i+3] = 255;
    }

    for(const star of stars) {
        if(star.pixelIndex === -1) continue;

        let finalColor = backgroundRgb;
        const elapsed = now - star.stateStartTime;
        const duration = star.fadeDuration || 1; // Prevent division by zero

        if(star.state === "fadeIn") {
            const factor = Math.min(1.0, elapsed / duration);
            finalColor = lerpColor(backgroundRgb, star.color, factor * factor);
        } else if (star.state === "on") {
            finalColor = star.color;
        } else if (star.state === "fadeOut") {
            const factor = Math.max(0.0, 1.0 - (elapsed / duration));
            finalColor = lerpColor(backgroundRgb, star.color, factor * factor);
        }

        const index = star.pixelIndex * 4;
        pixels[index] = Math.round(finalColor[0]);
        pixels[index+1] = Math.round(finalColor[1]);
        pixels[index+2] = Math.round(finalColor[2]);
    }

    ctx.putImageData(imageData, 0, 0);

    requestAnimationFrame(update);
}

// Initial call
// initializeStars(); // Moved initialization into first run of update()
requestAnimationFrame(update);
</script>
</html>