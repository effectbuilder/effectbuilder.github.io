<!DOCTYPE html>
<html>
<head>
    <title>Particle EQ Bars</title>
    <meta description="A particle audio visualizer where columns are built from individual particles affected by gravity and Perlin noise-driven turbulence." />
    <meta publisher="Jose Miranda" />

    <meta property="barCount" label="Bar/Point Count (Max 64)" type="number" default="8" min="8" max="64">
    <meta property="particleSize" label="Particle Size" type="number" default="2" min="1" max="5">
    <meta property="logScale" label="Logarithmic Scale" type="number" default="10" min="10" max="100">
    <meta property="decaySpeed" label="Decay Speed" type="number" default="1" min="1" max="50">
    <meta property="gravity" label="Gravity Strength" type="number" default="0" min="0" max="100">
    <meta property="turbulence" label="Noise Turbulence" type="number" default="14" min="0" max="100">
    <meta property="glow" label="Glow (Trail Amount)" type="number" default="50" min="50" max="99">
    <meta property="mirrorLine" label="Mirror Line Height (%)" type="number" default="20" min="0" max="50">
    <meta property="sparkleCount" label="Sparkle Count" type="number" default="2" min="0" max="15">
    <meta property="smearAmount" label="Smear Amount (px)" type="number" default="2" min="0" max="20">
    <meta property="colorMode" label="Color Mode" type="combobox" values="Rainbow,Vertical Gradient,Vaporwave,Ocean,Heat,Static,Pastel,Cyberpunk,Forest,Neon" default="Rainbow">
    <meta property="staticColor" label="Static Color" type="color" default="#FF00FF">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }
    </style>

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="particle-eq-canvas" width="320" height="200"></canvas>
</body>

<script>
    // -------------------------------------------------------------------
    // SETUP
    // -------------------------------------------------------------------
    if (typeof(barCount) === 'undefined') var barCount = 8;
    if (typeof(particleSize) === 'undefined') var particleSize = 2;
    if (typeof(logScale) === 'undefined') var logScale = 10;
    if (typeof(decaySpeed) === 'undefined') var decaySpeed = 1;
    if (typeof(gravity) === 'undefined') var gravity = 0;
    if (typeof(turbulence) === 'undefined') var turbulence = 14;
    if (typeof(glow) === 'undefined') var glow = 50;
    if (typeof(mirrorLine) === 'undefined') var mirrorLine = 20;
    if (typeof(sparkleCount) === 'undefined') var sparkleCount = 2;
    if (typeof(smearAmount) === 'undefined') var smearAmount = 2;
    if (typeof(colorMode) === 'undefined') var colorMode = 'Rainbow';
    if (typeof(staticColor) === 'undefined') var staticColor = '#FF00FF';

    const canvas = document.getElementById('particle-eq-canvas');
    const ctx = canvas.getContext('2d');
    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;
    const eqMode = 'Bars'; // Fixed to 'Bars' mode
    const BOUNCE_DURATION = 500; // Hard-coded bounce flash duration (ms)

    // Create an off-screen canvas to render the effect *before* mirroring
    const offscreenCanvas = document.createElement('canvas');
    offscreenCanvas.width = canvasWidth;
    offscreenCanvas.height = canvasHeight;
    const offCtx = offscreenCanvas.getContext('2d');
    offCtx.imageSmoothingEnabled = false;

    // Create a *second* off-screen canvas for the smear effect
    const smearCanvas = document.createElement('canvas');
    smearCanvas.width = canvasWidth;
    smearCanvas.height = canvasHeight; // Full height needed for transformations
    const smearCtx = smearCanvas.getContext('2d');
    smearCtx.imageSmoothingEnabled = false;

    ctx.imageSmoothingEnabled = false;

    let activeParticles = [];
    let activeSparkles = []; // Array for sparkles
    let time = 0;

    const barHeights = [];
    let lastBarCount = 0;
    let lastMirrorLine = 0; // Track the previous mirror line height value

    // --------------------------------

    // --- Perlin Noise Setup (Unchanged) ---
    const SimplexNoise = (function () {
        const F3 = 1.0 / 3.0, G3 = 1.0 / 6.0;
        const grad3 = new Float32Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1]);
        const p = new Uint8Array(256);
        for (let i = 0; i < 256; i++) p[i] = i;
        for (let i = 255; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [p[i], p[j]] = [p[j], p[i]]; }
        const perm = new Uint8Array(512);
        const permMod12 = new Uint8Array(512);
        for (let i = 0; i < 512; i++) { perm[i] = p[i & 255]; permMod12[i] = perm[i] % 12; }

        return {
            noise3D: function (xin, yin, zin) {
                let n0, n1, n2, n3;
                const s = (xin + yin + zin) * F3;
                const i = Math.floor(xin + s), j = Math.floor(yin + s), k = Math.floor(zin + s);
                const t = (i + j + k) * G3;
                const X0 = i - t, Y0 = j - t, Z0 = k - t;
                const x0 = xin - X0, y0 = yin - Y0, z0 = zin - Z0;
                let i1, j1, k1, i2, j2, k2;
                if (x0 >= y0) {
                    if (y0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
                    else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; }
                    else { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; }
                } else {
                    if (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; }
                    else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; }
                    else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
                }
                const x1 = x0 - i1 + G3, y1 = y0 - j1 + G3, z1 = z0 - k1 + G3;
                const x2 = x0 - i2 + 2.0 * G3, y2 = y0 - j2 + 2.0 * G3, z2 = z0 - k2 + 2.0 * G3;
                const x3 = x0 - 1.0 + 3.0 * G3, y3 = y0 - 1.0 + 3.0 * G3, z3 = z0 - 1.0 + 3.0 * G3;
                const ii = i & 255, jj = j & 255, kk = k & 255;
                const gi0 = permMod12[ii + perm[jj + perm[kk]]];
                const gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]];
                const gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]];
                const gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]];
                let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
                if (t0 < 0) n0 = 0.0;
                else { t0 *= t0; n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0 + grad3[gi0 + 2] * z0); }
                let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
                if (t1 < 0) n1 = 0.0;
                else { t1 *= t1; n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1 + grad3[gi1 + 2] * z1); }
                let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
                if (t2 < 0) n2 = 0.0;
                else { t2 *= t2; n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2 + grad3[gi2 + 2] * z2); }
                let t3 = 0.6 - x3 * x3 - y3 * x3 - z3 * z3;
                if (t3 < 0) n3 = 0.0;
                else { t3 *= t3; n3 = t3 * t3 * (grad3[gi3] * x3 + grad3[gi3 + 1] * y3 + grad3[gi3 + 2] * z3); }
                return 32.0 * (n0 + n1 + n2 + n3);
            }
        };
    })();


    // -------------------------------------------------------------------
    // UTILITIES: Color & Audio
    // -------------------------------------------------------------------

    function hexToRgb(hex) {
        if (!hex || hex.length < 7) return [0, 0, 0];
        const r = parseInt(hex.slice(1, 3), 16) || 0;
        const g = parseInt(hex.slice(3, 5), 16) || 0;
        const b = parseInt(hex.slice(5, 7), 16) || 0;
        return [r, g, b];
    }

    function hsvToRgb(h, s, v) {
        let r, g, b;
        h *= 360;
        s = 1; v = 1;
        const i = Math.floor(h / 60) % 6;
        const f = h / 60 - i;
        const p = v * (1 - s);
        const q = v * (1 - f * s);
        const t = v * (1 - (1 - f) * s);
        switch (i) {
            case 0: r = v, g = t, b = p; break; case 1: r = q, g = v, b = p; break;
            case 2: r = p, g = v, b = t; break; case 3: r = p, g = q, b = v; break;
            case 4: r = t, g = p, b = v; break; case 5: r = v, g = p, b = q; break;
        }
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    function getColor(barIndex, totalBars, yPosNormalized, colorMode, staticColorRgb) {
        let h, s = 1, v = 1;

        if (colorMode === 'Static') {
            return staticColorRgb;
        }

        let finalHue;
        const barHue = barIndex / totalBars;
        const yHue = 1.0 - yPosNormalized;

        switch (colorMode) {
            case 'Vertical Gradient':
                finalHue = (barHue * 0.5 + yHue * 0.5) % 1.0;
                break;
            case 'Vaporwave':
                finalHue = ((barHue * 0.3 + 0.75) + yHue * 0.1) % 1.0;
                break;
            case 'Ocean':
                finalHue = ((barHue * 0.3 + 0.5) + yHue * 0.1) % 1.0;
                break;
            case 'Heat':
                finalHue = ((barHue * 0.17) + yHue * 0.05) % 1.0;
                break;
            case 'Pastel':
                finalHue = (barHue + yHue * 0.1) % 1.0;
                s = 0.5; 
                v = 1.0;
                break;
            case 'Cyberpunk':
                finalHue = ((barHue * 0.5) + 0.7) % 1.0; 
                break;
            case 'Forest':
                finalHue = ((barHue * 0.3) + 0.25) % 1.0; 
                break;
            case 'Neon':
                finalHue = (barHue * 0.8) % 1.0;
                s = 1.0;
                v = 1.0;
                break;
            case 'Rainbow':
            default:
                finalHue = barHue;
                break;
        }

        return hsvToRgb(finalHue, s, v);
    }

    function getAudioLevel(audioData, barIndex, totalBars, logAmount, effectHeight) {
        let audioLevel = 0;

        // Use 'Bars' mode logic only
        const freqStart = Math.floor(barIndex * 200 / totalBars);
        const freqEnd = Math.min(200, Math.floor((barIndex + 1) * 200 / totalBars));

        for (let j = freqStart; j < freqEnd; j++) {
            audioLevel = Math.max(audioLevel, Math.abs(audioData[j]) / 128.0);
        }

        // Apply logarithmic scaling
        const logLevel = Math.pow(audioLevel, logAmount);

        // Calculate target Y position based on the effect height
        return effectHeight - (logLevel * effectHeight * 0.95);
    }


    // -------------------------------------------------------------------
    // PARTICLE LOGIC
    // -------------------------------------------------------------------

    class EQParticle {
        constructor(x, y, barIndex, colorRgb) {
            this.x = x;
            this.y = y;
            this.vx = 0;
            this.vy = 0;
            this.barIndex = barIndex;
            this.color = colorRgb;
            this.isConstrained = true;
            this.bounceTimer = 0; // Timer for the bounce flash
            this.bounceCount = 0; // Track bounces
        }

        update(deltaTime, barWidth, gravity, turbulence, particleSize, effectHeight, sparkleCount) { 

            const dt = deltaTime;

            // Decrease bounce timer *every frame* regardless of state
            if (this.bounceTimer > 0) {
                this.bounceTimer -= dt * 1000; // deltaTime is in seconds, duration is in ms
            }

            const barLeft = this.barIndex * barWidth;
            const barRight = barLeft + barWidth - particleSize;
            
            const bounceY = effectHeight; 

            // --- Get Target Y ---
            let barHeightY;
            if (this.isConstrained) {
                if (!barHeights[this.barIndex]) return;
                barHeightY = barHeights[this.barIndex].currentY;
            } else {
                barHeightY = bounceY;
            }

            // 1. Noise / Turbulence
            const noiseScale = (100 - turbulence) * 0.005 + 0.001;
            const noiseX = SimplexNoise.noise3D(this.x * noiseScale, this.y * noiseScale, time * 0.05);
            const noiseY = SimplexNoise.noise3D(this.x * noiseScale + 10, this.y * noiseScale + 5, time * 0.05);
            const turbulenceFactor = (turbulence / 100.0);

            // 2. Vertical Movement (Fountain Physics)
            if (this.y + particleSize > barHeightY) { 
                const dist = (this.y + particleSize) - barHeightY;
                this.vy -= (dist * 0.5 + (gravity * 0.5)) * dt;
            } else {
                this.vy += (gravity * 0.5) * dt;
            }
            this.vy += noiseY * 0.5 * turbulenceFactor;

            // 3. Horizontal Movement
            this.vx += noiseX * 1.0 * turbulenceFactor;

            // Horizontal constraints (only in 'Bars' mode, while constrained)
            if (this.isConstrained) {
                const center = barLeft + barWidth / 2;
                const distToCenter = center - this.x;
                this.vx += distToCenter * 0.1 * dt;

                if (this.x < barLeft || this.x > barRight) {
                    this.isConstrained = false;
                }
            }

            // 4. Damping (friction)
            this.vx *= 0.95;
            this.vy *= 0.90;

            // 5. Update position *before* collision check
            this.y += this.vy;
            this.x += this.vx;

            // 6. Mirror Line Collision & Bounce Logic
            if (!this.isConstrained && (this.y + particleSize) >= effectHeight) {
                
                this.y = effectHeight - particleSize; 

                if (this.vy > 0.5 && this.bounceTimer <= 0) {
                    this.bounceTimer = BOUNCE_DURATION;
                    
                    this.vy *= -0.75; 

                    this.bounceCount++;

                    // Sparkle check is here, using the passed sparkleCount
                    if (sparkleCount > 0) {
                        spawnSparkles(this.x, effectHeight, particleSize, sparkleCount);
                    }

                } else {
                    if (Math.abs(this.vy) > 0.1) {
                        this.vy *= -0.75; 
                        this.bounceCount++;
                    } else {
                        this.vy = 0;
                    }
                }
                this.vx *= 0.8;
            }
        }

        render(context, size, effectHeight) {
            const alpha = Math.min(1.0, (effectHeight - this.y + 5) / 20.0);
            const radius = size / 2.0;

            const isBouncing = this.bounceTimer > 0;

            const renderColor = isBouncing ? [255, 255, 255] : this.color;

            context.fillStyle = `rgba(${renderColor[0]}, ${renderColor[1]}, ${renderColor[2]}, ${alpha})`;

            context.beginPath();
            context.arc(
                Math.floor(this.x) + radius,
                Math.floor(this.y) + radius,
                radius,
                0, 2 * Math.PI
            );
            context.fill();
        }
    }

    // --- SPARKLE CLASS (Unchanged) ---
    class Sparkle {
        constructor(x, y, maxSize) { 
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * (4 + Math.random() * 2); 
            this.vy = (Math.random() - 1.0) * (2 + Math.random() * 4); 
            this.life = 0.5 + Math.random() * 1.0; 
            this.size = Math.floor(Math.random() * Math.max(1, maxSize * 1.5)) + 1; 
            this.gravityMultiplier = 0.5 + Math.random(); 
            this.bounceCount = 0; 
        }

        update(deltaTime, gravity, effectHeight) { 
            const dt = deltaTime;
            
            this.vy += (gravity * this.gravityMultiplier * 0.5) * dt; 

            this.x += this.vx * dt * 60; 
            this.y += this.vy * dt * 60;
            this.life -= dt / (this.life * 0.8); 
            
            // Sparkle Collision Logic
            if (this.y + this.size >= effectHeight) {
                this.y = effectHeight - this.size; 
                
                if (this.vy > 0.1) {
                    this.vy *= -0.4; 
                    this.vx *= 0.8;  
                    this.bounceCount++; 
                } else {
                    this.vy = 0; 
                }
            }
        }

        render(context) {
            if (this.life <= 0) return;
            const alpha = Math.min(1.0, this.life * 2); 
            context.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            context.fillRect(this.x, this.y, this.size, this.size);
        }
    }

    // --- SPARKLE SPAWNER (Unchanged) ---
    function spawnSparkles(x, y, particleSize, sparkleCount) {
        if (sparkleCount <= 0) return;

        const centerX = x + particleSize / 2;
        const centerY = y; 
        for (let i = 0; i < sparkleCount; i++) {
            activeSparkles.push(new Sparkle(centerX, centerY, Math.max(1, particleSize)));
        }
    }


    // Initialize Bar Heights
    function initBarData(barCount, effectHeight) {
        const oldBarHeightLength = barHeights.length;
        barHeights.length = barCount;

        for (let i = 0; i < barCount; i++) {
            if (i < oldBarHeightLength) {
                // Adjust existing bars to the new maximum height
                const bar = barHeights[i];
                
                // Clamp current and target height to the new visual floor
                bar.currentY = Math.min(bar.currentY, effectHeight);
                bar.targetY = Math.min(bar.targetY, effectHeight);

            } else {
                // Initialize new bars
                barHeights[i] = {
                    currentY: effectHeight, 
                    targetY: effectHeight    
                };
            }
        }
    }

    // Create a new particle at the bottom of a bar
    function spawnParticle(barIndex, barWidth, barCount, colorMode, staticColorRgb, effectHeight) {
        const currentParticleSize = window.particleSize || 2;
        const barLeft = barIndex * barWidth;
        const x = barLeft + Math.random() * barWidth;
        const y = effectHeight - currentParticleSize * 3; 

        const yPosNorm = y / effectHeight; 
        const colorRgb = getColor(barIndex, barCount, yPosNorm, colorMode, staticColorRgb);

        activeParticles.push(new EQParticle(x, y, barIndex, colorRgb));
    }


    // -------------------------------------------------------------------
    // MAIN ANIMATION LOOP
    // -------------------------------------------------------------------

    let lastTime = 0;
    
    // --- Audio Fallback State (Moved here to match your logic for other vars) ---
    let randomAudio = new Int8Array(200);
    let randomAudioTime = 0;
    // ---------------------------------------------------------------------------

    function update(currentTime) {
        if (!currentTime) currentTime = 0;
        let deltaTime = (currentTime - lastTime) / 1000;
        if (deltaTime > 0.033) deltaTime = 0.033;
        if (deltaTime <= 0) deltaTime = 1/60;
        lastTime = currentTime;

        // --- Get Properties ---
        const currentBarCount = window.barCount || 32;
        const currentParticleSize = window.particleSize || 2;
        const currentLogScale = (window.logScale || 60) / 100.0;
        const currentDecaySpeed = window.decaySpeed || 5;
        const currentGlow = window.glow || 95;
        const currentColorMode = window.colorMode || "Rainbow";
        const currentStaticColor = window.staticColor || "#FF00FF";
        const staticColorRgb = hexToRgb(currentStaticColor);
        const currentGravity = (window.gravity || 20);
        const currentTurbulence = (window.turbulence || 10);
        
        // FIX: Ensure currentMirrorLine defaults to 0 if undefined
        const currentMirrorLine = window.mirrorLine || 0; 
        
        // Correctly handle 0 as a valid sparkleCount value.
        const currentSparkleCount = (window.sparkleCount === undefined || window.sparkleCount === null) 
                                     ? 5 : window.sparkleCount;
        
        const currentSmearAmount = window.smearAmount !== undefined ? window.smearAmount : 5;
        const currentSmearSteps = window.smearSteps !== undefined ? window.smearSteps : 3;
        // NOTE: smearSteps is not a meta property, keeping it local to 3 for consistency.
        // const currentSmearSteps = 3; 


        const barWidth = canvasWidth / currentBarCount;
        const decayAmount = (currentDecaySpeed / 10.0) * (deltaTime * 100);
        const verticalPushSpeed = 0.2;
        const spawnRateFactor = 0.2;

        // Define the effect and mirror areas based on property
        const mirrorPercent = currentMirrorLine / 100.0;
        // effectHeight is the Y position of the mirror line (or canvas bottom)
        const effectHeight = canvasHeight * (1.0 - mirrorPercent);
        const mirrorHeight = canvasHeight * mirrorPercent;

        // CHECK: Recalculate bar data if bar count OR mirror line changes.
        const isBarCountChanging = currentBarCount !== lastBarCount;
        const isMirrorLineChanging = currentMirrorLine !== lastMirrorLine;

        if (isBarCountChanging || isMirrorLineChanging) {
            initBarData(currentBarCount, effectHeight);
            
            // Only clear particles if the bar count changes (which changes particle identity)
            if (isBarCountChanging) {
                activeParticles.length = 0;
            }
            
            // Clear sparkles if the bounce area changes, preventing them from floating above the new line
            if (isMirrorLineChanging) {
                activeSparkles.length = 0;
            }

            // NEW: SEED PARTICLES on bar count change OR on initial load (lastBarCount === 0)
            if (isBarCountChanging || lastBarCount === 0) { 
                for (let i = 0; i < currentBarCount; i++) {
                    // Seed 2 particles per bar segment
                    spawnParticle(i, barWidth, currentBarCount, currentColorMode, staticColorRgb, effectHeight);
                    spawnParticle(i, barWidth, currentBarCount, currentColorMode, staticColorRgb, effectHeight);
                }
            }


            lastBarCount = currentBarCount;
            lastMirrorLine = currentMirrorLine; // Update tracker
        }

        // ---------------------------------------------------------------------------------
        // --- START AUDIO FALLBACK MODIFICATION ---
        // ---------------------------------------------------------------------------------
        let audioData;
        if (typeof engine !== 'undefined' && engine.audio && engine.audio.freq) {
            audioData = new Int8Array(engine.audio.freq);
        } else {
            // Fallback: Use simple sine wave data for animation in a browser environment
            randomAudioTime += deltaTime * 2;
            // --- Synthetic, smoothly-varying audio spectrum ---
            // Combines slow bass envelope, moving harmonics and low-level noise so the signal looks natural
            const bassEnv = Math.max(0, Math.sin(randomAudioTime * 1.2)) * 0.9; // slow bass pulse 0..0.9
            for (let i = 0; i < 200; i++) {
                const pos = i / 200; // 0..1 across the spectrum

                // Moving harmonic content (multiple sine layers)
                const harmonic = Math.sin(pos * Math.PI * 2 * 2.5 + randomAudioTime * 3.0) * 0.5;
                const formant = Math.sin(pos * 10 + randomAudioTime * 1.4) * 0.35;
                const micro = Math.sin(i * 0.37 + randomAudioTime * 5.2) * 0.12;

                // Gentle pseudo-random noise (smooth in time)
                const noiseSeed = i * 12.9898 + randomAudioTime * 2.7;
                const noise = (Math.abs(Math.sin(noiseSeed) * 43758.5453) % 1 - 0.5) * 0.25;

                // Spectral roll-off so highs are generally lower than lows
                const rollOff = 1.0 - pos * 0.85;

                // Combine layers and add bass envelope (bass affects lower bins more)
                let value = (harmonic * 0.55 + formant * 0.35 + micro * 0.25 + noise * 0.9) * rollOff;
                value += bassEnv * (1.0 - pos * 0.7);

                // Scale to signed Int8 range (-127..127) and clamp
                let v = Math.floor(value * 127);
                if (v > 127) v = 127;
                if (v < -127) v = -127;
                randomAudio[i] = v;
            }
            audioData = randomAudio;
        }
        // ---------------------------------------------------------------------------------
        // --- END AUDIO FALLBACK MODIFICATION ---
        // ---------------------------------------------------------------------------------


        // --- Drawing Logic ---

        // 1. Fade the OFF-SCREEN canvas (which holds the trails)
        offCtx.globalCompositeOperation = 'source-over';
        let effectiveFadeAlpha = 1.0 - (currentGlow / 100.0);

        // If sparkles are disabled (count=0), override the fade alpha to 1.0
        // for the first frame to instantly clear all residual sparkle trails.
        if (currentSparkleCount === 0 && activeSparkles.length > 0) {
            effectiveFadeAlpha = 1.0;
            activeSparkles.length = 0; // Clear the array instantly
        }
        
        offCtx.fillStyle = `rgba(0, 0, 0, ${effectiveFadeAlpha})`;
        offCtx.fillRect(0, 0, canvasWidth, canvasHeight); // Fade the whole buffer

        // 2. Set blend mode for NEW particles on the OFF-SCREEN canvas
        offCtx.globalCompositeOperation = 'lighter';

        // --- Update Bar Heights and Spawn Particles ---
        for (let i = 0; i < currentBarCount; i++) {
            const bar = barHeights[i];
            const targetY = getAudioLevel(audioData, i, currentBarCount, currentLogScale, effectHeight);

            bar.targetY = Math.min(effectHeight, targetY); // Clamp to mirror line
            const diff = bar.targetY - bar.currentY;

            if (diff < 0) {
                bar.currentY += diff * verticalPushSpeed;
            } else if (diff > 0.1) {
                bar.currentY += Math.min(diff, decayAmount);
            }

            // Ensure current bar position never exceeds the new visual height
            bar.currentY = Math.min(effectHeight, Math.max(0, bar.currentY)); 

            // FIX: Spawn new particles if the audio bar is pushed high enough
            const barHeightThreshold = effectHeight - (currentParticleSize * 5); // Must be significantly raised
            if (bar.currentY < barHeightThreshold) {
                if (Math.random() < spawnRateFactor) {
                    spawnParticle(i, barWidth, currentBarCount, currentColorMode, staticColorRgb, effectHeight);
                }
            }
        }

        // --- Process All Particles ---
        for (let i = activeParticles.length - 1; i >= 0; i--) {
            const p = activeParticles[i];

            p.update(deltaTime, barWidth, currentGravity, currentTurbulence, currentParticleSize, effectHeight, currentSparkleCount);

            // Render NEW particles to the OFF-SCREEN buffer
            p.render(offCtx, currentParticleSize, effectHeight);

            // Define the "kill zone" well below the mirror line
            const killY = canvasHeight + 20; 

            // Particle removal condition:
            let shouldRemove = false;
            if (p.y > killY || p.x < -20 || p.x > canvasWidth + 20) {
                shouldRemove = true; // Off-screen kill
            } else if (!p.isConstrained && p.bounceCount > 2) {
                // If it has bounced more than twice, check if it's "at rest" on the line (particle bottom at line)
                if ((p.y + currentParticleSize) >= effectHeight && Math.abs(p.vy) < 0.2) {
                    shouldRemove = true;
                }
            }

            if (shouldRemove) {
                activeParticles.splice(i, 1);
            }
        }

        // --- Process Sparkles ---
        
        if (currentSparkleCount > 0) {
            for (let i = activeSparkles.length - 1; i >= 0; i--) {
                const s = activeSparkles[i];
                s.update(deltaTime, currentGravity, effectHeight); 
                s.render(offCtx); // Render to the same off-screen buffer

                // Remove sparkles if faded or if they've bounced too many times and settled
                let shouldRemoveSparkle = false;
                if (s.life <= 0 || s.y > effectHeight + 5) { 
                    shouldRemoveSparkle = true;
                } else if (s.bounceCount > 2 && s.y + s.size >= effectHeight && Math.abs(s.vy) < 0.2) {
                    shouldRemoveSparkle = true;
                }

                if (shouldRemoveSparkle) {
                    activeSparkles.splice(i, 1);
                }
            }
        }

        // --- Final Composite to MAIN Canvas ---

        // 1. Clear MAIN canvas to PURE BLACK
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);

        // 2. Draw the main effect (top part) from the primary buffer
        ctx.drawImage(offscreenCanvas,
            0, 0, canvasWidth, effectHeight,  // Source
            0, 0, canvasWidth, effectHeight); // Destination

        // 3. Draw the reflection and smear (only if mirrorHeight > 0)
        if (mirrorHeight > 0) {

            // --- Create the basic (un-smeared) reflection first ---
            smearCtx.save(); // Use smearCtx as a temp buffer
            smearCtx.clearRect(0, 0, canvasWidth, canvasHeight); // Clear smear buffer

            // Create a clipping mask *within the smear buffer*
            smearCtx.beginPath();
            smearCtx.rect(0, effectHeight, canvasWidth, mirrorHeight);
            smearCtx.clip();

            // Translate and flip *within the smear buffer*
            smearCtx.translate(0, effectHeight * 2);
            smearCtx.scale(1, -1);
            
            smearCtx.globalAlpha = 1.0; 

            // Draw the effect from the primary buffer into the smear buffer
            smearCtx.drawImage(offscreenCanvas,
                0, 0, canvasWidth, effectHeight,      // Source
                0, 0, canvasWidth, effectHeight);      // Destination

            smearCtx.restore(); // Remove clip and transforms on smearCtx
            // Now smearCtx contains the properly clipped and flipped reflection

            // --- Apply Smear to the reflection ---
            ctx.save(); // Save main context state
            // Clip the main context to the mirror area
            ctx.beginPath();
            ctx.rect(0, effectHeight, canvasWidth, mirrorHeight);
            ctx.clip();

            // Only perform smear steps if amount is greater than zero
            if (currentSmearAmount > 0 && currentSmearSteps > 1) {
                // Set blend mode for smearing on the main context
                ctx.globalCompositeOperation = 'lighter';
                // Opacity for each smear step
                ctx.globalAlpha = 1.0 / (currentSmearSteps * 1.5); 

                for (let i = 1; i <= currentSmearSteps; i++) {
                    const offset = (i / currentSmearSteps) * currentSmearAmount;
                    // Draw smeared copies from smearCanvas to main canvas
                    ctx.drawImage(smearCanvas, offset, 0); // Smear right
                    ctx.drawImage(smearCanvas, -offset, 0); // Smear left
                }
            }
            
            // Draw the original reflection (center) from smearCanvas onto main canvas
            ctx.globalCompositeOperation = 'source-over'; 
            if (currentSmearAmount > 0) {
                ctx.globalAlpha = 1.0 / currentSmearSteps; 
            } else {
                ctx.globalAlpha = 0.8; 
            }
            ctx.drawImage(smearCanvas, 0, 0);


            ctx.restore(); // Remove clip mask from main context

            // 4. Draw the black fade gradient over the mirrored part
            // Only apply the gradient if smear is active
            if (currentSmearAmount > 0) {
                const gradient = ctx.createLinearGradient(0, effectHeight, 0, canvasHeight);
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0.0)'); // Transparent at the mirror line
                gradient.addColorStop(0.8, 'rgba(0, 0, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 1.0)'); // Opaque black at the bottom

                ctx.globalCompositeOperation = 'source-over'; // Draw on top
                ctx.globalAlpha = 1.0; // Reset global alpha
                ctx.fillStyle = gradient;
                ctx.fillRect(0, effectHeight, canvasWidth, mirrorHeight);
            }
        }

        // 5. Save the final image to the offscreen buffer for the next frame's trail
        offCtx.globalCompositeOperation = 'source-over';
        offCtx.clearRect(0, 0, canvasWidth, canvasHeight);
        offCtx.drawImage(canvas, 0, 0);

        // --- End of new logic ---

        time++;
        requestAnimationFrame(update);
    }

    // Initialize with the (default) effectHeight
    const initialEffectHeight = canvasHeight * (1.0 - (window.mirrorLine || 20) / 100.0);
    initBarData(barCount || 8, initialEffectHeight);
    requestAnimationFrame(update);
</script>

</html>