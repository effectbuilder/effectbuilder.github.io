<!DOCTYPE html><html>
<head>
    <title>ORGB: Noise Map</title>
    <meta description="Floor is lava.">
    <meta publisher="JosÃ© Miranda (Port and improvements)">

    <meta property="speed" label="Global Speed" type="number" min="1" max="100" default="50">
    <meta property="motion" label="Motion" type="list" values="Up,Down,Left,Right" default="Up">
    <meta property="motion_speed" label="Motion Speed" type="number" min="0" max="100" default="10">
    <meta property="colors_mode" label="Color Mode" type="list" values="Rainbow,Inverse Rainbow,Custom Gradient" default="Rainbow">

    <meta property="frequency" label="Frequency" type="number" min="1" max="5000" default="1200">
    <meta property="amplitude" label="Amplitude" type="number" min="1" max="50000" default="39000">
    <meta property="lacunarity" label="Lacunarity" type="number" min="1" max="50000" default="7500">
    <meta property="persistence" label="Persistence" type="number" min="1" max="50000" default="5000">
    <meta property="octaves" label="Octaves" type="number" min="1" max="20" default="2">

    <meta property="color1" label="Color 1" type="color" default="#ff5500">
    <meta property="color2" label="Color 2" type="color" default="#ffc800">
    <meta property="color3" label="Color 3" type="color" default="#c80000">
    <meta property="color4" label="Color 4" type="color" default="#ff5500">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="noisemap-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('noisemap-canvas');
const ctx = canvas.getContext('2d');

// --- ADDED: Disable image smoothing ---
ctx.imageSmoothingEnabled = false;
ctx.mozImageSmoothingEnabled = false;
ctx.webkitImageSmoothingEnabled = false;

const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
// --- ADDED: ImageData buffer ---
const imageData = ctx.createImageData(canvasWidth, canvasHeight);
const pixels = imageData.data;


const gradientCanvas = document.createElement('canvas');
gradientCanvas.width = 256;
gradientCanvas.height = 1;
const gradientCtx = gradientCanvas.getContext('2d', { willReadFrequently: true });
let gradientData = null;

let progress = 0.0; // Used for time dimension in noise
// --- MODIFIED: Initialize with defaults ---
let lastColorSettings = (typeof color1 !== 'undefined' ? color1 : "#ff5500") +
                        (typeof color2 !== 'undefined' ? color2 : "#ffc800") +
                        (typeof color3 !== 'undefined' ? color3 : "#c80000") +
                        (typeof color4 !== 'undefined' ? color4 : "#ff5500");
let lastColorsMode = typeof colors_mode !== 'undefined' ? colors_mode : "Rainbow";
let initialized = false; // Flag for initial setup

// -------------------------------------------------------------------
// SIMPLEX NOISE ALGORITHM (provided implementation)
// -------------------------------------------------------------------
const SimplexNoise = (function() {
    const F3 = 1.0 / 3.0, G3 = 1.0 / 6.0;
    const grad3 = new Float32Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1]);
    const p = new Uint8Array(256);
    for (let i = 0; i < 256; i++) p[i] = i;
    for (let i = 255; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [p[i], p[j]] = [p[j], p[i]]; }
    const perm = new Uint8Array(512);
    const permMod12 = new Uint8Array(512);
    for (let i = 0; i < 512; i++) { perm[i] = p[i & 255]; permMod12[i] = perm[i] % 12; }

    return {
        noise3D: function(xin, yin, zin) {
            let n0, n1, n2, n3;
            const s = (xin + yin + zin) * F3;
            const i = Math.floor(xin + s), j = Math.floor(yin + s), k = Math.floor(zin + s);
            const t = (i + j + k) * G3;
            const X0 = i - t, Y0 = j - t, Z0 = k - t;
            const x0 = xin - X0, y0 = yin - Y0, z0 = zin - Z0;
            let i1, j1, k1, i2, j2, k2;
            if (x0 >= y0) {
                if (y0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
                else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; }
                else { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; }
            } else {
                if (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; }
                else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; }
                else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
            }
            const x1 = x0 - i1 + G3, y1 = y0 - j1 + G3, z1 = z0 - k1 + G3;
            const x2 = x0 - i2 + 2.0 * G3, y2 = y0 - j2 + 2.0 * G3, z2 = z0 - k2 + 2.0 * G3;
            const x3 = x0 - 1.0 + 3.0 * G3, y3 = y0 - 1.0 + 3.0 * G3, z3 = z0 - 1.0 + 3.0 * G3;
            const ii = i & 255, jj = j & 255, kk = k & 255;
            const gi0 = permMod12[ii + perm[jj + perm[kk]]];
            const gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]];
            const gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]];
            const gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]];
            let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
            if (t0 < 0) n0 = 0.0;
            else { t0 *= t0; n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0 + grad3[gi0 + 2] * z0); }
            let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
            if (t1 < 0) n1 = 0.0;
            else { t1 *= t1; n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1 + grad3[gi1 + 2] * z1); }
            let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
            if (t2 < 0) n2 = 0.0;
            else { t2 *= t2; n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2 + grad3[gi2 + 2] * z2); } // Corrected index from gi2+2 to gi2+1 for y
            let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
            if (t3 < 0) n3 = 0.0;
            else { t3 *= t3; n3 = t3 * t3 * (grad3[gi3] * x3 + grad3[gi3 + 1] * y3 + grad3[gi3 + 2] * z3); }
            return 32.0 * (n0 + n1 + n2 + n3);
        },
        fractal: function(octavesCount, x, y, z, freqVal, ampVal, lacVal, perVal) { // Pass params explicitly
            let val = 0;
            let freq = freqVal, amp = ampVal; // Use passed values
            const lac = lacVal, per = perVal;
            for(let i = 0; i < octavesCount; i++) {
                val += this.noise3D(x * freq, y * freq, z * freq) * amp;
                freq *= lac;
                amp *= per;
            }
            return val;
        }
    };
})();

// -------------------------------------------------------------------
// HELPER FUNCTIONS
// -------------------------------------------------------------------
// --- ADDED: HSL to RGB ---
function hslToRgb(h, s, l) { // h(0-360), s(0-100), l(0-100)
    h /= 360; s /= 100; l /= 100;
    let r, g, b;
    if (s === 0) { r = g = b = l; }
    else {
        const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1; if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3); g = hue2rgb(p, q, h); b = hue2rgb(p, q, h - 1 / 3);
    }
    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}


function generateGradient() {
    // --- ADDED: Fallbacks for colors ---
    const c1 = typeof color1 !== 'undefined' ? color1 : "#ff5500";
    const c2 = typeof color2 !== 'undefined' ? color2 : "#ffc800";
    const c3 = typeof color3 !== 'undefined' ? color3 : "#c80000";
    const c4 = typeof color4 !== 'undefined' ? color4 : "#ff5500"; // Repeat first

    let colors = [c1, c2, c3, c4].filter(c => c && c !== ''); // Filter empty
    if (colors.length < 2) colors = ["#ff0000", "#0000ff"]; // Ensure at least 2 colors

    const grad = gradientCtx.createLinearGradient(0, 0, gradientCanvas.width, 0);
    const step = 1.0 / (colors.length - 1);
    for (let i = 0; i < colors.length; i++) {
        grad.addColorStop(i * step, colors[i]);
    }
    gradientCtx.fillStyle = grad;
    gradientCtx.fillRect(0, 0, gradientCanvas.width, 1);
    try {
        gradientData = gradientCtx.getImageData(0, 0, gradientCanvas.width, 1).data;
    } catch(e) {
        console.error("Error getting gradient data:", e);
        gradientData = null;
    }
}

// -------------------------------------------------------------------
// EFFECT LOGIC
// -------------------------------------------------------------------

function getPixelColor(x, y) {
    // --- ADDED: Fallbacks for meta properties ---
    const currentMotion = typeof motion !== 'undefined' ? motion : "Up";
    const currentMotionSpeed = typeof motion_speed !== 'undefined' ? motion_speed : 10;
    const currentOctaves = typeof octaves !== 'undefined' ? Math.max(1, octaves) : 2; // Ensure >= 1
    const currentColorsMode = typeof colors_mode !== 'undefined' ? colors_mode : "Rainbow";
    // Noise parameter fallbacks
    const currentFrequency = typeof frequency !== 'undefined' ? frequency : 1200;
    const currentAmplitude = typeof amplitude !== 'undefined' ? amplitude : 39000;
    const currentLacunarity = typeof lacunarity !== 'undefined' ? lacunarity : 7500;
    const currentPersistence = typeof persistence !== 'undefined' ? persistence : 5000;


    let x_shift = 0, y_shift = 0;
    // Scale motion speed for visual effect
    const motion_val = (currentMotionSpeed / 10.0) * progress; // Divide by 10 for less extreme shift
    switch (currentMotion) {
        case "Up": y_shift = motion_val; break;
        case "Down": y_shift = -motion_val; break;
        case "Left": x_shift = motion_val; break;
        case "Right": x_shift = -motion_val; break;
    }

    // Scale x, y for noise input domain (adjust 50.0 to control zoom)
    const noiseX = (x / 50.0) + x_shift;
    const noiseY = (y / 50.0) + y_shift;
    const noiseZ = progress; // Use progress for the time dimension

    // Get the noise value (-1 to 1) using fallbacks for parameters
    const value = SimplexNoise.fractal(
        currentOctaves, noiseX, noiseY, noiseZ,
        currentFrequency / 10000.0, currentAmplitude / 10000.0, // Scale down params
        currentLacunarity / 10000.0, currentPersistence / 10000.0
    );

    // Normalize to 0-1 range
    const frac = Math.max(0, Math.min(1, (1 + value) * 0.5)); // Clamp frac

    let finalRgb = [0, 0, 0]; // Default black

    switch (currentColorsMode) {
        case "Rainbow":
            finalRgb = hslToRgb(360 * frac, 100, 50); // H(0-360), S(0-100), L(0-100)
            break;
        case "Inverse Rainbow":
            finalRgb = hslToRgb(360 - 360 * frac, 100, 50);
            break;
        case "Custom Gradient":
            if (gradientData) {
                const gradIndex = Math.min(gradientCanvas.width - 1, Math.floor(frac * gradientCanvas.width)) * 4;
                finalRgb = [gradientData[gradIndex], gradientData[gradIndex+1], gradientData[gradIndex+2]];
            }
            break;
    }
    return finalRgb; // Return RGB array
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
     // --- MODIFIED: Use performance.now() ---
    const now = performance.now();
    const deltaTime = lastTime === 0 ? 0.016 : (now - lastTime) / 1000; // Delta in seconds
    lastTime = now;

    if (isNaN(deltaTime) || deltaTime <= 0) {
        requestAnimationFrame(update);
        return;
    }

     // --- ADDED: Fallbacks for meta properties ---
    const currentColorsMode = typeof colors_mode !== 'undefined' ? colors_mode : "Rainbow";
    const currentSpeed = typeof speed !== 'undefined' ? speed : 50;
    const c1 = typeof color1 !== 'undefined' ? color1 : "#ff5500";
    const c2 = typeof color2 !== 'undefined' ? color2 : "#ffc800";
    const c3 = typeof color3 !== 'undefined' ? color3 : "#c80000";
    const c4 = typeof color4 !== 'undefined' ? color4 : "#ff5500";

     // --- ADDED: Initialize gradient on first run ---
     if (!initialized) {
        if (currentColorsMode === "Custom Gradient") {
             generateGradient(); // Uses fallbacks internally
             lastColorSettings = c1+c2+c3+c4; // Sync state
        }
        lastColorsMode = currentColorsMode; // Sync state
        initialized = true;
     }


    // Regenerate custom gradient if mode or colors change
    if (currentColorsMode === "Custom Gradient") {
        const currentSettings = c1 + c2 + c3 + c4;
        if(currentSettings !== lastColorSettings || currentColorsMode !== lastColorsMode) {
            generateGradient(); // Uses fallbacks internally
            lastColorSettings = currentSettings;
            lastColorsMode = currentColorsMode;
        }
    } else if (currentColorsMode !== lastColorsMode) {
        lastColorsMode = currentColorsMode; // Update mode tracker
    }


    // Update progress based on global speed
    progress += (currentSpeed / 50.0) * deltaTime; // Speed 50 = base rate

    // Render using ImageData
    for (let y = 0; y < canvasHeight; y++) {
        for (let x = 0; x < canvasWidth; x++) {
            const [r, g, b] = getPixelColor(x, y); // Uses fallbacks internally
            const index = (y * canvasWidth + x) * 4;
            pixels[index] = r;
            pixels[index + 1] = g;
            pixels[index + 2] = b;
            pixels[index + 3] = 255; // Alpha
        }
    }
    ctx.putImageData(imageData, 0, 0); // Draw buffer

    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);

</script>
</html>