<!DOCTYPE html><html>
<head>
    <title>ORGB: Bouncing Ball</title>
    <meta description="A ball bounces around your RGB setup.">
    <meta publisher="JosÃ© Miranda (Port and improvements)">

    <meta property="ball_radius" label="Ball Radius" type="number" min="1" max="100" default="15">
    <meta property="gravity" label="Gravity" type="number" min="1" max="100" default="10">
    <meta property="horizontal_velocity" label="Horizontal Velocity" type="number" min="0" max="100" default="10">
    <meta property="spectrum_velocity" label="Spectrum Velocity" type="number" min="0" max="100" default="10">
    <meta property="drop_height_percent" label="Drop Height %" type="number" min="0" max="100" default="90">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="bouncingball-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('bouncingball-canvas');
const ctx = canvas.getContext('2d');

ctx.imageSmoothingEnabled = false;
ctx.mozImageSmoothingEnabled = false;
ctx.webkitImageSmoothingEnabled = false;

const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

// --- Simulation State ---
let ball = {
    x: 0, y: 0,     // Position
    dx: 0, dy: 0,   // Velocity
    ddx: 0, ddy: 0, // Acceleration
    hue: 0,         // Color hue (0-360)
    impactVelocity: 0 // Pre-calculated bounce velocity
};

// -------------------------------------------------------------------
// HELPER & PHYSICS FUNCTIONS
// -------------------------------------------------------------------

/** Converts gravity slider value (1-100) to an acceleration value */
function getGravity(value) {
    return value <= 10 ? value : (10 + Math.pow(1.07, value));
}

/** Calculates the initial velocity a ball has when dropped from a height */
function getImpactVelocity(gravity, dropHeight) {
    return Math.sqrt(2 * gravity * dropHeight);
}

/** Resets the ball's position and velocity */
function initSimulation() {
    const currentGravity = typeof gravity !== 'undefined' ? gravity : 10;
    const currentHorizontalVelocity = typeof horizontal_velocity !== 'undefined' ? horizontal_velocity : 10;
    const currentDropHeightPercent = typeof drop_height_percent !== 'undefined' ? drop_height_percent : 90;

    const w = canvasWidth - 1;
    const h = canvasHeight - 1;

    ball.ddy = getGravity(currentGravity) * 20;
    ball.ddx = 0;

    // Preserve direction if dx is already non-zero, otherwise randomize
    const direction = (ball.dx !== 0) ? Math.sign(ball.dx) : (Math.random() > 0.5 ? 1 : -1);
    ball.dx = currentHorizontalVelocity * direction;

    const dropHeight = (currentDropHeightPercent / 100.0) * h;
    ball.impactVelocity = getImpactVelocity(ball.ddy, dropHeight);

    ball.y = h - dropHeight;
    ball.dy = 0;
    ball.x = Math.random() * w; // Random start X position if resetting

    // Ensure dx has a direction if velocity > 0
    if (ball.dx === 0 && currentHorizontalVelocity > 0) {
       ball.dx = currentHorizontalVelocity * (Math.random() > 0.5 ? 1 : -1);
    }
}

// --- ADDED: Explicit HSL to RGB conversion function ---
function hslToRgb(h, s, l) {
    h /= 360; s /= 100; l /= 100;
    let r, g, b;
    if (s === 0) {
        r = g = b = l; // achromatic
    } else {
        const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }
    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}


// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
let lastSettings = {}; // Used to detect when a setting changes
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    const currentGravity = typeof gravity !== 'undefined' ? gravity : 10;
    const currentHorizontalVelocity = typeof horizontal_velocity !== 'undefined' ? horizontal_velocity : 10;
    const currentDropHeightPercent = typeof drop_height_percent !== 'undefined' ? drop_height_percent : 90;
    const currentSpectrumVelocity = typeof spectrum_velocity !== 'undefined' ? spectrum_velocity : 10;
    const currentBallRadius = typeof ball_radius !== 'undefined' ? ball_radius : 15;

    // Check if any settings have changed to re-initialize the simulation
    const currentSettings = { currentGravity, currentHorizontalVelocity, currentDropHeightPercent };
    if (JSON.stringify(currentSettings) !== JSON.stringify(lastSettings)) {
        initSimulation();
        lastSettings = currentSettings;
    }

    // --- Update Physics ---
    const w = canvasWidth - 1;
    const h = canvasHeight - 1;
    const dt = deltaTime * 20; // Time multiplier

    ball.dx += ball.ddx * dt;
    ball.x += ball.dx * dt;
    
    if (ball.x < 0) { ball.x = 0; ball.dx *= -1; }
    else if (ball.x >= w) { ball.x = w; ball.dx *= -1; }
    
    ball.dy += ball.ddy * dt;
    ball.y += ball.dy * dt;
    
    if (ball.y >= h) { ball.y = h; ball.dy = -ball.impactVelocity; }

    ball.hue = (ball.hue + (currentSpectrumVelocity * deltaTime * 20)) % 360;

    // --- Render ---
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);

    const imageData = ctx.createImageData(canvasWidth, canvasHeight);
    const data = imageData.data;
    const radiusSq = currentBallRadius * currentBallRadius;

    const startX = Math.max(0, Math.floor(ball.x - currentBallRadius));
    const endX = Math.min(canvasWidth, Math.ceil(ball.x + currentBallRadius));
    const startY = Math.max(0, Math.floor(ball.y - currentBallRadius));
    const endY = Math.min(canvasHeight, Math.ceil(ball.y + currentBallRadius));
    
    for (let py = startY; py < endY; py++) {
        for (let px = startX; px < endX; px++) {
            const distSq = Math.pow(px - ball.x, 2) + Math.pow(py - ball.y, 2);
            
            if (distSq <= radiusSq) {
                const distance = Math.sqrt(distSq);
                // Brightness creates a gradient: brighter at the center (distance=0), fading towards black at the edge (distance=radius)
                // HSL Lightness goes from 0% (black) up to 50% (full color)
                const lightnessPercent = (1 - distance / currentBallRadius) * 50;

                // --- MODIFIED: Use explicit hslToRgb function ---
                const rgb = hslToRgb(ball.hue, 100, lightnessPercent); // Saturation 100%
                
                const index = (py * canvasWidth + px) * 4;
                data[index] = rgb[0];
                data[index + 1] = rgb[1];
                data[index + 2] = rgb[2];
                data[index + 3] = 255;
            }
        }
    }

    ctx.putImageData(imageData, 0, 0);

    requestAnimationFrame(update);
}

// Initial call
initSimulation(); // Call once at the start
requestAnimationFrame(update);

</script>
</html>