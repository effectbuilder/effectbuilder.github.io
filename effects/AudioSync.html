<!DOCTYPE html><html>
<head>
    <title>ORGB: Audio Sync</title>
    <meta description="Display frequency based colors with different modes.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="sensitivity" label="Sensitivity" type="number" min="1" max="500" default="100">
    <meta property="hue_shift" label="Hue Shift" type="number" min="0" max="360" default="0">
    <meta property="color_fade_speed" label="Color Fade Speed" type="number" min="1" max="99" default="50">
    <meta property="saturation" label="Saturation" type="list" values="Normal,Saturate High Amplitudes,Black & White" default="Normal">
    <meta property="roll_mode" label="Roll Mode" type="list" values="Linear Horizontal,No Roll,Radial,Wave,Linear Vertical" default="Linear Horizontal">
    
    <meta property="bypass_min" label="Band-pass Min Freq" type="number" min="0" max="199" default="0">
    <meta property="bypass_max" label="Band-pass Max Freq" type="number" min="0" max="200" default="200">

    <meta property="silent_color_enable" label="Enable Silent Color" type="boolean" default="false">
    <meta property="silent_color_value" label="Silent Color" type="color" default="#000000">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="audiosync-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('audiosync-canvas');
const ctx = canvas.getContext('2d');

// --- ADDED: Disable image smoothing ---
ctx.imageSmoothingEnabled = false;
ctx.mozImageSmoothingEnabled = false;
ctx.webkitImageSmoothingEnabled = false;

const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

// Effect state variables
let immediate_freq_hue = 0;
let current_freq_hue = 0;
let current_freq_sat = 255;
let current_freq_val = 0;
let colors_rotation = [];
let silent_color_timer = 0;
const SILENT_COLOR_TIMEOUT = 120; // frames

const rainbow_hues = [];
for (let i = 0; i < 200; i++) {
    rainbow_hues.push(360 - (i / 199.0) * 360);
}

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hsvToRgb(h, s, v) {
    let r, g, b;
    h /= 360; s /= 255; v /= 255;
    const i = Math.floor(h * 6);
    const f = h * 6 - i;
    const p = v * (1 - s);
    const q = v * (1 - f * s);
    const t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v, g = t, b = p; break; case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break; case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break; case 5: r = v, g = p, b = q; break;
    }
    return [r * 255, g * 255, b * 255];
}

function hexToRgb(hex) {
    if (!hex) return [0, 0, 0];
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return [r, g, b];
}

// -------------------------------------------------------------------
// EFFECT LOGIC
// -------------------------------------------------------------------

// --- MODIFIED: Added roll_mode_val parameter ---
function getColor(x, y, w, h, roll_mode_val) {
    let color = [0, 0, 0];
    // --- MODIFIED: Removed engine.getProperty ---
    const index = getRollIndex(x, y, w, h, roll_mode_val);
    if (index < colors_rotation.length) {
        color = colors_rotation[index];
    }
    return `rgb(${Math.round(color[0])}, ${Math.round(color[1])}, ${Math.round(color[2])})`;
}

function getRollIndex(x, y, w, h, roll_mode_val) {
    switch (roll_mode_val) {
        case "Linear Horizontal": return x;
        case "No Roll": return 0;
        case "Radial": {
            const centerX = w / 2;
            const centerY = h / 2;
            return Math.round(Math.sqrt(Math.pow(centerX - x, 2) + Math.pow(centerY - y, 2)));
        }
        case "Wave": {
            const centerX = w * 1.1;
            const centerY = h / 2;
            return Math.round(Math.sqrt(Math.pow(centerX - x, 2) + Math.pow(centerY - y, 2)));
        }
        case "Linear Vertical": return y;
    }
    return 0;
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    // --- REMOVED: Guard clause that broke browser execution ---
    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    // --- ADDED: Fallbacks for all meta properties ---
    const currentSensitivity = typeof sensitivity !== 'undefined' ? sensitivity : 100;
    const currentHueShift = typeof hue_shift !== 'undefined' ? hue_shift : 0;
    const currentColorFadeSpeed = typeof color_fade_speed !== 'undefined' ? color_fade_speed : 50;
    const currentSaturation = typeof saturation !== 'undefined' ? saturation : "Normal";
    const currentRollMode = typeof roll_mode !== 'undefined' ? roll_mode : "Linear Horizontal";
    const currentBypassMin = typeof bypass_min !== 'undefined' ? bypass_min : 0;
    const currentBypassMax = typeof bypass_max !== 'undefined' ? bypass_max : 200;
    const currentSilentEnable = typeof silent_color_enable !== 'undefined' ? silent_color_enable : false;
    const currentSilentValue = typeof silent_color_value !== 'undefined' ? silent_color_value : "#000000";

    // --- ADDED: Audio data fallback for browser ---
    const audioData = (typeof engine !== 'undefined' && engine.audio && engine.audio.freq)
                      ? new Int8Array(engine.audio.freq)
                      : new Int8Array(200).fill(30);

    const fps = deltaTime > 0 ? 1 / deltaTime : 60;
    
    let max_idx = -1;
    let max_value = 0;
    const min_freq = Math.max(0, currentBypassMin);
    const max_freq = Math.min(200, currentBypassMax);
    
    const sensitivity_mult = currentSensitivity / 100.0;

    for (let i = min_freq; i < max_freq; i++) {
        const amp = (Math.abs(audioData[i]) / 128.0) * sensitivity_mult;
        if (amp > max_value) {
            max_value = amp;
            max_idx = i;
        }
    }

    if (max_idx !== -1) {
        const shifted_idx = (max_idx + currentHueShift) % 200;
        immediate_freq_hue = rainbow_hues[shifted_idx];
        
        const fadeFactor = 1.0 - (currentColorFadeSpeed / 100.0);
        const diff = immediate_freq_hue - current_freq_hue;
        current_freq_hue += (diff / (fadeFactor * 10 + 1)) / (fps / 60);

        switch(currentSaturation) {
            case "Saturate High Amplitudes":
                current_freq_sat = 255 - 255 * Math.pow(max_value, 3);
                break;
            case "Black & White":
                current_freq_sat = 0;
                break;
            default:
                current_freq_sat = 255;
                break;
        }
        current_freq_val = max_value * 255;
    } else {
        current_freq_val -= 5.0;
    }
    
    current_freq_sat = Math.max(0, Math.min(255, current_freq_sat));
    current_freq_val = Math.max(0, Math.min(255, current_freq_val));

    let mainColor = hsvToRgb(current_freq_hue, current_freq_sat, current_freq_val);

    if (current_freq_val < 1 && currentSilentEnable) {
        silent_color_timer = Math.min(SILENT_COLOR_TIMEOUT, silent_color_timer + 1);
        const silentRgb = hexToRgb(currentSilentValue);
        const brightness = silent_color_timer / SILENT_COLOR_TIMEOUT;
        mainColor = [silentRgb[0] * brightness, silentRgb[1] * brightness, silentRgb[2] * brightness];
    } else {
        silent_color_timer = 0;
    }
    
    colors_rotation.unshift(mainColor);
    if (colors_rotation.length > 1024) {
        colors_rotation.pop();
    }
    
    for (let y = 0; y < canvasHeight; y++) {
        for (let x = 0; x < canvasWidth; x++) {
            // --- MODIFIED: Pass currentRollMode to getColor ---
            ctx.fillStyle = getColor(x, y, canvasWidth, canvasHeight, currentRollMode);
            ctx.fillRect(x, y, 1, 1);
        }
    }
    
    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);

</script>
</html>