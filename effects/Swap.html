<!DOCTYPE html><html>
<head>
    <title>ORGB: Swap</title>
    <meta description="Alternate two colors on your devices from left to right.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="speed" label="Speed" type="number" min="1" max="20" default="10">
    <meta property="random_colors" label="Random Colors" type="boolean" default="false">
    <meta property="color1" label="Color 1" type="color" min="0" max="360" default="#ff0000">
    <meta property="color2" label="Color 2" type="color" min="0" max="360" default="#0000ff">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="swap-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('swap-canvas');
const ctx = canvas.getContext('2d');

// --- ADDED: Disable image smoothing ---
ctx.imageSmoothingEnabled = false;
ctx.mozImageSmoothingEnabled = false;
ctx.webkitImageSmoothingEnabled = false;

const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
const imageData = ctx.createImageData(canvasWidth, canvasHeight);
const pixels = imageData.data;

// Effect state variables
let time = 0.0;
let color_a = [255, 0, 0];
let color_b = [0, 0, 255];
let last_direction = false;
// --- MODIFIED: Initialize with defaults ---
let last_random_colors = typeof random_colors !== 'undefined' ? random_colors : false;
let last_color1 = typeof color1 !== 'undefined' ? color1 : '#ff0000';
let last_color2 = typeof color2 !== 'undefined' ? color2 : '#0000ff';
let initialized = false; // Flag for initial setup

// Variables for smooth random color transition
let current_random_a = [0, 0, 0];
let current_random_b = [0, 0, 0];
let next_random_a = [0, 0, 0];
let next_random_b = [0, 0, 0];


// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex || hex.length < 7) return [0, 0, 0];
    try {
        return [parseInt(hex.slice(1, 3), 16), parseInt(hex.slice(3, 5), 16), parseInt(hex.slice(5, 7), 16)];
    } catch(e) { console.error("Invalid hex:", hex, e); return [0,0,0]; }
}

function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

function lerpColor(c1, c2, factor) {
    const f = Math.max(0, Math.min(1, factor));
    const r = c1[0] * (1 - f) + c2[0] * f;
    const g = c1[1] * (1 - f) + c2[1] * f;
    const b = c1[2] * (1 - f) + c2[2] * f;
    return [r, g, b];
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    // --- MODIFIED: Use performance.now() ---
    const now = performance.now();
    const deltaTime = lastTime === 0 ? 0.016 : (now - lastTime) / 1000; // Delta in seconds
    lastTime = now;

    if (isNaN(deltaTime) || deltaTime <= 0) {
        requestAnimationFrame(update);
        return;
    }

    // --- ADDED: Fallbacks for meta properties ---
    const currentSpeed = typeof speed !== 'undefined' ? speed : 10;
    const currentRandomColors = typeof random_colors !== 'undefined' ? random_colors : false;
    const c1 = typeof color1 !== 'undefined' ? color1 : '#ff0000';
    const c2 = typeof color2 !== 'undefined' ? color2 : '#0000ff';

    // --- ADDED: Initialize on first run ---
    if (!initialized) {
        if (currentRandomColors) {
            current_random_a = randomRgb(); next_random_a = randomRgb();
            current_random_b = randomRgb(); next_random_b = randomRgb();
        } else {
            color_a = hexToRgb(c1);
            color_b = hexToRgb(c2);
        }
        last_random_colors = currentRandomColors; // Sync initial state
        last_color1 = c1;                         // Sync initial state
        last_color2 = c2;                         // Sync initial state
        initialized = true;
    }

    // --- Update State ---
    const old_time = time;
    // Speed 1-20 -> Time increment adjust
    time += (currentSpeed / 10.0) * deltaTime; // Adjust speed scaling

    const progress = time % 1.0; // Fractional part (0 to 1)
    const direction = Math.floor(time) % 2 === 0; // true = forward (A->B), false = backward (B->A)

    // When the direction changes (cycle completes), prepare next random colors
    if (direction !== last_direction) {
        if (currentRandomColors) {
            current_random_a = next_random_a;
            current_random_b = next_random_b;
            next_random_a = randomRgb();
            next_random_b = randomRgb();
        }
        last_direction = direction;
    }

    // Update colors if controls change mid-cycle
    if (currentRandomColors !== last_random_colors) {
        if (currentRandomColors) {
             // Switching TO random: Start transition immediately
            current_random_a = last_random_colors ? current_random_a : hexToRgb(c1); // Use current color A
            current_random_b = last_random_colors ? current_random_b : hexToRgb(c2); // Use current color B
            next_random_a = randomRgb();
            next_random_b = randomRgb();
        } else {
            // Switching FROM random: Set user colors immediately
            color_a = hexToRgb(c1);
            color_b = hexToRgb(c2);
        }
        last_random_colors = currentRandomColors;
    } else if (!currentRandomColors) { // Only update user colors if random is off
        if (c1 !== last_color1) { color_a = hexToRgb(c1); last_color1 = c1; }
        if (c2 !== last_color2) { color_b = hexToRgb(c2); last_color2 = c2; }
    }


    // --- Render ---
    // Colors for the current frame, potentially lerping between random sets
    const frame_color_a = currentRandomColors ? lerpColor(current_random_a, next_random_a, progress) : color_a;
    const frame_color_b = currentRandomColors ? lerpColor(current_random_b, next_random_b, progress) : color_b;

    // Determine which color is the 'start' and 'end' based on direction
    const startColor = direction ? frame_color_a : frame_color_b;
    const endColor = direction ? frame_color_b : frame_color_a;

    const wipe_position = progress; // Wipe position always goes 0 to 1

    for (let x = 0; x < canvasWidth; x++) {
        let finalColor;
        const x_norm = x / (canvasWidth - 1); // Normalize x from 0 to 1

        // Smooth transition zone (adjust 0.02 for wider/narrower blend)
        const transitionWidth = 0.02;
        const distance = x_norm - wipe_position;

        if (Math.abs(distance) < transitionWidth) {
            // Inside transition zone: lerp between start and end colors
            // Map distance from -transitionWidth to +transitionWidth -> 0 to 1
            const factor = (distance + transitionWidth) / (2 * transitionWidth);
            finalColor = lerpColor(startColor, endColor, factor);
        } else if (x_norm < wipe_position) {
            finalColor = startColor; // Pixel is behind the wipe edge
        } else {
            finalColor = endColor; // Pixel is ahead of the wipe edge
        }

        // Apply color to the full vertical column
        for (let y = 0; y < canvasHeight; y++) {
            const pixelIndex = (y * canvasWidth + x) * 4;
            pixels[pixelIndex] = Math.round(finalColor[0]);
            pixels[pixelIndex + 1] = Math.round(finalColor[1]);
            pixels[pixelIndex + 2] = Math.round(finalColor[2]);
            pixels[pixelIndex + 3] = 255; // Alpha
        }
    }

    ctx.putImageData(imageData, 0, 0);

    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);
</script>
</html>