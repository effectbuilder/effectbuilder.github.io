<!DOCTYPE html>
<html>
<head>
    <title>Window Rain</title>
    <meta description="Realistic rain dripping down a window pane with refracting translucent drops, continuous streaks, color themes, and beat-reactive lightning." />
    <meta publisher="JosÃ© Miranda" />

    <meta property="theme" label="Color Theme" type="combobox" values="Custom,Blood Moon,Candy,Cyberpunk,Deep Space,Desert,Forest,Ghost,Glacier,Inferno,Matrix,Midnight,Neon City,Ocean,Outrun,Royal,Sunset,Synthwave,Thunderstorm,Toxic,Vaporwave" default="Neon City">
    
    <meta property="custom1" label="Custom Color 1" type="color" default="#FF007F">
    <meta property="custom2" label="Custom Color 2" type="color" default="#7000FF">
    <meta property="custom3" label="Custom Color 3" type="color" default="#00F0FF">
    <meta property="customBg" label="Custom Background" type="color" default="#0A0A2A">

    <meta property="water_color" label="Water Tint (Custom Mode)" type="color" default="#C8DCFF">

    <meta property="intensity" label="Rain Intensity" type="number" min="1" max="100" default="100">
    <meta property="wind" label="Wind Direction" type="number" min="-50" max="50" default="0">
    
    <meta property="drop_size" label="Drop Size" type="number" min="10" max="200" default="100">
    <meta property="drop_speed" label="Terminal Velocity" type="number" min="10" max="200" default="20">
    <meta property="gravity_scale" label="Gravity Acceleration" type="number" min="10" max="200" default="40">
    <meta property="meander_amount" label="Snaking/Meander" type="number" min="0" max="50" default="0">
    
    <meta property="streak_opacity" label="Streak Visibility" type="number" min="0" max="100" default="10">

    <meta property="audio_reactive" label="Audio Reactive" type="boolean" default="true">
    <meta property="bass_sensitivity" label="Bass Sensitivity (Lightning)" type="number" min="1" max="80" default="70">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #start-overlay { display: none; }
    </style>
</head>

<body>
    <div id="start-overlay"></div>
    <canvas id="canvas" width="320" height="200"></canvas>

    <script>
        // -------------------------------------------------------------------
        // BROWSER COMPATIBILITY LAYER & AUTO-VARIABLE CREATION
        // -------------------------------------------------------------------
        if (typeof window.engine === 'undefined') {
            const metaTags = document.querySelectorAll('meta[property]');
            metaTags.forEach(meta => {
                const propName = meta.getAttribute('property');
                const propType = meta.getAttribute('type');
                const defaultVal = meta.getAttribute('default');
                if (propName) {
                    let finalValue = defaultVal;
                    if (propType === 'number') finalValue = parseFloat(defaultVal);
                    else if (propType === 'boolean') finalValue = (defaultVal === 'true' || defaultVal === '1');
                    window[propName] = finalValue;
                }
            });

            window.engine = { audio: { freq: new Array(128).fill(0) } };

            function simulateAudio() {
                const time = Date.now() / 1000; 
                const dataArray = new Array(128).fill(0);
                const beat = (Math.sin(time * Math.PI * 4) + 1) / 2; 
                const bassVal = Math.pow(beat, 4) * 255; 
                dataArray[0] = bassVal; dataArray[1] = bassVal; dataArray[2] = bassVal;
                for (let i = 10; i < 40; i++) {
                    const wave = (Math.sin(time * 8 + i * 0.5) + 1) / 2;
                    dataArray[i] = wave * 150 + (Math.random() * 50); 
                }
                window.engine.audio.freq = dataArray;
                requestAnimationFrame(simulateAudio);
            }
            simulateAudio();
        } else {
            document.getElementById('start-overlay').style.display = 'none';
        }
    </script>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const width = 320;
        const height = 200;

        // Offscreen canvas for continuous streaks
        const sCanvas = document.createElement('canvas');
        sCanvas.width = width;
        sCanvas.height = height;
        const sCtx = sCanvas.getContext('2d', { alpha: true });

        // Offscreen canvas to capture background for refraction
        const bgCanvas = document.createElement('canvas');
        bgCanvas.width = width;
        bgCanvas.height = height;
        const bgCtx = bgCanvas.getContext('2d', { alpha: false });

        let drops = [];
        let bokehs = [];
        let lastTime = performance.now();
        let lightningFlash = 0;
        let lastBass = 0;

        // Palettes defined as: [Color1, Color2, Color3, Background, WaterTint]
        const palettes = {
            "Blood Moon": ["#880000", "#FF0000", "#FF5500", "#1A0000", "#FFCCCC"],
            "Candy": ["#FFB6C1", "#FF69B4", "#FF1493", "#2A0011", "#FFE0E5"],
            "Cyberpunk": ["#FCEE0A", "#FF003C", "#00FFFF", "#111111", "#00FFFF"],
            "Deep Space": ["#FFFFFF", "#A1C4FD", "#C2E9FB", "#000000", "#A1C4FD"],
            "Desert": ["#EDC9AF", "#D2B48C", "#8B4513", "#221100", "#F5DEB3"],
            "Forest": ["#11998E", "#38EF7D", "#004400", "#001100", "#D0F0C0"],
            "Ghost": ["#F8F8FF", "#E6E6FA", "#DCDCDC", "#0A0A0A", "#E6E6FA"],
            "Glacier": ["#FFFFFF", "#B2EBF2", "#00BCD4", "#001A22", "#E0F7FA"],
            "Inferno": ["#FF0000", "#FF7F00", "#FFFF00", "#1A0000", "#FFD700"],
            "Matrix": ["#00FF41", "#008F11", "#003B00", "#000000", "#CCFFCC"],
            "Midnight": ["#000022", "#003388", "#0066FF", "#000000", "#88AAFF"],
            "Neon City": ["#FF007F", "#7000FF", "#00F0FF", "#0A0A2A", "#C8DCFF"],
            "Ocean": ["#00A8C5", "#FFFF7E", "#00E1D9", "#001122", "#E0FFFF"],
            "Outrun": ["#F5D300", "#FF007F", "#00FFFF", "#0D001A", "#FF71CE"],
            "Royal": ["#F1C40F", "#8E44AD", "#9B59B6", "#1A001A", "#E6E6FA"],
            "Sunset": ["#FF4E50", "#F9D423", "#FF8E53", "#2A0800", "#FFDAB9"],
            "Synthwave": ["#FF073A", "#00FFFF", "#FF00FF", "#110022", "#00FFFF"],
            "Thunderstorm": ["#2A3B4C", "#4B6584", "#778CA3", "#0F141E", "#B0C4DE"],
            "Toxic": ["#00FF00", "#AAFF00", "#004400", "#051105", "#CCFF99"],
            "Vaporwave": ["#FF71CE", "#01CDFE", "#05FFA1", "#1A002A", "#BFFFFF"]
        };

        function hexToRgb(hex) {
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 200, g: 220, b: 255 };
        }

        class Bokeh {
            constructor(colors) {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.r = Math.random() * 60 + 20;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.color = colors[Math.floor(Math.random() * (colors.length - 2))]; 
                this.alpha = Math.random() * 0.5 + 0.1;
                this.pulseOffset = Math.random() * Math.PI * 2;
                this.pulseSpeed = Math.random() * 0.02 + 0.01;
            }

            update(dt) {
                this.x += this.vx * dt * 60;
                this.y += this.vy * dt * 60;
                if (this.x < -this.r) this.x = width + this.r;
                if (this.x > width + this.r) this.x = -this.r;
                if (this.y < -this.r) this.y = height + this.r;
                if (this.y > height + this.r) this.y = -this.r;
            }

            draw(ctx, time) {
                const currentAlpha = this.alpha + Math.sin(time * this.pulseSpeed + this.pulseOffset) * 0.1;
                ctx.globalAlpha = Math.max(0.05, Math.min(0.8, currentAlpha));
                const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.r);
                grad.addColorStop(0, this.color);
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Drop {
            constructor(x, y, r, active) {
                this.x = x; this.y = y; this.r = r; this.active = active;
                this.vy = 0; this.mass = r * r;
                this.lastTrailX = x; this.lastTrailY = y;
                this.snakingOffset = Math.random() * 100;
            }

            update(dt, settings, waterRGB) {
                if (!this.active) {
                    if (this.r > 3.5 * settings.sizeMulti) this.active = true;
                    return;
                }
                this.vy += 9.8 * settings.gravityMulti * (this.r / 3) * dt; 
                const terminal = Math.min(8 * settings.speedMulti, this.r * 1.5 * settings.speedMulti);
                if (this.vy > terminal) this.vy = terminal;
                this.y += this.vy * dt * 60;
                const meander = Math.sin((this.y + this.snakingOffset) * 0.05) * 0.6 * settings.meanderMulti;
                this.x += (settings.wind + meander) * dt * 60;

                // Fast squared distance check to avoid Math.hypot overhead
                const dx = this.x - this.lastTrailX;
                const dy = this.y - this.lastTrailY;
                const sqDist = dx * dx + dy * dy;

                if (this.vy > 0.5 * settings.speedMulti && sqDist > 1.0) {
                    if (settings.streakOpacity > 0.001) {
                        sCtx.globalCompositeOperation = 'source-over';
                        sCtx.lineCap = 'round';
                        sCtx.strokeStyle = `rgba(0, 0, 0, ${settings.streakOpacity})`;
                        sCtx.lineWidth = this.r * 0.8;
                        sCtx.beginPath();
                        sCtx.moveTo(this.lastTrailX, this.lastTrailY);
                        sCtx.lineTo(this.x, this.y);
                        sCtx.stroke();
                        
                        sCtx.strokeStyle = `rgba(${waterRGB.r}, ${waterRGB.g}, ${waterRGB.b}, ${settings.streakOpacity})`;
                        sCtx.lineWidth = this.r * 1.0;
                        sCtx.beginPath();
                        sCtx.moveTo(this.lastTrailX, this.lastTrailY);
                        sCtx.lineTo(this.x, this.y);
                        sCtx.stroke();
                    }
                    if (Math.random() > 0.85) {
                        drops.push(new Drop(this.x, this.y - this.r * 1.5, (Math.random() * 0.4 + 0.3) * settings.sizeMulti, false));
                    }
                    this.mass -= 0.01 * settings.sizeMulti;
                    this.r = Math.max(0.5, Math.sqrt(this.mass));
                    this.lastTrailX = this.x; this.lastTrailY = this.y;
                }
            }

            draw(ctx, waterRGB) {
                const stretchY = this.active ? 1 + (this.vy * 0.15) : 1;
                const stretchX = this.active ? Math.max(0.6, 1 - (this.vy * 0.05)) : 1;
                const rx = this.r * stretchX; 
                const ry = this.r * stretchY;

                ctx.save();
                ctx.beginPath();
                ctx.ellipse(this.x, this.y, rx, ry, 0, 0, Math.PI * 2);

                // Dark outer rim
                ctx.lineWidth = 1;
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.stroke();

                ctx.clip(); 

                // Refraction (Magnification effect)
                const zoom = 0.6;
                const sx = this.x - (rx * zoom);
                const sy = this.y - (ry * zoom);
                const sw = rx * 2 * zoom;
                const sh = ry * 2 * zoom;
                ctx.drawImage(bgCanvas, sx, sy, sw, sh, this.x - rx, this.y - ry, rx * 2, ry * 2);

                // Tint
                ctx.globalAlpha = 0.35;
                ctx.fillStyle = `rgba(${waterRGB.r}, ${waterRGB.g}, ${waterRGB.b}, 1.0)`;
                ctx.fill();

                // FAKED Inner Shadow (High performance replacement for shadowBlur)
                ctx.globalAlpha = 1.0;
                ctx.beginPath();
                ctx.ellipse(this.x - 1, this.y - 1, rx + 1, ry + 1, 0, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.lineWidth = Math.max(2, this.r * 0.3);
                ctx.stroke();

                ctx.restore();

                // Specular Highlight
                if (this.r > 1) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.lineWidth = Math.max(0.5, this.r * 0.25);
                    ctx.beginPath();
                    ctx.ellipse(this.x - rx * 0.1, this.y - ry * 0.1, rx * 0.6, ry * 0.6, 0, Math.PI, Math.PI * 1.5);
                    ctx.stroke();
                }
            }
        }

        function initBackground(themeColors) {
            bokehs = [];
            for (let i = 0; i < 15; i++) {
                bokehs.push(new Bokeh(themeColors));
            }
        }

        function getProp(name, fallback) {
            return typeof window[name] !== 'undefined' ? window[name] : fallback;
        }

        let currentThemeName = "";

        function animate(time) {
            const dt = Math.min((time - lastTime) / 1000, 0.05);
            lastTime = time;

            // Opacity slider ranges 0-100. We map it to 0.00 to 0.03 for ultra-fine steps.
            const rawOpacity = getProp('streak_opacity', 60);
            const mappedOpacity = (rawOpacity / 100) * 0.03;

            const settings = {
                themeName: getProp('theme', 'Neon City'),
                custom1: getProp('custom1', '#FF007F'),
                custom2: getProp('custom2', '#7000FF'),
                custom3: getProp('custom3', '#00F0FF'),
                customBg: getProp('customBg', '#0A0A2A'),
                customWater: getProp('water_color', '#C8DCFF'),
                intensity: getProp('intensity', 60) / 100,
                wind: getProp('wind', 5) / 50,
                sizeMulti: getProp('drop_size', 100) / 100,
                speedMulti: getProp('drop_speed', 100) / 100,
                gravityMulti: getProp('gravity_scale', 100) / 100,
                meanderMulti: getProp('meander_amount', 100) / 100,
                streakOpacity: mappedOpacity,
                audioReactive: getProp('audio_reactive', true),
                bassSens: getProp('bass_sensitivity', 70) / 100
            };

            let themeColors = palettes[settings.themeName];
            if (settings.themeName === "Custom") {
                themeColors = [settings.custom1, settings.custom2, settings.custom3, settings.customBg, settings.customWater];
            }
            
            const waterColor = themeColors[4]; 
            const waterRGB = hexToRgb(waterColor);

            if (settings.themeName !== currentThemeName) {
                currentThemeName = settings.themeName;
                initBackground(themeColors || palettes["Neon City"]);
            }

            let bassLevel = 0;
            if (settings.audioReactive && engine.audio && engine.audio.freq) {
                const freq = engine.audio.freq;
                bassLevel = (freq[0] + freq[1] + freq[2]) / (3 * 255);
                if (bassLevel - lastBass > (1.0 - settings.bassSens) * 0.5 + 0.05) {
                    lightningFlash = 1.0;
                    if (Math.random() > 0.5) {
                        for(let i=0; i<Math.floor(settings.intensity * 10); i++) {
                            drops.push(new Drop(Math.random() * width, -10, (Math.random() * 2 + 1.5) * settings.sizeMulti, true));
                        }
                    }
                }
                lastBass = bassLevel;
            }

            if (Math.random() < settings.intensity * 0.4) {
                drops.push(new Drop(Math.random() * width, Math.random() * height, (Math.random() * 1.2 + 0.5) * settings.sizeMulti, false));
            }
            if (Math.random() < settings.intensity * 0.08) {
                drops.push(new Drop(Math.random() * width, -15, (Math.random() * 1.5 + 1.5) * settings.sizeMulti, true));
            }

            sCtx.globalCompositeOperation = 'destination-out';
            sCtx.fillStyle = `rgba(255, 255, 255, ${dt * 0.3})`;
            sCtx.fillRect(0, 0, width, height);

            // Fast AABB Collision detection
            for (let i = drops.length - 1; i >= 0; i--) {
                const d1 = drops[i];
                d1.update(dt, settings, waterRGB);
                if (d1.active) {
                    for (let j = i - 1; j >= 0; j--) {
                        const d2 = drops[j];
                        const dx = d1.x - d2.x;
                        const dy = d1.y - d2.y;
                        const rSum = d1.r + d2.r;
                        
                        // AABB preliminary check before expensive distance math
                        if (Math.abs(dx) < rSum && Math.abs(dy) < rSum) {
                            if (dx * dx + dy * dy < rSum * rSum) {
                                d1.mass += d2.mass;
                                d1.r = Math.min(Math.sqrt(d1.mass), 6.0 * settings.sizeMulti); 
                                d1.x = d1.x * 0.7 + d2.x * 0.3;
                                d1.vy *= 0.5;
                                drops.splice(j, 1);
                                i--;
                            }
                        }
                    }
                }
                if (d1.y > height + 20 || d1.x < -20 || d1.x > width + 20 || d1.mass < 0.1) {
                    drops.splice(i, 1);
                }
            }

            // --- 1. DRAW BACKGROUND ---
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1.0;
            ctx.fillStyle = themeColors[3]; 
            ctx.fillRect(0, 0, width, height);

            ctx.globalCompositeOperation = 'screen';
            for (const b of bokehs) { b.update(dt); b.draw(ctx, time); }

            if (lightningFlash > 0) {
                ctx.globalAlpha = lightningFlash;
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, width, height);
                lightningFlash -= dt * 3.0; 
            }

            // --- 2. CAPTURE BACKGROUND FOR REFRACTION ---
            bgCtx.clearRect(0, 0, width, height);
            bgCtx.drawImage(canvas, 0, 0);

            // --- 3. DRAW STREAKS & DROPS ---
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1.0;
            ctx.drawImage(sCanvas, 0, 0);
            
            for (const d of drops) { 
                d.draw(ctx, waterRGB); 
            }
            
            requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);
    </script>
</body>
</html>