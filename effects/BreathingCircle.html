<!DOCTYPE html><html>
<head>
    <title>ORGB: Breathing Circle</title>
    <meta description="A breathing circle effect.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="speed" label="Speed" type="number" min="10" max="100" default="50">
    <meta property="thickness" label="Thickness" type="number" min="1" max="20" default="10">
    <meta property="random_colors" label="Random Colors" type="boolean" default="true">
    <meta property="user_color" label="Color" type="color" default="#00ff00">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="breathingcircle-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('breathingcircle-canvas');
const ctx = canvas.getContext('2d');

// --- ADDED: Disable image smoothing ---
ctx.imageSmoothingEnabled = false;
ctx.mozImageSmoothingEnabled = false;
ctx.webkitImageSmoothingEnabled = false;

const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

// Effect state variables
let time = 0.0;
let progress = 0.0;
let was_growing = true;
let activeColor = [0, 255, 0]; // Default to green
let initialized = false; // Flag for initial color setup

// -------------------------------------------------------------------
// HELPER FUNCTIONS
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex || hex.length < 7) return [0, 255, 0]; // Basic validation
    try {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return [r, g, b];
    } catch (e) {
        console.error("Invalid hex color:", hex, e);
        return [0, 255, 0]; // Fallback
    }
}

function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

// -------------------------------------------------------------------
// MAIN LOGIC (Note: getColor is not used with the optimized rendering)
// -------------------------------------------------------------------
/*
function getColor(x, y, w, h) {
    // --- ADDED: Fallback for thickness ---
    const currentThickness = typeof thickness !== 'undefined' ? thickness : 10;

    const distance = Math.sqrt(Math.pow(0.5 - x / w, 2) + Math.pow(0.5 - y / h, 2));
    const thickness_norm = currentThickness / (w + h) * 2; // Adjusted scaling

    if (distance > progress || distance < progress - thickness_norm) {
        return 'rgb(0,0,0)';
    }

    return `rgb(${Math.round(activeColor[0])}, ${Math.round(activeColor[1])}, ${Math.round(activeColor[2])})`;
}
*/
// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    // --- ADDED: Fallbacks for meta properties ---
    const currentSpeed = typeof speed !== 'undefined' ? speed : 50;
    const currentThickness = typeof thickness !== 'undefined' ? thickness : 10;
    const currentRandomColors = typeof random_colors !== 'undefined' ? random_colors : true;
    const currentUserColor = typeof user_color !== 'undefined' ? user_color : "#00ff00";

    // --- ADDED: Initialize color on first run ---
    if (!initialized) {
        activeColor = currentRandomColors ? randomRgb() : hexToRgb(currentUserColor);
        initialized = true;
    }

    // --- Update State ---
    const prevProgress = progress;

    time += (currentSpeed / 100) * deltaTime * 5;
    progress = 0.35 * (1 + Math.sin(time));
    const is_growing = progress > prevProgress;

    // Check if a cycle has just completed (changed from shrinking to growing)
    if (is_growing && !was_growing) {
        if (currentRandomColors) {
            activeColor = randomRgb();
        } else {
            activeColor = hexToRgb(currentUserColor);
        }
    }
    was_growing = is_growing;

    // --- Render ---
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);

    // Optimized rendering using arc stroke
    const centerX = canvasWidth / 2;
    const centerY = canvasHeight / 2;
    // Scale radius relative to the smaller dimension to keep aspect ratio
    const max_radius = Math.min(canvasWidth, canvasHeight) / 2;
    const radius_pixels = progress * max_radius * 1.4; // Scale progress to max_radius range (0.7 maps roughly to 1)

    // Scale thickness relative to the smaller dimension
    const thickness_pixels = (currentThickness / 10) * (max_radius / 10); // Scale thickness

    // Prevent stroke width from becoming zero or negative
    const final_thickness = Math.max(1, thickness_pixels);

    ctx.strokeStyle = `rgb(${Math.round(activeColor[0])}, ${Math.round(activeColor[1])}, ${Math.round(activeColor[2])})`;
    ctx.lineWidth = final_thickness;

    ctx.beginPath();
    // Adjust radius calculation slightly - draw arc based on the *center* of the line width
    const drawRadius = Math.max(0, radius_pixels - final_thickness / 2);
    ctx.arc(centerX, centerY, drawRadius, 0, 2 * Math.PI);
    ctx.stroke();


    requestAnimationFrame(update);
}

// Initial call (color is now set on the first frame of update)
requestAnimationFrame(update);

</script>
</html>