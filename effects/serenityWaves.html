<!-- Original code: https://codepen.io/Yakudoo/pen/rJjOJx -->
<!DOCTYPE html>
<html>

<head>
    <title>Serenity Waves</title>
    <meta description="Procedural noise waves shader with custom palettes and adjustable ridges." />
    <meta publisher="Jose Miranda" />

    <meta property="palette" label="Color Palette" type="combobox" values="Blood Moon,Cotton Candy,Custom,Cyberpunk,Deep Sea,Forest,Golden Hour,Ice Kingdom,Lavender,Magma,Matrix,Midnight,Minty,Monochrome,Northern Lights,Rainbow,Royal,Slate,Solar Flare,Sunset,Toxic,Vaporwave" default="Magma">
    <meta property="customColor" label="Custom Color" type="color" default="#c2416c">

    <meta property="speed" label="Animation Speed" type="number" min="0" max="100" default="25">
    <meta property="hue_variation" label="Hue Variation" type="number" min="0" max="100" default="100">

    <meta property="density" label="Density" type="number" min="1" max="100" default="1">
    <meta property="displacement" label="Displacement" type="number" min="0" max="100" default="15">
    <meta property="ridge_width" label="Ridge Width" type="number" min="1" max="100" default="100">

    <meta property="audio_sensitive" label="Audio Reactive" type="boolean" default="False">
    <meta property="audio_strength" label="Audio Strength" type="number" min="0" max="100" default="100">

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            transition: background 1s ease;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="effect-canvas"></canvas>
</body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    if (typeof engine === 'undefined') {
        window.palette = "Magma";
        window.customColor = "#c2416c";
        window.speed = 25;
        window.hue_variation = 100;
        window.density = 1;
        window.displacement = 15;
        window.ridge_width = 100;
        window.audio_sensitive = false;
        window.audio_strength = 100;
    }

    // -------------------------------------------------------------------
    // SHADERS
    // -------------------------------------------------------------------

    const vertexShader = `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = vec4(position, 1.0);
    }
`;

    const fragmentShader = `
    uniform float uTime;
    uniform vec2 uMousePosition;
    
    // HSL Mode Uniforms
    uniform float uHue;
    uniform float uHueVariation;
    
    // Palette Mode Uniforms
    uniform sampler2D uGradientMap;
    uniform float uUsePalette;
    
    // General Uniforms
    uniform float uDensity;
    uniform float uDisplacement;
    
    // Audio / Flash / Ridge
    uniform float uAudioFlash; 
    uniform float uRidgeThreshold; 
    
    varying vec2 vUv;

    // --- Simplex Noise Utilities ---
    float mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
    vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
    vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}

    float hue2rgb(float f1, float f2, float hue) {
            if (hue < 0.0) hue += 1.0;
            else if (hue > 1.0) hue -= 1.0;
            float res;
            if ((6.0 * hue) < 1.0) res = f1 + (f2 - f1) * 6.0 * hue;
            else if ((2.0 * hue) < 1.0) res = f2;
            else if ((3.0 * hue) < 2.0) res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;
            else res = f1;
            return res;
    }

    vec3 hsl2rgb(vec3 hsl) {
            vec3 rgb;
            if (hsl.y == 0.0) {
                    rgb = vec3(hsl.z); 
            } else {
                    float f2;
                    if (hsl.z < 0.5) f2 = hsl.z * (1.0 + hsl.y);
                    else f2 = hsl.z + hsl.y - hsl.y * hsl.z;
                    float f1 = 2.0 * hsl.z - f2;
                    rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));
                    rgb.g = hue2rgb(f1, f2, hsl.x);
                    rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));
            }
            return rgb;
    }

    // --- Hue Rotation Utility ---
    vec3 hueRotate(vec3 col, float angle) {
        const vec3 k = vec3(0.57735, 0.57735, 0.57735);
        float cosAngle = cos(angle);
        return vec3(col * cosAngle + cross(k, col) * sin(angle) + k * dot(k, col) * (1.0 - cosAngle));
    }

    float fade(float t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }
    vec2 fade(vec2 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }

    float cnoise(vec2 P){
            vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);
            vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);
            Pi = mod(Pi, 289.0); 
            vec4 ix = Pi.xzxz;
            vec4 iy = Pi.yyww;
            vec4 fx = Pf.xzxz;
            vec4 fy = Pf.yyww;
            vec4 i = perm(perm(ix) + iy);
            vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; 
            vec4 gy = abs(gx) - 0.5;
            vec4 tx = floor(gx + 0.5);
            gx = gx - tx;
            vec2 g00 = vec2(gx.x,gy.x);
            vec2 g10 = vec2(gx.y,gy.y);
            vec2 g01 = vec2(gx.z,gy.z);
            vec2 g11 = vec2(gx.w,gy.w);
            vec4 norm = 1.79284291400159 - 0.85373472095314 *
            vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));
            g00 *= norm.x;
            g01 *= norm.y;
            g10 *= norm.z;
            g11 *= norm.w;
            float n00 = dot(g00, vec2(fx.x, fy.x));
            float n10 = dot(g10, vec2(fx.y, fy.y));
            float n01 = dot(g01, vec2(fx.z, fy.z));
            float n11 = dot(g11, vec2(fx.w, fy.w));
            vec2 fade_xy = fade(Pf.xy);
            vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
            float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
            return 2.3 * n_xy;
    }

    void main () {
        float mouseDistance = length(vUv - uMousePosition);
        float t = uTime * .005;
        
        float elevation = vUv.y * uDensity * 10.0;
        
        float shadow = smoothstep(0.0, .3 + sin(t * 5.0 * 3.14) * .1 , mouseDistance);
        elevation += shadow * 5.0;
        
        float displacement = cnoise( vec2( t + vUv.y * 2.0, t + vUv.x * 3.0 )) * uDisplacement * 3.0;

        elevation += displacement * 4.0;
        elevation *= 2.0 + cnoise( vec2( t + vUv.y * 1.0, t + .5)) * 2.0;
        
        float ridge = fract(elevation);
        float light = .9 + ridge;
        light *= .9 + (1.0 - (displacement * displacement)) * .1;
        
        elevation = floor(elevation);
    
        vec3 col;
        float noiseFactor = cnoise(vec2(elevation * 0.1, t * 0.5));

        if (uUsePalette > 0.5) {
            // Palette Mode
            float mapCoord = clamp((elevation * 0.05) + 0.5 + (noiseFactor * 0.2), 0.0, 1.0);
            mapCoord += (shadow * 0.2);
            
            col = texture2D(uGradientMap, vec2(clamp(mapCoord, 0.01, 0.99), 0.5)).rgb;
            col *= max(0.5, light); 
            
            if (uHueVariation > 0.0) {
                col = hueRotate(col, noiseFactor * uHueVariation * 3.0); 
            }
        } else {
            // HSL Mode
            float hue = uHue + shadow * .1 + cnoise( vec2( elevation * .10, .1 + t)) * uHueVariation;
            float saturation = .6;
            float brightness = - (1.0 - shadow) * .1 + .5 - smoothstep( 0.0, .9, cnoise( vec2( elevation * .5, .4 + t * 5.0)) ) * .1;
            vec3 hslCol = vec3(hue, saturation, brightness);
            col = hsl2rgb(hslCol) * max(0.8, light);
        }
        
        // Audio White Flash
        float contourZone = smoothstep(uRidgeThreshold, 1.0, ridge);
        vec3 whiteFlash = vec3(1.0) * contourZone * uAudioFlash;
        col += whiteFlash;
        
        gl_FragColor = vec4(col, 1.);
    }
`;

    // -------------------------------------------------------------------
    // PALETTE DEFINITIONS
    // -------------------------------------------------------------------
    const Palettes = {
        "Blood Moon": { waves: ["#8a0303", "#b22222", "#800000"], bgTop: "#1a0000", bgBot: "#000000" },
        "Cotton Candy": { waves: ["#ffb7d5", "#ffc0cb", "#ff69b4"], bgTop: "#2e2028", bgBot: "#20282e" },
        "Cyberpunk": { waves: ["#fcee0a", "#ff0055", "#00ff00"], bgTop: "#0a0a2e", bgBot: "#000000" },
        "Deep Sea": { waves: ["#000080", "#0000cd", "#4169e1"], bgTop: "#001a33", bgBot: "#00050a" },
        "Forest": { waves: ["#006400", "#228b22", "#556b2f"], bgTop: "#001a00", bgBot: "#000000" },
        "Golden Hour": { waves: ["#ffcc00", "#ffd700", "#ffa500"], bgTop: "#2e2200", bgBot: "#1a0d00" },
        "Ice Kingdom": { waves: ["#ffffff", "#f0f8ff", "#e0ffff"], bgTop: "#e0f7fa", bgBot: "#006064" },
        "Lavender": { waves: ["#e6e6fa", "#d8bfd8", "#dda0dd"], bgTop: "#1e1a2e", bgBot: "#000000" },
        "Magma": { waves: ["#ff0000", "#ff4500", "#ff8c00"], bgTop: "#330000", bgBot: "#1a0500" },
        "Matrix": { waves: ["#000000", "#003300", "#001100"], bgTop: "#001a00", bgBot: "#000000" },
        "Midnight": { waves: ["#191970", "#000080", "#00008b"], bgTop: "#000000", bgBot: "#050515" },
        "Minty": { waves: ["#98ff98", "#00ff7f", "#3cb371"], bgTop: "#002e1f", bgBot: "#000000" },
        "Monochrome": { waves: ["#ffffff", "#cccccc", "#999999"], bgTop: "#222222", bgBot: "#000000" },
        "Northern Lights": { waves: ["#00ff80", "#00fa9a", "#90ee90"], bgTop: "#001a1a", bgBot: "#05001a" },
        "Rainbow": { waves: ["#ff0000", "#ffa500", "#ffff00", "#008000", "#0000ff", "#4b0082", "#ee82ee"], bgTop: "#202020", bgBot: "#000000" },
        "Royal": { waves: ["#ffd700", "#daa520", "#b8860b"], bgTop: "#1a002e", bgBot: "#000000" },
        "Slate": { waves: ["#708090", "#778899", "#2f4f4f"], bgTop: "#2f4f4f", bgBot: "#000000" },
        "Solar Flare": { waves: ["#ff4500", "#ff8c00", "#ffa500"], bgTop: "#2e0d00", bgBot: "#000000" },
        "Sunset": { waves: ["#ff4500", "#ff6347", "#ff7f50"], bgTop: "#2e001f", bgBot: "#1a0500" },
        "Toxic": { waves: ["#ccff00", "#adff2f", "#7fff00"], bgTop: "#1a2e00", bgBot: "#15002e" },
        "Vaporwave": { waves: ["#ff00ff", "#bd00ff", "#ff00aa"], bgTop: "#2b002b", bgBot: "#000000" }
    };

    // -------------------------------------------------------------------
    // TEXTURE GENERATOR
    // -------------------------------------------------------------------

    function generateGradientTexture(colors) {
        const size = 256;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = 1;
        const ctx = canvas.getContext('2d');

        const grad = ctx.createLinearGradient(0, 0, size, 0);

        for (let i = 0; i < colors.length; i++) {
            const stop = i / (colors.length - 1);
            grad.addColorStop(stop, colors[i]);
        }

        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, size, 1);

        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.ClampToEdgeWrapping;
        texture.wrapT = THREE.ClampToEdgeWrapping;
        texture.minFilter = THREE.LinearFilter;
        return texture;
    }

    // -------------------------------------------------------------------
    // THREE.JS SETUP
    // -------------------------------------------------------------------

    const canvas = document.getElementById('effect-canvas');
    let renderer, scene, camera, material, mesh;
    let time = 0;
    let lastTime = 0;

    let lastPaletteName = "";
    let currentGradientTexture = null;
    let currentAudioLevel = 0;

    function init() {
        if (typeof THREE === 'undefined') {
            setTimeout(init, 100);
            return;
        }

        try {
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: false, preserveDrawingBuffer: true });
            renderer.setSize(canvas.width, canvas.height);
        } catch (e) {
            console.error("Could not create WebGL Renderer:", e);
            return;
        }

        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // Default texture
        currentGradientTexture = generateGradientTexture(["#000000", "#ffffff"]);

        const uniforms = {
            uTime: { value: 0 },
            uMousePosition: { value: new THREE.Vector2(0.5, 0.5) },

            uHue: { value: 0.5 },
            uHueVariation: { value: 0.1 },

            uGradientMap: { value: currentGradientTexture },
            uUsePalette: { value: 0.0 },

            uDensity: { value: 1.0 },
            uDisplacement: { value: 0.1 },

            uAudioFlash: { value: 0.0 },
            uRidgeThreshold: { value: 0.8 }
        };

        material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: vertexShader,
            fragmentShader: fragmentShader
        });

        const geometry = new THREE.PlaneGeometry(2, 2);
        mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);
    }

    function update(currentTime) {
        requestAnimationFrame(update);

        if (!renderer) {
            if (!scene) init();
            return;
        }

        const dt = (currentTime - lastTime) / 1000;
        lastTime = currentTime;

        if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- AUDIO SENSITIVITY ---
        let rawBass = 0;

        if (typeof engine !== 'undefined' && engine.audio && engine.audio.freq) {
            if (typeof audio_sensitive !== 'undefined' && audio_sensitive) {
                let bassTotal = 0;
                const audioData = engine.audio.freq;
                for (let i = 0; i < 3; i++) {
                    bassTotal += audioData[i];
                }
                rawBass = bassTotal / (3 * 255.0);
            }
        } else {
            if (typeof audio_sensitive !== 'undefined' && audio_sensitive) {
                rawBass = (Math.sin(currentTime * 0.01) > 0.9) ? 0.8 : 0.0;
            }
        }

        const strength = (typeof audio_strength !== 'undefined' ? audio_strength : 50) / 100.0;
        const targetLevel = rawBass * strength * 4.0;
        currentAudioLevel += (targetLevel - currentAudioLevel) * 0.3;

        material.uniforms.uAudioFlash.value = currentAudioLevel;

        // --- TIME & MOVEMENT ---
        const speedVal = (typeof speed !== 'undefined' ? speed : 20);
        time += dt * speedVal;
        material.uniforms.uTime.value = time;

        // --- AUTO FOCUS ---
        const fSpeed = 0.5;
        const fx = 0.5 + 0.35 * Math.sin(time * 0.02 * fSpeed);
        const fy = 0.5 + 0.35 * Math.cos(time * 0.03 * fSpeed);
        material.uniforms.uMousePosition.value.set(fx, fy);

        // --- PROPERTIES ---
        const baseDensity = (typeof density !== 'undefined' ? density : 20) / 20.0;
        material.uniforms.uDensity.value = baseDensity;

        const baseDisp = (typeof displacement !== 'undefined' ? displacement : 20) / 100.0;
        material.uniforms.uDisplacement.value = baseDisp;

        const hueVar = (typeof hue_variation !== 'undefined' ? hue_variation : 15) / 100.0;
        material.uniforms.uHueVariation.value = hueVar;

        // --- RIDGE WIDTH ---
        const rWidth = (typeof ridge_width !== 'undefined' ? ridge_width : 30) / 100.0;
        material.uniforms.uRidgeThreshold.value = 1.0 - rWidth;

        // --- COLOR LOGIC ---
        const paletteName = typeof palette !== 'undefined' ? palette : "Rainbow";

        if (paletteName === "Custom") {
            // HSL Mode
            material.uniforms.uUsePalette.value = 0.0;

            const cHex = typeof customColor !== 'undefined' ? customColor : "#ff0055";
            const cObj = new THREE.Color(cHex);
            const hsl = {};
            cObj.getHSL(hsl);

            material.uniforms.uHue.value = hsl.h;
            document.body.style.background = "#000000";

        } else {
            // Palette Mode
            material.uniforms.uUsePalette.value = 1.0;

            if (paletteName !== lastPaletteName) {
                const p = Palettes[paletteName] || Palettes["Rainbow"];

                if (currentGradientTexture) currentGradientTexture.dispose();
                currentGradientTexture = generateGradientTexture(p.waves);
                material.uniforms.uGradientMap.value = currentGradientTexture;

                const bgStr = `linear-gradient(to bottom, ${p.bgTop}, ${p.bgBot})`;
                document.body.style.background = bgStr;

                lastPaletteName = paletteName;
            }
        }

        renderer.render(scene, camera);
    }

    requestAnimationFrame(update);

</script>

</html>