<!DOCTYPE html>
<html>
<head>
    <title>Audio Eclipse</title>
    <meta title="Audio Eclipse">
    <meta description="The audio spectrum forms a vibrant, rotating ring of light, with a bass-pulsing central void." />
    <meta publisher="JosÃ© Miranda" />

    <meta property="coloringMode" label="Coloring Mode" type="combobox" values="Palette,Amplitude Hue" default="Palette">
    <meta property="palette" label="Color Palette" type="combobox" values="Custom,Rainbow,America,Aurora,Beach,Breeze,Bumblebee,C9,Cloud,Fairy Light,Forest,Heat,Holiday,Lava,Ocean,Party,Pastel,Sakura,Sunset,Technicolor" default="Rainbow">
    <meta property="color1" label="Primary Color (Custom)" type="color" default="#ffffff">
    <meta property="color2" label="Secondary Color (Custom)" type="color" default="#ffc88a">

    <meta property="voidSize" label="Void Size (Sun Radius)" type="number" default="33" min="10" max="200">
    <meta property="ringThickness" label="Ring Thickness" type="number" default="19" min="5" max="100">
    <meta property="innerBeamLength" label="Inner Beam Length" type="number" default="55" min="0" max="100">
    <meta property="outerBeamLength" label="Outer Beam Length" type="number" default="81" min="1" max="100">
    <meta property="ringCorona" label="Corona Brightness" type="number" default="73" min="0" max="100">
    <meta property="masterBrightness" label="Master Brightness" type="number" default="200" min="20" max="200">
    <meta property="beamContrast" label="Beam Contrast" type="number" default="21" min="0" max="100">
    <meta property="spectrumSmoothing" label="Spectrum Smoothing" type="number" default="2" min="0" max="10">

    <meta property="symmetryCycles" label="Symmetry Cycles" type="number" default="0" min="0" max="4">
    <meta property="coronaDistortionMagnitude" label="Wavy Distortion Strength" type="number" default="0" min="0" max="300">
    <meta property="sunMotionMagnitude" label="Sun Motion Magnitude" type="number" default="100" min="0" max="100">
    <meta property="starSizeMagnitude" label="Star Size" type="number" default="82" min="0" max="200">
    <meta property="starRotationSpeed" label="Star Field Rotation" type="number" default="5" min="-10" max="10">

    <meta property="enableNormalization" label="Enable Normalization" type="boolean" default="true">
    <meta property="soundLevelMultiplier" label="Sound Level Multiplier" type="number" default="113" min="0" max="200">
    <meta property="trailAmount" label="Trail Amount" type="number" default="93" min="0" max="100">
    <meta property="cometRate" label="Comet Rate" type="number" default="100" min="0" max="100">
    <meta property="cometSpeed" label="Comet Speed" type="number" default="33" min="10" max="100">

    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }
    </style>
</head>

<body>
    <canvas id="effect-canvas" width="320" height="200"></canvas>

    <script>
    if (typeof window.engine === 'undefined') {
        const metaTags = document.querySelectorAll('meta[property]');
        metaTags.forEach(meta => {
            const propName = meta.getAttribute('property');
            const propType = meta.getAttribute('type');
            const defaultVal = meta.getAttribute('default');
            if (propName) {
                let finalValue = defaultVal;
                if (propType === 'number') finalValue = parseFloat(defaultVal);
                else if (propType === 'boolean') finalValue = (defaultVal === 'true' || defaultVal === '1');
                window[propName] = finalValue;
            }
        });

        window.engine = { audio: { freq: new Array(128).fill(0) } };

        function simulateAudio() {
            const time = Date.now() / 1000; 
            const dataArray = new Array(128).fill(0);
            const beat = (Math.sin(time * Math.PI * 4) + 1) / 2; 
            const bassVal = Math.pow(beat, 4) * 255; 
            dataArray[0] = bassVal; dataArray[1] = bassVal; dataArray[2] = bassVal;
            for (let i = 10; i < 40; i++) {
                const wave = (Math.sin(time * 8 + i * 0.5) + 1) / 2;
                dataArray[i] = wave * 150 + (Math.random() * 50); 
            }
            window.engine.audio.freq = dataArray;
            requestAnimationFrame(simulateAudio);
        }
        simulateAudio();
    }
    </script>

    <script>
        // -------------------------------------------------------------------
        // MAIN EFFECT SCRIPT
        // -------------------------------------------------------------------
        const canvas = document.getElementById('effect-canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        ctx.imageSmoothingEnabled = false;

        let width = 320;
        let height = 200;
        let centerX = 160;
        let centerY = 100;
        let time = 0;
        let lastFrameTime = 0;
        const PI = Math.PI;

        // Constants
        const MIN_AMP_FLOOR = 20;
        const NO_SOUND_THRESHOLD = 25;
        const GRAVITY_STRENGTH = 400000;
        const BEAT_THRESHOLD = 0.95;
        const ROTATION_ACCEL_RATE = 2.0;
        const ROTATION_DAMPING = 0.98;
        const MIN_VELOCITY_FOR_TAIL_DRAW = 20;

        // Rotation & State
        let totalRotation = 0;
        let MAX_AMP_HISTORY = 0;
        let currentRotationVelocity = 0;
        let targetRotationDirection = 1;

        // Stars & Comets
        let stars = [];
        const NUM_STARS = 300;
        const STAR_FIELD_SCALE = 1.5;
        let starTotalRotation = 0;
        let comets = [];
        const MAX_COMETS = 5;
        let cometLastSpawnTime = 0;
        let volumeNormalized = 0;

        let pixelData = null;
        let imageData = null;

        const wledPalettes = {
            "Rainbow": ["#FF0000", "#FF4000", "#FF8000", "#FFFF00", "#80FF00", "#00FF00", "#00FF80", "#00FFFF", "#0080FF", "#0000FF", "#8000FF", "#FF00FF", "#FF0000"],
            "Cloud": ["#FFFFFF", "#D0D0E0", "#A0A0C0", "#7070A0", "#404080", "#101060", "#000040"],
            "Lava": ["#FF0000", "#FF4500", "#FFD700", "#000000", "#FFD700", "#FF4500", "#FF0000"],
            "Ocean": ["#00008B", "#0000CD", "#00BFFF", "#FFFFFF", "#00BFFF", "#0000CD", "#00008B"],
            "Forest": ["#006400", "#228B22", "#008000", "#556B2F", "#6B8E23", "#808000", "#006400"],
            "Sunset": ["#FF4500", "#FFA500", "#FFD700", "#FFFF00", "#FFD700", "#FFA500", "#FF4500", "#FF69B4", "#8A2BE2", "#4B0082", "#8A2BE2", "#FF69B4", "#FF4500"],
            "Heat": ["#000000", "#FF0000", "#FFFF00", "#FFFFFF"],
            "Party": ["#FF0000", "#00FF00", "#0000FF", "#FFFF00", "#FF00FF", "#00FFFF"],
            "Beach": ["#FDB813", "#F6D55C", "#79AEC8", "#EDF5E1", "#33658A"],
            "Pastel": ["#FFDDC1", "#FFABAB", "#FFC3A0", "#FF869A", "#D4A5A5"],
            "America": ["#B22234", "#FFFFFF", "#3C3B6E"],
            "Holiday": ["#D92626", "#0E5D2E", "#F2B705", "#F2F2F2"],
            "Bumblebee": ["#000000", "#FEE12B", "#FEE12B", "#000000"],
            "Fairy Light": ["#FF0000", "#00FF00", "#0000FF", "#FFFF00"],
            "Technicolor": ["#FF0000", "#00FF00", "#0000FF", "#FFFFFF", "#000000"],
            "Sakura": ["#FFC0CB", "#FFB6C1", "#DB7093", "#FFFFFF", "#FF1493"],
            "Breeze": ["#87CEEB", "#ADD8E6", "#B0E0E6", "#FFFFFF"],
            "C9": ["#FF0000", "#00FF00", "#0000FF", "#FFA500", "#FFFFFF"],
            "Aurora": ["#00FF00", "#00FFFF", "#8A2BE2", "#00008B"]
        };

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        function hsvToRgb(h, s, v) {
            let r, g, b, i = Math.floor(h * 6), f = h * 6 - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v, g = t, b = p; break; case 1: r = q, g = v, b = p; break;
                case 2: r = p, g = v, b = t; break; case 3: r = p, g = q, b = v; break;
                case 4: r = t, g = p, b = v; break; case 5: r = v, g = p, b = q; break;
            }
            return { r: r * 255, g: g * 255, b: b * 255 };
        }

        function lerpColor(c1, c2, t) {
            return { r: c1.r + (c2.r - c1.r) * t, g: c1.g + (c2.g - c1.g) * t, b: c1.b + (c2.b - c1.b) * t };
        }

        function getColorFromPalette(palette, t) {
            t = Math.max(0, Math.min(1, t));
            const len = palette.length - 1;
            const idx = Math.floor(t * len);
            const localT = (t - (idx / len)) * len;
            return lerpColor(hexToRgb(palette[idx]), hexToRgb(palette[Math.min(idx + 1, len)]), localT);
        }

        function setupCanvas() {
            width = canvas.width;
            height = canvas.height;
            centerX = width / 2;
            centerY = height / 2;
            if (typeof starSizeMagnitude !== 'undefined' && starSizeMagnitude > 0) initializeStars();
        }

        function getSmoothedAmp(freqData, index, smoothing) {
            if (smoothing === 0) return freqData[index] / 255.0;
            let total = 0, count = 0;
            for (let i = -smoothing; i <= smoothing; i++) {
                const safeIndex = (index + i + 100) % 100;
                total += freqData[safeIndex];
                count++;
            }
            return (total / count) / 255.0;
        }

        function initializeStars() {
            stars = [];
            const scaledWidth = width * STAR_FIELD_SCALE;
            const scaledHeight = height * STAR_FIELD_SCALE;
            for (let i = 0; i < NUM_STARS; i++) {
                stars.push({
                    x: (centerX - scaledWidth/2) + Math.random() * scaledWidth,
                    y: (centerY - scaledHeight/2) + Math.random() * scaledHeight,
                    sizeSeed: Math.random(),
                    baseOpacity: Math.random() * 0.5 + 0.5,
                    twinkleSeed: Math.random() * 2 * PI
                });
            }
        }

        function drawStars(cx, cy) {
            const mag = typeof starSizeMagnitude !== 'undefined' ? starSizeMagnitude : 82;
            const vSize = typeof voidSize !== 'undefined' ? voidSize : 33;
            if (mag <= 0) return;

            const scale = (mag / 100.0) * 1.5;
            const voidSq = vSize * vSize;
            const rot = starTotalRotation;

            ctx.globalCompositeOperation = 'lighter';
            ctx.fillStyle = 'white';

            stars.forEach(s => {
                const dx = s.x - cx;
                const dy = s.y - cy;
                if ((dx*dx + dy*dy) > voidSq) {
                    const rx = cx + dx * Math.cos(rot) - dy * Math.sin(rot);
                    const ry = cy + dx * Math.sin(rot) + dy * Math.cos(rot);
                    const op = s.baseOpacity * (0.6 + ((Math.sin(s.twinkleSeed + time * 0.05) + 1) / 2) * 0.4);
                    ctx.globalAlpha = op;
                    ctx.beginPath();
                    ctx.arc(rx, ry, (s.sizeSeed * scale * 0.5 + 0.1), 0, PI * 2);
                    ctx.fill();
                }
            });
            ctx.globalAlpha = 1.0;
            ctx.globalCompositeOperation = 'source-over';
        }

        function spawnComet() {
            if (comets.length >= MAX_COMETS) return;
            const edge = Math.floor(Math.random() * 4);
            let sx, sy, ang;
            if (edge === 0) { sx = -width*0.1; sy = Math.random()*height; ang = 0; }
            else if (edge === 1) { sx = width*1.1; sy = Math.random()*height; ang = PI; }
            else if (edge === 2) { sx = Math.random()*width; sy = -height*0.1; ang = PI*0.5; }
            else { sx = Math.random()*width; sy = height*1.1; ang = PI*1.5; }
            
            ang += (Math.random() - 0.5) * 0.5;
            const speedVar = (typeof cometSpeed !== 'undefined' ? cometSpeed : 33) / 100.0;
            const spd = speedVar * (Math.random() * 150 + 50) * 0.8 * (Math.random()*0.5 + 0.5);

            comets.push({
                x: sx, y: sy,
                vx: Math.cos(ang)*spd, vy: Math.sin(ang)*spd,
                lengthFactor: Math.random()*0.5 + 0.5,
                overSun: Math.random() > 0.5,
                size: Math.random()*2 + 1,
                color: 'white'
            });
        }

        function updateAndDrawComets(cx, cy, dt, drawLayer) {
            const rate = typeof cometRate !== 'undefined' ? cometRate : 100;
            if (rate === 0) return;

            for (let i = comets.length - 1; i >= 0; i--) {
                const c = comets[i];
                if (c.overSun !== drawLayer) continue;

                const dx = cx - c.x;
                const dy = cy - c.y;
                const distSq = dx*dx + dy*dy;
                const acc = GRAVITY_STRENGTH / (distSq + 10000);
                const invD = 1 / Math.sqrt(distSq);
                
                c.vx += (dx * invD * acc) * dt;
                c.vy += (dy * invD * acc) * dt;
                c.x += c.vx * dt;
                c.y += c.vy * dt;

                const vel = Math.sqrt(c.vx*c.vx + c.vy*c.vy);
                const tLen = vel * 0.008 * c.lengthFactor;

                ctx.globalCompositeOperation = 'lighter';
                if (tLen > 0.001 && vel > 20) {
                    const grad = ctx.createLinearGradient(c.x, c.y, c.x - c.vx*tLen*1.5, c.y - c.vy*tLen*1.5);
                    grad.addColorStop(0, 'rgba(255,255,255,0.8)');
                    grad.addColorStop(1, 'rgba(255,255,255,0)');
                    ctx.strokeStyle = grad;
                    ctx.lineWidth = c.size * 3.5 * 0.5;
                    ctx.beginPath();
                    ctx.moveTo(c.x, c.y);
                    ctx.lineTo(c.x - c.vx*tLen*2, c.y - c.vy*tLen*2);
                    ctx.stroke();
                }
                ctx.fillStyle = c.color;
                ctx.beginPath(); ctx.arc(c.x, c.y, c.size * 0.75, 0, PI*2); ctx.fill();

                if (c.x < -width || c.x > width*2 || c.y < -height || c.y > height*2) comets.splice(i, 1);
            }
            ctx.globalCompositeOperation = 'source-over';
        }

        function animate(now) {
            const dt = (now - lastFrameTime) / 1000 || 0;
            lastFrameTime = now;

            // --- AUDIO DATA SAFEGUARD ---
            let rawData;
            // Strict check: engine exists, audio exists, and rawlevel is actually an array
            if (typeof engine !== 'undefined' && engine.audio) {
                if (engine.audio.freq && Array.isArray(Array.from(engine.audio.freq))) {
                    rawData = new Uint8Array(engine.audio.freq);
                } else {
                     rawData = new Uint8Array(200).fill(20);
                }
            } else {
                rawData = new Uint8Array(200).fill(20);
            }
            
            // Normalize/Clamp to 200 bins
            const frequency = new Uint8Array(200);
            for(let i=0; i<200; i++) frequency[i] = rawData[i] || 0;

            // Audio Logic
            let maxVal = 0;
            for(let i=0; i<200; i++) if(frequency[i] > maxVal) maxVal = frequency[i];

            if (typeof enableNormalization !== 'undefined' && enableNormalization && maxVal > NO_SOUND_THRESHOLD) {
                let normMax = Math.max(MIN_AMP_FLOOR, maxVal);
                for(let i=0; i<200; i++) frequency[i] = (Math.max(frequency[i], MIN_AMP_FLOOR) / normMax) * 255;
            } else {
                for(let i=0; i<200; i++) frequency[i] = Math.max(frequency[i], MIN_AMP_FLOOR);
            }

            volumeNormalized = Math.min(1.0, maxVal / 255.0);
            if (volumeNormalized > BEAT_THRESHOLD && Math.random() < 0.5) targetRotationDirection *= -1;
            
            // Physics
            const rotVel = currentRotationVelocity + ((ROTATION_ACCEL_RATE * targetRotationDirection) - currentRotationVelocity) * dt;
            currentRotationVelocity = rotVel * ROTATION_DAMPING;
            totalRotation += currentRotationVelocity * dt;
            
            const starRotSpd = typeof starRotationSpeed !== 'undefined' ? starRotationSpeed : 5;
            starTotalRotation += (starRotSpd / 100.0) * dt;

            // Comets
            const cRate = typeof cometRate !== 'undefined' ? cometRate : 100;
            if (cRate > 0 && now > cometLastSpawnTime + (1000/cRate)) {
                spawnComet();
                cometLastSpawnTime = now;
            }

            // Draw Background
            ctx.fillStyle = 'black';
            ctx.globalAlpha = 1 - ((typeof trailAmount !== 'undefined' ? trailAmount : 93) / 100.0);
            ctx.fillRect(0, 0, width, height);
            ctx.globalAlpha = 1.0;

            // Draw Scene
            const sunMag = typeof sunMotionMagnitude !== 'undefined' ? sunMotionMagnitude : 100;
            const cx = centerX + (sunMag > 0 ? Math.sin(time*0.005)*15*(sunMag/100) : 0);
            const cy = centerY + (sunMag > 0 ? Math.sin(time*0.007)*20*(sunMag/100) : 0);

            drawStars(cx, cy);
            updateAndDrawComets(cx, cy, dt, false);

            if (!imageData || imageData.width !== width) {
                setupCanvas();
                imageData = ctx.getImageData(0, 0, width, height);
                pixelData = imageData.data;
            } else {
                imageData = ctx.getImageData(0, 0, width, height);
                pixelData = imageData.data;
            }

            // Spectrum Ring
            const smooth = parseInt(typeof spectrumSmoothing !== 'undefined' ? spectrumSmoothing : 2);
            const amps = new Float32Array(100);
            for(let i=0; i<100; i++) amps[i] = getSmoothedAmp(frequency, i, smooth);

            const lvlScale = (typeof soundLevelMultiplier !== 'undefined' ? soundLevelMultiplier : 113) / 100.0;
            const contrast = typeof beamContrast !== 'undefined' ? beamContrast : 21;
            const exp = 1.0 - (contrast / 101.0);
            const paletteName = typeof palette !== 'undefined' ? palette : "Rainbow";
            const cMode = typeof coloringMode !== 'undefined' ? coloringMode : "Palette";
            const col1 = hexToRgb(typeof color1 !== 'undefined' ? color1 : "#ffffff");
            const col2 = hexToRgb(typeof color2 !== 'undefined' ? color2 : "#ffc88a");

            const vSize = typeof voidSize !== 'undefined' ? voidSize : 33;
            const rThick = typeof ringThickness !== 'undefined' ? ringThickness : 19;
            const outerL = typeof outerBeamLength !== 'undefined' ? outerBeamLength : 81;
            const innerL = typeof innerBeamLength !== 'undefined' ? innerBeamLength : 55;
            const rCorona = typeof ringCorona !== 'undefined' ? ringCorona : 73;
            const mBright = (typeof masterBrightness !== 'undefined' ? masterBrightness : 200) / 100.0;

            const outerP = 1 + (101 - outerL) / 25.0;
            const innerP = 1 + (101 - innerL) / 25.0;
            const coronaInt = rCorona / 25.0;

            const distMag = (typeof coronaDistortionMagnitude !== 'undefined' ? coronaDistortionMagnitude : 0) * 0.008;
            const sym = typeof symmetryCycles !== 'undefined' ? symmetryCycles : 0;
            const symAngle = sym === 0 ? 2*PI : PI/sym;

            for (let i = 0; i < width * height; i++) {
                const px = i % width;
                const py = Math.floor(i / width);
                const dx = px - cx;
                const dy = py - cy;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                let ang = Math.atan2(dy, dx) - totalRotation;
                if (distMag > 0) ang += Math.sin(dist*0.003 + time*0.04) * distMag;

                const normAng = ((ang % symAngle + symAngle) % symAngle) / symAngle;
                const idx = Math.floor(normAng * 99);
                let val = Math.min(0.8, amps[idx] * lvlScale);
                val = Math.pow(val, exp);

                let bright = 0;
                let col;

                if (cMode === 'Amplitude Hue') col = hsvToRgb(val % 1.0, 1, 1);
                else col = paletteName === "Custom" ? lerpColor(col1, col2, normAng) : getColorFromPalette(wledPalettes[paletteName], normAng);

                if (dist >= vSize && dist <= vSize + rThick) {
                    const pos = (dist - vSize) / rThick;
                    const cFactor = Math.pow(1 - pos, 2.0);
                    bright = val * (1 + cFactor * coronaInt);
                    const blend = Math.min(1.0, cFactor * val * (rCorona/100.0) * 1.5);
                    col = lerpColor(col, {r:255,g:255,b:255}, blend);
                } else if (dist > vSize + rThick) {
                    bright = val * Math.pow((vSize+rThick)/dist, outerP - (val*(outerP-1)));
                } else if (innerL > 0 && dist < vSize) {
                    bright = val * Math.pow(dist/vSize, innerP);
                }

                if (bright > 0.001) {
                    const pIdx = i * 4;
                    pixelData[pIdx] = Math.min(255, pixelData[pIdx] + col.r * bright * mBright);
                    pixelData[pIdx+1] = Math.min(255, pixelData[pIdx+1] + col.g * bright * mBright);
                    pixelData[pIdx+2] = Math.min(255, pixelData[pIdx+2] + col.b * bright * mBright);
                }
            }

            ctx.putImageData(imageData, 0, 0);
            updateAndDrawComets(cx, cy, dt, true);
            time++;
            requestAnimationFrame(animate);
        }

        window.onload = () => {
            setupCanvas();
            requestAnimationFrame(animate);
        };
    </script>
</body>
</html>