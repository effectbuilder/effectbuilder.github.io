<!DOCTYPE html><html>
<head>
    <title>ORGB: Hypnotoad</title>
    <meta description="You wont escape this.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="animation_speed" label="Animation Speed" type="number" min="10" max="100" default="50">
    <meta property="color_rotation_speed" label="Rotation Speed" type="number" min="10" max="100" default="20">
    <meta property="spacing" label="Spacing" type="number" min="1" max="10" default="5">
    <meta property="thickness" label="Thickness" type="number" min="1" max="10" default="5">
    <meta property="center_x" label="X Position (%)" type="number" min="0" max="100" default="50">
    <meta property="center_y" label="Y Position (%)" type="number" min="0" max="100" default="50">
    <meta property="animation_direction" label="Animation Direction" type="list" values="To the Inside,To the Outside" default="To the Inside">
    <meta property="color_rotation_direction" label="Rotation Direction" type="list" values="Clockwise,Counter-clockwise" default="Clockwise">

    <meta property="color_mode" label="Color Mode" type="list" values="Rainbow,Custom" default="Rainbow">
    <meta property="color1" label="Color 1" type="color" min="0" max="360" default="#ff0000">
    <meta property="color2" label="Color 2" type="color" min="0" max="360" default="#00ff00">
    <meta property="color3" label="Color 3" type="color" min="0" max="360" default="#0000ff">
    <meta property="color4" label="Color 4" type="color" min="0" max="360" default="#ff0000">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="hypnotoad-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('hypnotoad-canvas');
const ctx = canvas.getContext('2d');

// --- ADDED: Disable image smoothing ---
ctx.imageSmoothingEnabled = false;
ctx.mozImageSmoothingEnabled = false;
ctx.webkitImageSmoothingEnabled = false;

const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
const imageData = ctx.createImageData(canvasWidth, canvasHeight);
const pixels = imageData.data;

const gradientCanvas = document.createElement('canvas');
gradientCanvas.width = 256;
gradientCanvas.height = 1;
const gradientCtx = gradientCanvas.getContext('2d', { willReadFrequently: true });
let gradientData = null;

let progress = 0.0;
// --- MODIFIED: Initialize with defaults ---
let lastColorSettings = (typeof color1 !== 'undefined' ? color1 : "#ff0000") +
                        (typeof color2 !== 'undefined' ? color2 : "#00ff00") +
                        (typeof color3 !== 'undefined' ? color3 : "#0000ff") +
                        (typeof color4 !== 'undefined' ? color4 : "#ff0000");
let lastColorMode = typeof color_mode !== 'undefined' ? color_mode : "Rainbow";

// -------------------------------------------------------------------
// HELPER FUNCTIONS
// -------------------------------------------------------------------

/** Converts HSL values to an RGB array. h(0-360), s(0-100), l(0-100) */
function hslToRgb(h, s, l) {
    h /= 360; s /= 100; l /= 100;
    let r, g, b;
    if (s === 0) {
        r = g = b = l; // achromatic
    } else {
        const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }
    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

function hexToRgb(hex) {
    if (!hex || hex.length < 7) return [0, 0, 0];
    try {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return [r, g, b];
    } catch(e) {
        console.error("Invalid hex color:", hex, e);
        return [0,0,0];
    }
}

function generateGradient() {
    // --- ADDED: Fallbacks for colors ---
    const c1 = typeof color1 !== 'undefined' ? color1 : "#ff0000";
    const c2 = typeof color2 !== 'undefined' ? color2 : "#00ff00";
    const c3 = typeof color3 !== 'undefined' ? color3 : "#0000ff";
    const c4 = typeof color4 !== 'undefined' ? color4 : "#ff0000"; // Repeat first color

    let colors = [c1, c2, c3, c4].filter(c => c && c !== ''); // Filter empty
    if (colors.length < 2) colors = ["#ff0000", "#0000ff"]; // Ensure at least 2 colors

    const grad = gradientCtx.createLinearGradient(0, 0, gradientCanvas.width, 0);
    const step = 1.0 / (colors.length - 1);
    for (let i = 0; i < colors.length; i++) {
        grad.addColorStop(i * step, colors[i]);
    }
    gradientCtx.fillStyle = grad;
    gradientCtx.fillRect(0, 0, gradientCanvas.width, 1);
    try {
        gradientData = gradientCtx.getImageData(0, 0, gradientCanvas.width, 1).data;
    } catch (e) {
        console.error("Error getting gradient data:", e);
        gradientData = null; // Prevent errors later if this fails
    }
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    // --- ADDED: Fallbacks for meta properties ---
    const currentAnimationSpeed = typeof animation_speed !== 'undefined' ? animation_speed : 50;
    const currentColorRotationSpeed = typeof color_rotation_speed !== 'undefined' ? color_rotation_speed : 20;
    const currentSpacing = typeof spacing !== 'undefined' ? spacing : 5;
    const currentThickness = typeof thickness !== 'undefined' ? thickness : 5;
    const currentCenterX = typeof center_x !== 'undefined' ? center_x : 50;
    const currentCenterY = typeof center_y !== 'undefined' ? center_y : 50;
    const currentAnimationDirection = typeof animation_direction !== 'undefined' ? animation_direction : "To the Inside";
    const currentColorRotationDirection = typeof color_rotation_direction !== 'undefined' ? color_rotation_direction : "Clockwise";
    const currentColorMode = typeof color_mode !== 'undefined' ? color_mode : "Rainbow";
    const c1 = typeof color1 !== 'undefined' ? color1 : "#ff0000";
    const c2 = typeof color2 !== 'undefined' ? color2 : "#00ff00";
    const c3 = typeof color3 !== 'undefined' ? color3 : "#0000ff";
    const c4 = typeof color4 !== 'undefined' ? color4 : "#ff0000";

    // Update animation progress
    progress += 0.1 * (currentAnimationSpeed / 10.0) * deltaTime * 60; // Scale speed

    // Regenerate custom gradient only when colors or mode change
    if(currentColorMode === "Custom") {
        const currentSettings = c1 + c2 + c3 + c4;
        if(currentSettings !== lastColorSettings || currentColorMode !== lastColorMode) {
            generateGradient(); // Uses fallbacks internally
            lastColorSettings = currentSettings;
            lastColorMode = currentColorMode;
        }
    } else if (currentColorMode !== lastColorMode) {
        lastColorMode = currentColorMode; // Update mode tracker even if not Custom
    }


    // Render
    const centerX = canvasWidth * (currentCenterX / 100.0);
    const centerY = canvasHeight * (currentCenterY / 100.0);

    const anim_dir = (currentAnimationDirection === "To the Inside") ? 1 : -1;
    const color_rot_dir = (currentColorRotationDirection === "Clockwise") ? -1 : 1;

    // --- MODIFIED: Simplified speed scaling ---
    const anim_mult = 0.1 * currentAnimationSpeed * anim_dir;
    const color_mult = 0.1 * currentColorRotationSpeed * color_rot_dir;

    const fade_mult = Math.max(1, (11 - currentThickness)); // Ensure fade_mult is at least 1

    for (let y = 0; y < canvasHeight; y++) {
        for (let x = 0; x < canvasWidth; x++) {
            const pixelIndex = (y * canvasWidth + x) * 4;

            const dx = x - centerX;
            const dy = y - centerY;
            const angle = Math.atan2(dy, dx) * 180 / Math.PI; // Degrees
            const distance = Math.sqrt(dx*dx + dy*dy);

            // Calculate base wave value (-1 to 1) based on distance and progress
            const value_wave = Math.cos(anim_mult * distance / Math.max(1, currentSpacing) + progress);
            // Calculate brightness (0 to 1) based on wave and thickness/fade
            const brightness = Math.pow(Math.max(0, (value_wave + 1) * 0.5), fade_mult); // Ensure base is non-negative for pow

            let finalRgb = [0, 0, 0]; // Default to black

            if (brightness > 0.001) { // Only calculate color if pixel is visible
                if (currentColorMode === "Rainbow") {
                    // --- MODIFIED: Adjusted color calculation ---
                    const hue = (angle * color_rot_dir + distance * 0.5 + progress * color_mult) % 360;
                    finalRgb = hslToRgb((hue + 360) % 360, 100, brightness * 50); // Ensure hue is positive
                } else { // Custom color mode
                    if (gradientData) { // Check if gradient is ready
                         // --- MODIFIED: Adjusted color calculation ---
                        const color_lookup_base = (angle * color_rot_dir + distance * 0.5 + progress * color_mult);
                        // Normalize lookup to 0-1 range for gradient
                        const color_lookup_norm = ((color_lookup_base % 360) + 360) % 360 / 360.0;

                        const gradIndex = Math.min(gradientCanvas.width - 1, Math.floor(color_lookup_norm * gradientCanvas.width)) * 4;

                        const r = gradientData[gradIndex] * brightness;
                        const g = gradientData[gradIndex + 1] * brightness;
                        const b = gradientData[gradIndex + 2] * brightness;
                        finalRgb = [Math.round(r), Math.round(g), Math.round(b)];
                    }
                }
            }

            pixels[pixelIndex] = finalRgb[0];
            pixels[pixelIndex + 1] = finalRgb[1];
            pixels[pixelIndex + 2] = finalRgb[2];
            pixels[pixelIndex + 3] = 255; // Alpha
        }
    }

    ctx.putImageData(imageData, 0, 0);

    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);

</script>
</html>