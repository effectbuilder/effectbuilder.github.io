<!DOCTYPE html>
<html>
<head>
    <title>ARC Raiders: Blueprint Protocol</title>
    <meta description="Inspired by the visual aesthetic of the game 'Arc Raiders', this effect features a dynamic blueprint grid with animated diagonal stripes that move and react to audio input." />
    <meta publisher="Jose Miranda" />

    <meta property="color_profile" label="Color Profile" type="combobox" values="Custom,ARC Standard,Cotton Candy,Cyberpunk City,Deep Ocean,Glacial Ice,Golden Age,High Voltage,Matrix Code,Neon Tokyo,Night Vision,Red Alert,Royal Guard,Rust and Dust,Solar Flare,Stealth Grey,Synthwave,Thermal Heatmap,Toxic Hazard,Ultraviolet,Vampire Hunter" default="ARC Standard" tooltip="Select a preset theme or choose 'Custom' to use the pickers below.">

    <meta property="stripe_width" label="Stripe Thickness" type="number" min="1" max="50" default="11" tooltip="Sets the width of each individual stripe line.">
    <meta property="stripe_gap" label="Stripe Gap" type="number" min="0" max="20" default="5" tooltip="Sets the spacing between the stripes.">
    <meta property="slope_angle" label="Diagonal Angle" type="number" min="0" max="90" default="24" tooltip="Controls the angle of the main diagonal lines.">
    <meta property="curve_radius" label="Curve Smoothness" type="number" min="10" max="200" default="200" tooltip="Adjusts how round the curve transition is on the front stripe.">
    <meta property="curve_y_start" label="Curve Vertical Point" type="number" min="0" max="200" default="140" tooltip="Sets the vertical position (Y-axis) where the front stripe begins to curve.">
    <meta property="end_angle" label="Curve End Angle (Relative)" type="number" min="-90" max="90" default="-45" tooltip="Controls the angle of the tail after the curve. Value is relative to the Diagonal Angle.">

    <meta property="anim_enter" label="Entrance Animation" type="combobox" values="Static,Draw Down,Draw Up,Scan" default="Draw Down" tooltip="Choose how the stripes appear on screen.">
    <meta property="anim_exit" label="Exit Animation" type="combobox" values="None,Draw Off,Fade,Dissolve" default="Draw Off" tooltip="Choose how the stripes disappear after being drawn.">
    <meta property="anim_speed" label="Cycle Speed" type="number" min="1" max="100" default="6" tooltip="Controls how fast the Entry/Exit animation loop plays.">
    
    <meta property="move_dir" label="Stripes Movement" type="combobox" values="None,Left,Right" default="Right" tooltip="Scrolls the entire stripe pattern continuously across the screen. You MUST select Left or Right for Movement Speed to work.">
    <meta property="move_speed" label="Movement Speed" type="number" min="0" max="100" default="10" tooltip="Sets the speed of the continuous scrolling movement. Set to 0 to use Manual Position.">
    <meta property="manual_pos" label="Manual Position (If Speed 0)" type="number" min="0" max="100" default="0" tooltip="Manually sets the scroll position of the stripes (0-100%). Only works when Movement Speed is 0.">
    
    <meta property="audio_strength" label="Trigger Sensitivity" type="number" min="0" max="100" default="60" tooltip="Controls how easily audio beats trigger the white flash effect. Set to 0 to disable audio reactivity.">

    <meta property="show_grid" label="Show Grid" type="boolean" default="true" tooltip="Toggles the visibility of the background blueprint grid.">
    <meta property="grid_speed" label="Grid Speed" type="number" min="0" max="100" default="5" tooltip="Controls how fast the background grid scrolls.">
    <meta property="grid_size" label="Grid Size" type="number" min="10" max="100" default="40" tooltip="Sets the size of the grid squares.">
    <meta property="grid_color" label="Manual Grid Color" type="color" default="#0055ff" tooltip="Sets the color of the grid lines (Only used if Color Profile is Custom).">
    <meta property="bg_color" label="Background Color" type="color" default="#000000" tooltip="Sets the solid background color behind the effect.">

    <meta property="stripe_color_1" label="Custom Stripe 1 (Front)" type="color" default="#5fe5ff" tooltip="Only used if Color Profile is set to 'Custom'.">
    <meta property="stripe_color_2" label="Custom Stripe 2" type="color" default="#37f173" tooltip="Only used if Color Profile is set to 'Custom'.">
    <meta property="stripe_color_3" label="Custom Stripe 3" type="color" default="#ffb713" tooltip="Only used if Color Profile is set to 'Custom'.">
    <meta property="stripe_color_4" label="Custom Stripe 4 (Back)" type="color" default="#f6001f" tooltip="Only used if Color Profile is set to 'Custom'.">

    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; width: 100vw; height: 100vh; image-rendering: pixelated; }
    </style>
</head>
<body>
    <canvas id="effect-canvas" width="320" height="200"></canvas>

<script>
    if (typeof window.engine === 'undefined') {
        const metaTags = document.querySelectorAll('meta[property]');
        metaTags.forEach(meta => {
            const propName = meta.getAttribute('property');
            const propType = meta.getAttribute('type');
            const defaultVal = meta.getAttribute('default');
            if (propName) {
                let finalValue = defaultVal;
                if (propType === 'number') finalValue = parseFloat(defaultVal);
                else if (propType === 'boolean') finalValue = (defaultVal === 'true' || defaultVal === '1');
                window[propName] = finalValue;
            }
        });
        window.engine = { audio: { freq: new Array(128).fill(0) } };
        function simulateAudio() {
            const time = Date.now() / 1000; 
            const dataArray = new Array(128).fill(0);
            const beat = (Math.sin(time * Math.PI * 4) + 1) / 2; 
            const bassVal = Math.pow(beat, 4) * 255; 
            dataArray[0] = bassVal; dataArray[1] = bassVal; dataArray[2] = bassVal;
            window.engine.audio.freq = dataArray;
            requestAnimationFrame(simulateAudio);
        }
        simulateAudio();
    }
</script>

<script>
    const canvas = document.getElementById('effect-canvas');
    const ctx = canvas.getContext('2d');
    let time = 0;
    let activeFlashIndex = -1;
    let flashTimer = 0;
    let maxBass = 0.5; 
    let animPhase = 0;
    let movementX = 0;

    const PROFILES = {
        "Custom": null,
        "ARC Standard": ["#5fe5ff", "#37f173", "#ffb713", "#f6001f"],
        "Cotton Candy": ["#ffb7b2", "#ffdac1", "#e2f0cb", "#b5ead7"],
        "Cyberpunk City": ["#00ffff", "#ff00ff", "#8a2be2", "#0000ff"],
        "Deep Ocean": ["#00ffff", "#00bfff", "#1e90ff", "#00008b"],
        "Glacial Ice": ["#ffffff", "#e0ffff", "#afeeee", "#b0e0e6"],
        "Golden Age": ["#ffd700", "#ffb713", "#ffa500", "#daa520"],
        "High Voltage": ["#ffff00", "#0000ff", "#ffffff", "#ff0000"],
        "Matrix Code": ["#00ff00", "#003300", "#00cc00", "#001100"],
        "Neon Tokyo": ["#ff0099", "#ff6600", "#ccff00", "#00ffff"],
        "Night Vision": ["#00ff00", "#32cd32", "#008000", "#006400"],
        "Red Alert": ["#ff0000", "#ff4500", "#b22222", "#8b0000"],
        "Royal Guard": ["#ffd700", "#800080", "#4b0082", "#ffffff"],
        "Rust and Dust": ["#cd853f", "#8b4513", "#a0522d", "#d2691e"],
        "Solar Flare": ["#ffff00", "#ffcc00", "#ff8c00", "#ff4500"],
        "Stealth Grey": ["#ffffff", "#d3d3d3", "#a9a9a9", "#696969"],
        "Synthwave": ["#ff00ff", "#00ffff", "#ffff00", "#ff0099"],
        "Thermal Heatmap": ["#0000ff", "#00ffff", "#ffff00", "#ff0000"],
        "Toxic Hazard": ["#ccff00", "#99ff33", "#66ff66", "#33cc33"],
        "Ultraviolet": ["#e0b0ff", "#da70d6", "#9932cc", "#4b0082"],
        "Vampire Hunter": ["#ff0000", "#000000", "#444444", "#8b0000"]
    };

    function drawGrid(width, height, offset, gridSize, color) {
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let x = offset % gridSize; x < width; x += gridSize) {
            ctx.moveTo(x, 0); ctx.lineTo(x, height);
        }
        for (let y = offset % gridSize; y < height; y += gridSize) {
            ctx.moveTo(0, y); ctx.lineTo(width, y);
        }
        ctx.stroke();
    }

    function drawStripes(w, h, offsetX, colors) {
        const startX_base = 20; 
        const startY = -50;     
        const thickness = typeof stripe_width !== 'undefined' ? stripe_width : 11;
        const gap = typeof stripe_gap !== 'undefined' ? stripe_gap : 5;
        const angleDeg = typeof slope_angle !== 'undefined' ? slope_angle : 24;
        const radius = typeof curve_radius !== 'undefined' ? curve_radius : 200;
        const breakY = typeof curve_y_start !== 'undefined' ? curve_y_start : 140;
        const endAngleRelative = typeof end_angle !== 'undefined' ? end_angle : -18;
        const enterMode = typeof anim_enter !== 'undefined' ? anim_enter : "Draw Down";
        const exitMode = typeof anim_exit !== 'undefined' ? anim_exit : "Draw Off";
        
        const angleRad = angleDeg * (Math.PI / 180);
        const slope = Math.tan(angleRad);
        const totalStride = (thickness + gap) / Math.cos(angleRad); 
        const startX = startX_base + offsetX;
        const approxLen = h * 2.0; // Slightly longer for safe coverage

        let currentStage = "Enter", stageProgress = 0.0;    
        if (enterMode === "Scan") { currentStage = "Scan"; stageProgress = animPhase; }
        else if (exitMode === "None") { currentStage = "Enter"; stageProgress = animPhase; }
        else {
            if (animPhase < 0.45) { currentStage = "Enter"; stageProgress = animPhase / 0.45; }
            else if (animPhase < 0.55) { currentStage = "Hold"; stageProgress = (animPhase - 0.45) / 0.10; }
            else { currentStage = "Exit"; stageProgress = (animPhase - 0.55) / 0.45; }
        }

        ctx.lineCap = 'round'; 
        ctx.lineJoin = 'round'; 

        for (let i = 3; i >= 0; i--) {
            let drawColor = colors[i];
            if (i === activeFlashIndex && flashTimer > 0) drawColor = "#FFFFFF";
            ctx.globalAlpha = 1.0;
            ctx.setLineDash([]);
            ctx.lineDashOffset = 0;

            if (currentStage === "Enter") {
                if (enterMode === "Static") ctx.setLineDash([]);
                else {
                    let k = (enterMode === "Draw Down") ? (3 - i) : i; 
                    let lineP = Math.max(0, Math.min(1, (stageProgress - k * 0.25) / 0.25));
                    if (enterMode === "Draw Down") {
                        ctx.setLineDash([lineP * approxLen, approxLen]);
                    } else if (enterMode === "Draw Up") {
                        ctx.setLineDash([approxLen, approxLen]);
                        ctx.lineDashOffset = (1.0 - lineP) * approxLen;
                    }
                }
            } else if (currentStage === "Exit") {
                let k = (enterMode === "Draw Down") ? (3 - i) : i;
                let lineP = Math.max(0, Math.min(1, (stageProgress - k * 0.25) / 0.25));
                if (exitMode === "Draw Off") {
                    if (enterMode === "Draw Down") {
                         ctx.setLineDash([approxLen * (1-lineP), approxLen]);
                    } else {
                         ctx.setLineDash([approxLen, approxLen]);
                         ctx.lineDashOffset = (lineP) * approxLen;
                    }
                } else if (exitMode === "Fade") {
                    ctx.globalAlpha = 1.0 - lineP;
                } else if (exitMode === "Dissolve") {
                    if (lineP >= 1) ctx.globalAlpha = 0;
                    else { ctx.setLineDash([20, lineP * 100]); ctx.lineDashOffset = Math.random() * 50; }
                }
            } else if (currentStage === "Scan") {
                const scanLen = approxLen * 0.25; 
                ctx.setLineDash([scanLen, approxLen]); 
                ctx.lineDashOffset = - (stageProgress * (approxLen + scanLen)) + scanLen;
            }

            const xOffset = startX + (i * totalStride);
            ctx.strokeStyle = drawColor;
            ctx.lineWidth = thickness;
            ctx.beginPath();
            ctx.moveTo(xOffset + (startY * slope), startY);

            if (i > 0) {
                ctx.lineTo(xOffset + ((h + 100) * slope), h + 100);
            } else {
                const endAngleRad = (angleDeg + endAngleRelative) * (Math.PI / 180);
                const endSlope = Math.tan(endAngleRad);
                const cornerX = xOffset + (breakY * slope);
                const cornerY = breakY;
                const targetY = h + 200;
                ctx.arcTo(cornerX, cornerY, cornerX + (targetY - cornerY) * endSlope, targetY, radius);
                ctx.lineTo(cornerX + (targetY - cornerY) * endSlope, targetY);
            }
            ctx.stroke();
        }
        ctx.setLineDash([]);
    }

    function animate() {
        const width = canvas.width, height = canvas.height;
        const profileName = typeof color_profile !== 'undefined' ? color_profile : "Custom";
        const manualGridColor = typeof grid_color !== 'undefined' ? grid_color : "#0055ff";
        let activeColors, activeGridColor;

        if (profileName !== "Custom" && PROFILES[profileName]) {
            activeColors = PROFILES[profileName];
            activeGridColor = activeColors[0];
        } else {
            activeColors = [stripe_color_1, stripe_color_2, stripe_color_3, stripe_color_4];
            activeGridColor = manualGridColor;
        }

        const bgColor = typeof bg_color !== 'undefined' ? bg_color : "#000000";
        const sens = typeof audio_strength !== 'undefined' ? audio_strength : 60;
        const aSpeed = typeof anim_speed !== 'undefined' ? anim_speed : 20;
        animPhase = (animPhase + aSpeed / 2000) % 1;

        const moveDir = typeof move_dir !== 'undefined' ? move_dir : "None";
        const mSpeed = typeof move_speed !== 'undefined' ? move_speed : 20;
        const loopWidth = 320; 

        if (mSpeed === 0) {
            movementX = (manual_pos / 100) * loopWidth;
        } else {
            if (moveDir === "Left") movementX -= (mSpeed * 0.1);
            else if (moveDir === "Right") movementX += (mSpeed * 0.1);
            movementX = (movementX % loopWidth + loopWidth) % loopWidth;
        }

        let bass = 0;
        if (sens > 0 && window.engine.audio.freq) {
            bass = (window.engine.audio.freq[0] + window.engine.audio.freq[1] + window.engine.audio.freq[2]) / (3 * 255.0);
        }
        maxBass = Math.max(0.1, maxBass * 0.99, bass);
        if (bass > maxBass * (0.95 * (1.0 - sens / 100)) && flashTimer <= 0 && bass > 0.05) {
            activeFlashIndex = Math.floor(Math.random() * 4);
            flashTimer = 4; 
        }
        if (flashTimer > 0) flashTimer--; else activeFlashIndex = -1;

        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, width, height);
        if (typeof show_grid === 'undefined' || show_grid) {
            drawGrid(width, height, (time * grid_speed) % grid_size, grid_size, activeGridColor);
        }
        
        [-loopWidth, 0, loopWidth].forEach(offset => drawStripes(width, height, movementX + offset, activeColors));
        
        time += 0.05;
        requestAnimationFrame(animate);
    }
    animate();
</script>
</body>
</html>