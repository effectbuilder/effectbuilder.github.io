<head>
    <title>Solar System</title>
    <meta description="Displays a series of circles rotating around a sun. Highly customizable!" />
    <meta publisher="Jose Miranda" />
    <meta property="enableSun" label="Sun: Enable" type="boolean" default="true">
    <meta property="sunRadius" label="Sun: Radius" type="number" min="5" max="100" default="20">
    <meta property="sunColor" label="Sun: Color" type="color" default="#FFFF00">
    <meta property="enableSunColorCycle" label="Sun: Enable Color Cycling" type="boolean" default="true">
    <meta property="sunColorCycleSpeed" label="Sun: Color Cycle Speed" type="number" min="1" max="10" default="2">
    <meta property="enableSunAnimation" label="Sun: Animate" type="boolean" default="true">
    <meta property="enableFlares" label="Sun: Flares: Enable Flares" type="boolean" default="true">
    <meta property="flareCount" label="Sun: Flares Count" type="number" min="4" max="12" default="8">
    <meta property="flareLength" label="Sun: Flares Length" type="number" min="10" max="50" default="30">
    <meta property="flareSpeed" label="Sun: Flares Speed" type="number" min="0" max="10" default="4">
    <meta property="flareGlow" label="Sun: Flares Glow Intensity" type="number" min="0" max="10" default="8">
    <meta property="enablePlanets" label="Planets: Enable" type="boolean" default="true">
    <meta property="planetCount" label="Planets: Count" type="number" min="1" max="50" default="11">
    <meta property="planetSizeMultiplier" label="Planets: Size Multiplier" type="number" min="1" max="100" default="6">
    <meta property="speed" label="Planets: Speed" type="number" min="1" max="5" default="1">
    <meta property="enableColorCycle" label="Planets: Enable Color Cycling" type="boolean" default="true">
    <meta property="colorCycleSpeed" label="Planets: Color Cycle Speed" type="number" min="0" max="10" default="2">
    <meta property="enablePath" label="Planets: Enable Paths" type="boolean" default="true">
    <meta property="trailLength" label="Planets: Path Length" type="number" min="5" max="200" default="80">
    <meta property="pathLineWidth" label="Planets: Path Width" type="number" min="1" max="10" default="3"> 
    <meta property="usePlanetColors" label="Planets: Paths Use Planet Colors" type="boolean" default="true">
    <meta property="pathColor" label="Planets: Path Color" type="color" default="#FFFFFF">
</head>

<style>
  /* The CSS is mostly for browser display; SignalRGB ignores these dimensions */
  #myCanvas {
    width: 320px; /* Fixed width for consistency */
    height: 200px; /* Fixed height for consistency */
  }

  body {
    margin: 0;
    padding: 0;
    background-color: rgb(0, 0, 0);
  }
</style>

<body>
  <canvas id="myCanvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// ðŸ”¥ BROWSER COMPATIBILITY MOCK ENVIRONMENT & GLOBAL DEFAULTS
// -------------------------------------------------------------------

// Define all meta properties as global variables if not already defined (i.e., in a browser)
if (typeof enableSun === 'undefined') var enableSun = true;
if (typeof sunRadius === 'undefined') var sunRadius = 20;
if (typeof sunColor === 'undefined') var sunColor = "#FFFF00";
if (typeof enableSunColorCycle === 'undefined') var enableSunColorCycle = true;
if (typeof sunColorCycleSpeed === 'undefined') var sunColorCycleSpeed = 2;
if (typeof enableSunAnimation === 'undefined') var enableSunAnimation = true;
if (typeof enableFlares === 'undefined') var enableFlares = true;
if (typeof flareCount === 'undefined') var flareCount = 8;
if (typeof flareLength === 'undefined') var flareLength = 30;
if (typeof flareSpeed === 'undefined') var flareSpeed = 4;
if (typeof flareGlow === 'undefined') var flareGlow = 8;
if (typeof enablePlanets === 'undefined') var enablePlanets = true;
if (typeof planetCount === 'undefined') var planetCount = 11;
if (typeof planetSizeMultiplier === 'undefined') var planetSizeMultiplier = 6;
if (typeof speed === 'undefined') var speed = 1;
if (typeof enableColorCycle === 'undefined') var enableColorCycle = true;
if (typeof colorCycleSpeed === 'undefined') var colorCycleSpeed = 2;
if (typeof enablePath === 'undefined') var enablePath = true;
if (typeof trailLength === 'undefined') var trailLength = 80;
if (typeof pathLineWidth === 'undefined') var pathLineWidth = 3; 
if (typeof usePlanetColors === 'undefined') var usePlanetColors = true;
if (typeof pathColor === 'undefined') var pathColor = "#FFFFFF";
if (typeof engine === 'undefined') var engine = {}; 

// -------------------------------------------------------------------
// SETUP & INITIALIZATION
// -------------------------------------------------------------------

const canvas = document.getElementById("myCanvas");
const context = canvas.getContext("2d");

// Ensure canvas dimensions are respected
const CANVAS_WIDTH = 320;
const CANVAS_HEIGHT = 200;
canvas.width = CANVAS_WIDTH;
canvas.height = CANVAS_HEIGHT;

let planets = [];
let planetCountCurrent; 
let currentSunRadius; 
let sunHue = 60;
let flarePhase = 0;
let flareRotation = 0;
const flares = Array(12).fill().map(() => Math.random() * Math.PI * 2);

window.onload = () => {
  planetCountCurrent = getPlanetCount();
  currentSunRadius = getSunRadius();
  
  // Removed setSize() call, using fixed CANVAS_WIDTH/HEIGHT
  generatePlanets(planetCountCurrent);
  anim(); 
};


// -------------------------------------------------------------------
// GETTER FUNCTIONS (Original Logic)
// -------------------------------------------------------------------

function getSpeed() {
  const value = (typeof speed !== "undefined" && !isNaN(speed)) ? speed / 200 : 2 / 200;
  return value;
}

function getPlanetSizeMultiplier() {
  const value = (typeof planetSizeMultiplier !== "undefined" && !isNaN(planetSizeMultiplier)) ? Math.max(1, Math.min(100, planetSizeMultiplier)) : 6;
  return value;
}

function getTrailLength() {
  const value = Math.round(typeof trailLength !== "undefined" && !isNaN(trailLength)) ? trailLength : 80;
  return value;
}

function getTrailSpeed() {
  // Uses implied default of 0.05
  const value = 0.05; 
  return value;
}

function getPlanetCount() {
  const value = Math.round(typeof planetCount !== "undefined" && !isNaN(planetCount)) ? planetCount : 11;
  return value;
}

function getColorCycleSpeed() {
  const value = (typeof colorCycleSpeed !== "undefined" && !isNaN(colorCycleSpeed)) ? colorCycleSpeed / 10 : 2 / 10;
  return value;
}

function getEnableColorCycle() {
  const value = typeof enableColorCycle !== "undefined" ? enableColorCycle : true;
  return value;
}

function getPathWidth() {
  const value = (typeof pathLineWidth !== "undefined" && !isNaN(pathLineWidth)) ? Math.max(1, Math.min(10, pathLineWidth)) : 3;
  return value;
}

function getPathColor() {
  const value = (typeof pathColor !== "undefined" && pathColor && pathColor.match(/^#[0-9A-Fa-f]{6}$/)) ? pathColor : "#FFFFFF";
  return value;
}

function getUsePlanetColors() {
  const value = typeof usePlanetColors !== "undefined" ? usePlanetColors : true;
  return value;
}

function getEnableSun() {
  const value = typeof enableSun !== "undefined" ? enableSun : true;
  return value;
}

function getSunRadius() {
  const value = (typeof sunRadius !== "undefined" && !isNaN(sunRadius)) ? Math.max(5, Math.min(100, sunRadius)) : 20; 
  return value;
}

function getSunColor() {
  if (getEnableSunColorCycle()) {
    return hslToHex(sunHue, 100, 50);
  }
  const color = (typeof sunColor !== "undefined" && sunColor && sunColor.match(/^#[0-9A-Fa-f]{6}$/)) ? sunColor : "#FFFF00";
  return color;
}

function getEnableSunColorCycle() {
  const value = typeof enableSunColorCycle !== "undefined" ? enableSunColorCycle : true;
  return value;
}

function getSunColorCycleSpeed() {
  const value = (typeof sunColorCycleSpeed !== "undefined" && !isNaN(sunColorCycleSpeed)) ? sunColorCycleSpeed / 10 : 2 / 10;
  return value;
}

function getEnableSunAnimation() {
  const value = typeof enableSunAnimation !== "undefined" ? enableSunAnimation : true;
  return value;
}

function getEnableFlares() {
  const value = typeof enableFlares !== "undefined" ? enableFlares : true;
  return value;
}

function getFlareCount() {
  const value = Math.round(typeof flareCount !== "undefined" && !isNaN(flareCount)) ? Math.max(4, Math.min(12, flareCount)) : 8;
  return value;
}

function getFlareLength() {
  const value = (typeof flareLength !== "undefined" && !isNaN(flareLength)) ? Math.max(10, Math.min(50, flareLength)) : 30;
  return value;
}

function getFlareSpeed() {
  const value = (typeof flareSpeed !== "undefined" && !isNaN(flareSpeed)) ? flareSpeed / 20 : 4 / 20;
  return value;
}

function getFlareGlow() {
  const value = (typeof flareGlow !== "undefined" && !isNaN(flareGlow)) ? flareGlow / 10 : 0.8;
  return value;
}

function getEnablePlanets() {
  const value = typeof enablePlanets !== "undefined" ? enablePlanets : true;
  return value;
}

function getEnablePath() {
  const value = typeof enablePath !== "undefined" ? enablePath : true;
  return value;
}

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hslToHex(h, s, l) {
  try {
    l /= 100;
    const a = s * Math.min(l, 1 - l) / 100;
    const f = n => {
      const k = (n + h / 30) % 12;
      const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
      return Math.round(255 * color).toString(16).padStart(2, '0');
    };
    return `#${f(0)}${f(8)}${f(4)}`;
  } catch (e) {
    return "#FFFF00";
  }
}

function hexToRgb(hex) {
  try {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return { r, g, b };
  } catch (e) {
    return { r: 255, g: 255, b: 0 };
  }
}

function mixColors(color1, color2, t) {
  try {
    if (!color1 || !color2 || !color1.match(/^#[0-9A-Fa-f]{6}$/) || !color2.match(/^#[0-9A-Fa-f]{6}$/)) {
      return color1 || "#FFFF00";
    }
    const rgb1 = hexToRgb(color1);
    const rgb2 = hexToRgb(color2);
    const r = Math.round(rgb1.r * (1 - t) + rgb2.r * t);
    const g = Math.round(rgb1.g * (1 - t) + rgb2.g * t);
    const b = Math.round(rgb1.b * (1 - t) + rgb2.b * t);
    const hex = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    return hex;
  } catch (e) {
    return color1 || "#FFFF00";
  }
}

// -------------------------------------------------------------------
// PLANET & CANVAS LOGIC
// -------------------------------------------------------------------

// Removed setSize() as it was causing dynamic resizing, overriding 320x200.

function generatePlanets(amount) {
  if (!Number.isFinite(amount) || amount < 0) {
    amount = 11;
  }
  planets = [];
  const trailLength = getTrailLength();
  const pathWidth = getPathWidth();
  
  try {
    for (let i = 0; i < amount; i++) {
      planets[i] = new Planet(
        CANVAS_WIDTH / 2, // Use fixed width
        CANVAS_HEIGHT / 2, // Use fixed height
        Math.random() * 1.5 + 0.5,
        Math.random() * 360,
        Math.random() * 1 + 0.5,
        trailLength,
        pathWidth
      );
    }
  } catch (e) {
    // ignore
  }
  planetCountCurrent = amount;
}

function Planet(x, y, baseSize, hue, baseRotateSpeed, maxHistoryLength, pathWidth) {
  this.baseSize = baseSize;
  this.hue = hue;
  this.theta = Math.random() * Math.PI * 2;
  this.baseRotateSpeed = baseRotateSpeed;
  // Use fixed CANVAS_WIDTH/HEIGHT for radius calculation
  const maxRadius = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / 2 - 10;
  const minRadius = getSunRadius() + 20;
  this.t = Math.random() * (maxRadius - minRadius) + minRadius;
  this.t_max = maxRadius;
  this.circleRadius = this.baseSize * getPlanetSizeMultiplier();
  this.positionHistory = [];
  this.maxHistoryLength = maxHistoryLength;
  this.pathWidth = pathWidth;
  this.x = CANVAS_WIDTH / 2 + Math.cos(this.theta) * this.t;
  this.y = CANVAS_HEIGHT / 2 + Math.sin(this.theta) * this.t;

  this.rotate = () => {
    try {
      if (!context) return;
      
      this.maxHistoryLength = getTrailLength();
      this.pathWidth = getPathWidth();

      if (getEnableColorCycle()) {
        this.hue = (this.hue + getColorCycleSpeed()) % 360;
      }

      this.circleRadius = this.baseSize * getPlanetSizeMultiplier();

      const trailSpeed = getTrailSpeed();
      this.frameCount = (this.frameCount || 0) + 1;
      if (this.frameCount >= Math.max(1, Math.round(10 * trailSpeed))) {
        this.positionHistory.push({ x: this.x, y: this.y, hue: this.hue });
        this.frameCount = 0;
      }

      while (this.positionHistory.length > this.maxHistoryLength) {
        this.positionHistory.shift();
      }

      const distanceFactor = Math.min((this.t_max / this.t) ** 0.3, 1.5);
      this.rotateSpeed = this.baseRotateSpeed * getSpeed() * distanceFactor;

      this.theta += this.rotateSpeed;
      this.x = CANVAS_WIDTH / 2 + Math.cos(this.theta) * this.t;
      this.y = CANVAS_HEIGHT / 2 + Math.sin(this.theta) * this.t;

      context.save();
      context.lineCap = "round";
      context.lineJoin = "round";

      if (getEnablePath() && this.positionHistory.length >= 2) {
        for (let i = 0; i < this.positionHistory.length - 1; i++) {
          if (isNaN(this.positionHistory[i].x) || isNaN(this.positionHistory[i].y)) continue;
          context.beginPath();
          context.lineWidth = this.pathWidth;
          context.strokeStyle = getUsePlanetColors() ? hslToHex(this.positionHistory[i].hue, 100, 50) : getPathColor();
          context.globalAlpha = 0.5 * (i + 1) / this.positionHistory.length;
          context.moveTo(this.positionHistory[i].x, this.positionHistory[i].y);
          context.lineTo(this.positionHistory[i + 1].x, this.positionHistory[i + 1].y);
          context.stroke();
        }
      }

      context.beginPath();
      context.fillStyle = hslToHex(this.hue, 100, 50);
      context.globalAlpha = 0.5;
      context.arc(this.x, this.y, this.circleRadius, 0, Math.PI * 2);
      context.fill();

      context.restore();
    } catch (e) {
      // ignore
    }
  };
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

function anim() {
  try {
    window.requestAnimationFrame(anim);
    if (!context) return;
    
    // Clear canvas
    context.fillStyle = "rgb(0, 0, 0)";
    context.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); // Use fixed dimensions

    // Sun Color Cycling and Animation
    if (getEnableSunColorCycle()) {
      sunHue = (sunHue + getSunColorCycleSpeed()) % 360;
    }

    if (getEnableSunAnimation()) {
      const flareSpeed = getFlareSpeed();
      flarePhase += flareSpeed * 0.1;
      flareRotation += flareSpeed * 0.02;
    }

    // Sun Redrawing and Planet Regeneration Check
    const newSunRadius = getSunRadius();
    if (newSunRadius !== currentSunRadius) {
      currentSunRadius = newSunRadius;
      generatePlanets(planetCountCurrent);
    }

    // Draw Sun and Flares
    if (getEnableSun()) {
      const sunColor = getSunColor();
      const centerX = CANVAS_WIDTH / 2; // Use fixed center
      const centerY = CANVAS_HEIGHT / 2; // Use fixed center
      const radius = getSunRadius();
      
      // Draw Sun Body
      context.save();
      context.beginPath();
      context.fillStyle = sunColor;
      context.globalAlpha = 1.0;
      context.arc(centerX, centerY, radius, 0, Math.PI * 2);
      context.fill();
      context.restore();

      // Draw Sun Halo
      context.save();
      context.beginPath();
      context.fillStyle = sunColor;
      context.globalAlpha = getFlareGlow() * 0.1;
      context.arc(centerX, centerY, radius + 10, 0, Math.PI * 2);
      context.fill();
      context.restore();

      // Draw Flares
      if (getEnableFlares()) {
        const flareCount = getFlareCount();
        const flareLength = getFlareLength();
        const isFlareAnimated = getEnableSunAnimation();
        
        context.save();
        for (let i = 0; i < flareCount; i++) {
          try {
            if (i >= flares.length) continue;
            const baseAngle = (2 * Math.PI * i) / flareCount + (isFlareAnimated ? flareRotation : 0);
            const phaseOffset = flares[i];
            const lengthScale = isFlareAnimated ? 0.3 + 0.9 * (0.5 + 0.5 * Math.sin(flarePhase + phaseOffset)) : 0.3;
            const alpha = getFlareGlow() * 0.1 + 0.6 * (isFlareAnimated ? (0.5 + 0.5 * Math.cos(flarePhase + phaseOffset)) : 0.1);
            const jitter = (isFlareAnimated && getFlareSpeed() > 0) ? (Math.random() - 0.5) * 0.05 : 0;
            const angle = baseAngle + jitter;
            
            const startX = centerX + Math.cos(angle) * radius;
            const startY = centerY + Math.sin(angle) * radius;
            const endX = centerX + Math.cos(angle) * (radius + flareLength * lengthScale);
            const endY = centerY + Math.sin(angle) * (radius + flareLength * lengthScale);

            const segments = 4;
            for (let j = 0; j < segments; j++) {
              const t = j / (segments - 1);
              const segX = startX + (endX - startX) * t;
              const segY = startY + (endY - startY) * t;
              
              context.beginPath();
              context.lineWidth = 4 * (1 - t) + 0.5 * t;
              const mixedColor = mixColors(sunColor, "#FFFFFF", t * 0.7);
              context.strokeStyle = mixedColor;
              context.globalAlpha = alpha * (1 - t * 0.5);
              
              const prevT = Math.max(t - 0.1, 0);
              const prevX = startX + (endX - startX) * prevT;
              const prevY = startY + (endY - startY) * prevT;
              
              context.moveTo(prevX, prevY);
              context.lineTo(segX, segY);
              context.stroke();
            }
          } catch (e) {
            // ignore
          }
        }
        context.restore();
      }
    }

    // Draw Planets
    if (getEnablePlanets()) {
      const newPlanetCount = getPlanetCount();
      if (newPlanetCount !== planetCountCurrent) {
        generatePlanets(newPlanetCount);
      }
      planets.forEach(planet => {
        if (planet && typeof planet.rotate === "function") {
          planet.rotate();
        }
      });
    }
  } catch (e) {
    // ignore
  }
}
</script>