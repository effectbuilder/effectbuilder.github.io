<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SRGB Effect Combiner</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body { margin: 0; background: #111; color: #eee; font-family: 'Segoe UI', sans-serif; overflow: hidden; display: flex; height: 100vh; }
        
        /* Sidebar */
        #sidebar {
            width: 380px;
            background: #1a1a1a;
            border-right: 1px solid #333;
            padding: 20px;
            display: flex;
            flex-direction: column;
            z-index: 10;
            height: 100vh;
            box-sizing: border-box;
            flex-shrink: 0;
        }

        #sidebar-scroll-area {
            flex-grow: 1;
            overflow-y: auto;
            padding-right: 10px;
            margin-bottom: 15px;
        }

        #sidebar-footer {
            flex-shrink: 0;
            border-top: 1px solid #333;
            padding-top: 15px;
            display: flex;
            gap: 10px;
        }
        
        /* Header & Logo Styles */
        .app-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
            padding-bottom: 15px;
        }
        .app-header img {
            max-height: 32px;
            width: auto;
        }
        .app-header h2 {
            margin: 0;
            font-size: 1.3rem;
            color: #00eaff;
            line-height: 1;
        }

        h3 { margin: 15px 0 5px 0; font-size: 0.9rem; color: #888; text-transform: uppercase; letter-spacing: 1px; border-bottom: 1px solid #333; padding-bottom: 5px; }
        
        .control-group { background: #252525; padding: 12px; border-radius: 8px; border: 1px solid #333; margin-bottom: 10px; }
        
        input[type="text"], textarea { width: 100%; box-sizing: border-box; background: #333; border: 1px solid #444; color: #fff; padding: 8px; border-radius: 4px; margin-bottom: 8px; font-family: inherit; font-size: 0.85rem; }
        input[type="text"]:focus, textarea:focus { border-color: #00eaff; outline: none; }
        
        .card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; border-bottom: 1px solid #333; padding-bottom: 5px; }
        .layer-title { font-size: 0.9rem; font-weight: bold; color: #ccc; }
        .actions { display: flex; gap: 4px; }
        .icon-btn { background: #333; border: none; color: #888; cursor: pointer; width: 24px; height: 24px; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 0.8rem; transition: 0.2s; }
        .icon-btn:hover { background: #444; color: #fff; }
        .btn-close:hover { background: #522; color: #f55; }

        .layout-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 15px; }
        button.mode-btn { background: #333; border: 1px solid #444; color: #fff; padding: 10px; border-radius: 4px; cursor: pointer; transition: 0.2s; font-size: 0.8rem; }
        button.mode-btn:hover { background: #444; }
        button.mode-btn.active { background: #00eaff; color: #000; border-color: #00eaff; font-weight: bold; }

        /* Action Buttons */
        #btn-export { flex-grow: 2; background: #00eaff; color: #000; font-weight: bold; border: none; padding: 15px; border-radius: 6px; cursor: pointer; font-size: 1rem; text-transform: uppercase; letter-spacing: 1px; }
        #btn-export:hover { background: #00cce6; box-shadow: 0 0 15px rgba(0,234,255,0.3); }

        #btn-clear { flex-grow: 1; background: #331111; color: #ff5555; font-weight: bold; border: 1px solid #552222; padding: 15px; border-radius: 6px; cursor: pointer; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 1px; }
        #btn-clear:hover { background: #551111; border-color: #ff3333; color: #fff; }

        .file-upload { border: 2px dashed #444; padding: 15px; text-align: center; color: #888; cursor: pointer; border-radius: 8px; transition: 0.2s; font-size: 0.9rem; display: block; }
        .file-upload:hover { border-color: #00eaff; color: #fff; background: #222; }
        input[type="file"] { display: none; }
        input[type="range"] { width: 100%; accent-color: #00eaff; height: 4px; margin-bottom: 10px; cursor: pointer; }
        select { width: 100%; background: #333; color: #fff; border: 1px solid #444; padding: 4px; border-radius: 4px; cursor: pointer; }

        .prop-badge { 
            display: inline-block; font-size: 0.7rem; background: #444; color: #aaa; padding: 2px 6px; border-radius: 4px; margin-top: 5px;
        }

        /* --- UPDATED VIEWPORT BACKGROUND --- */
        #viewport {
            flex-grow: 1; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            background-color: #080808;
            
            /* Professional Grid Pattern */
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            background-position: center;

            position: relative;
            /* padding: 40px;  */
            box-sizing: border-box; 
            overflow: hidden;
        }
        
        canvas#master-canvas {
            box-shadow: 0 0 60px rgba(0,0,0,0.9); 
            image-rendering: pixelated; 
            aspect-ratio: 16 / 9; 
            width: 100%; 
            height: auto; 
            max-height: 100%; 
            object-fit: contain;
            border: 1px solid #222;
        }
        #hidden-sandbox { position: absolute; top: -9999px; left: -9999px; visibility: hidden; }
        iframe { width: 320px; height: 200px; border: none; }
    </style>
</head>
<body>

    <div id="sidebar">
        <div id="sidebar-scroll-area">
            <div class="app-header">
                <img src="../logo.png" alt="SRGB Logo">
                <h2>SRGB Effect Combiner</h2>
            </div>
            
            <h3>1. Metadata</h3>
            <input type="text" id="meta-title" placeholder="Effect Title" value="My Custom Mix" oninput="Persistence.save()">
            <input type="text" id="meta-publisher" placeholder="Publisher Name" value="User" oninput="Persistence.save()">
            <textarea id="meta-desc" rows="2" placeholder="Description" oninput="Persistence.save()">A custom composite effect.</textarea>

            <h3>2. Source Files</h3>
            <label class="file-upload">
                + Add HTML Effects
                <input type="file" multiple accept=".html" onchange="compositor.handleUpload(this.files)">
            </label>

            <h3>3. Preview Layout</h3>
            <div class="control-group">
                <div class="layout-grid">
                    <button onclick="compositor.setLayout('LAYERED')" class="mode-btn active" id="btn-layered">Layered</button>
                    <button onclick="compositor.setLayout('SIDE_BY_SIDE')" class="mode-btn" id="btn-side">Side/Side</button>
                    <button onclick="compositor.setLayout('VERTICAL')" class="mode-btn" id="btn-vert">Vertical</button>
                    <button onclick="compositor.setLayout('GRID')" class="mode-btn" id="btn-grid">Grid</button>
                </div>
                <button onclick="compositor.setLayout('PIP')" class="mode-btn" style="width:100%" id="btn-pip">Picture in Picture</button>
            </div>

            <h3>4. Layers</h3>
            <div id="layer-list"></div>
        </div>

        <div id="sidebar-footer">
            <button id="btn-clear" onclick="Persistence.clear()">Reset</button>
            <button id="btn-export" onclick="exporter.download()">Export .ZIP</button>
        </div>
    </div>

    <div id="viewport">
        <canvas id="master-canvas" width="640" height="360"></canvas>
    </div>

    <div id="hidden-sandbox"></div>

<script>
// --- LOCAL STORAGE MANAGER ---
const Persistence = {
    KEY: 'srgb_combiner_state_v1',
    
    save() {
        const state = {
            meta: {
                title: document.getElementById('meta-title').value,
                publisher: document.getElementById('meta-publisher').value,
                desc: document.getElementById('meta-desc').value
            },
            layout: compositor.layout,
            layers: compositor.layers.map(l => ({
                name: l.name,
                content: l.content, // Raw HTML string
                enabled: l.enabled,
                opacity: l.opacity,
                blend: l.blend
            }))
        };
        localStorage.setItem(this.KEY, JSON.stringify(state));
    },

    load() {
        const raw = localStorage.getItem(this.KEY);
        if (!raw) return;
        try {
            const state = JSON.parse(raw);
            
            // Restore Metadata
            if(state.meta) {
                document.getElementById('meta-title').value = state.meta.title || "";
                document.getElementById('meta-publisher').value = state.meta.publisher || "";
                document.getElementById('meta-desc').value = state.meta.desc || "";
            }

            // Restore Layers
            if (state.layers && Array.isArray(state.layers)) {
                state.layers.forEach(l => {
                    // Re-create the layer from content
                    compositor.createLayer(l.name, l.content, {
                        enabled: l.enabled,
                        opacity: l.opacity,
                        blend: l.blend
                    });
                });
            }

            // Restore Layout (Must be done after layers to update UI correctly)
            if(state.layout) {
                compositor.setLayout(state.layout);
            }

        } catch(e) {
            console.error("Failed to load saved state:", e);
        }
    },

    clear() {
        if(confirm("Are you sure you want to clear the project? This cannot be undone.")) {
            localStorage.removeItem(this.KEY);
            location.reload();
        }
    }
};

// --- COMPOSITOR ---
class Compositor {
    constructor() {
        this.masterCanvas = document.getElementById('master-canvas');
        this.ctx = this.masterCanvas.getContext('2d');
        this.width = 640;
        this.height = 360;
        this.masterCanvas.width = this.width;
        this.masterCanvas.height = this.height;

        this.layers = []; 
        this.layout = 'LAYERED';
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    handleUpload(files) {
        Array.from(files).forEach(file => {
            const reader = new FileReader();
            reader.onload = (e) => {
                this.createLayer(file.name, e.target.result);
                Persistence.save(); // Save after upload
            };
            reader.readAsText(file);
        });
    }

    // Updated createLayer to accept optional 'restoredState' for loading settings
    createLayer(name, htmlContent, restoredState = null) {
        const id = Date.now() + Math.random();
        
        // 1. Parse Metadata
        const parser = new DOMParser();
        const doc = parser.parseFromString(htmlContent, "text/html");
        const metaTags = doc.querySelectorAll('meta[property]');
        const extractedProps = [];
        
        metaTags.forEach(tag => {
            const prop = tag.getAttribute('property');
            if(prop) {
                extractedProps.push({
                    name: prop,
                    label: tag.getAttribute('label') || prop,
                    type: tag.getAttribute('type') || 'text',
                    min: tag.getAttribute('min'),
                    max: tag.getAttribute('max'),
                    default: tag.getAttribute('default'),
                    values: tag.getAttribute('values')
                });
            }
        });

        // 2. Create Sandbox
        const iframe = document.createElement('iframe');
        iframe.id = `frame-${id}`;
        document.getElementById('hidden-sandbox').appendChild(iframe);
        
        // Inject Mock Engine
        iframe.contentWindow.engine = { 
            audio: { freq: new Array(128).fill(0) },
            getSensorValue: () => 0 
        };

        const iframeDoc = iframe.contentWindow.document;
        iframeDoc.open();
        iframeDoc.write(htmlContent);
        iframeDoc.close();

        // Determine initial settings (Load from state or default)
        let defaultBlend = (this.layout === 'LAYERED' && this.layers.length > 0) ? 'screen' : 'source-over';
        
        const layer = {
            id: id,
            name: name,
            content: htmlContent, 
            props: extractedProps, 
            iframe: iframe,
            window: iframe.contentWindow,
            sourceCanvas: null,
            enabled: restoredState ? restoredState.enabled : true,
            opacity: restoredState ? restoredState.opacity : 1.0,
            blend: restoredState ? restoredState.blend : defaultBlend,
            rect: { x: 0, y: 0, w: this.width, h: this.height }
        };

        this.layers.push(layer);
        this.updateLayout();
        this.renderUI();
    }

    removeLayer(index) {
        const layer = this.layers[index];
        if (layer) {
            layer.iframe.remove(); 
            this.layers.splice(index, 1);
            this.updateLayout();
            this.renderUI();
            Persistence.save(); // Save changes
        }
    }

    moveLayer(index, direction) {
        const newIndex = index + direction;
        if (newIndex < 0 || newIndex >= this.layers.length) return;
        const temp = this.layers[index];
        this.layers[index] = this.layers[newIndex];
        this.layers[newIndex] = temp;
        this.updateLayout();
        this.renderUI();
        Persistence.save(); // Save changes
    }

    setLayout(mode) {
        this.layout = mode;
        this.layers.forEach(l => l.enabled = true);
        if (mode === 'SIDE_BY_SIDE' || mode === 'VERTICAL' || mode === 'GRID') {
            this.layers.forEach(l => l.blend = 'source-over');
        }
        this.updateLayout();
        
        document.querySelectorAll('.layout-grid button, #btn-pip').forEach(b => b.classList.remove('active'));
        if(mode === 'LAYERED') document.getElementById('btn-layered').classList.add('active');
        if(mode === 'SIDE_BY_SIDE') document.getElementById('btn-side').classList.add('active');
        if(mode === 'VERTICAL') document.getElementById('btn-vert').classList.add('active');
        if(mode === 'GRID') document.getElementById('btn-grid').classList.add('active');
        if(mode === 'PIP') document.getElementById('btn-pip').classList.add('active');
        this.renderUI();
        Persistence.save(); // Save changes
    }

    // Helper for updating layer properties from UI
    updateLayerProp(index, key, value) {
        if(this.layers[index]) {
            this.layers[index][key] = value;
            Persistence.save(); // Auto-save on slider/select change
        }
    }

    updateLayout() {
        const w = this.width;
        const h = this.height;
        const count = this.layers.length;
        let gridCols = Math.ceil(Math.sqrt(count));
        let gridRows = Math.ceil(count / gridCols);

        this.layers.forEach((layer, index) => {
            let r = { x: 0, y: 0, w: w, h: h }; 
            if (this.layout === 'SIDE_BY_SIDE' && count > 0) {
                const sw = w / count;
                r = { x: sw * index, y: 0, w: sw, h: h };
            }
            else if (this.layout === 'VERTICAL' && count > 0) {
                const sh = h / count;
                r = { x: 0, y: sh * index, w: w, h: sh };
            }
            else if (this.layout === 'GRID') {
                const col = index % gridCols;
                const row = Math.floor(index / gridCols);
                const cw = w / gridCols;
                const ch = h / gridRows;
                r = { x: col * cw, y: row * ch, w: cw, h: ch };
            }
            else if (this.layout === 'PIP') {
                if (index > 0) {
                    const pw = w * 0.25, ph = h * 0.25, pad = 10;
                    const si = index - 1;
                    r = { x: w - pw - pad, y: h - ph - pad - (si * (ph + pad)), w: pw, h: ph };
                }
            }
            layer.rect = r;
        });
    }

    loop() {
        const time = Date.now() / 1000;
        const bass = (Math.sin(time * 10) + 1) * 120;
        const fakeAudio = new Array(200).fill(bass);
        
        this.layers.forEach(layer => {
            if (layer.window && layer.window.engine && layer.window.engine.audio) {
                if (layer.window.engine.audio.freq.length < 200) {
                    layer.window.engine.audio.freq = new Array(200).fill(0);
                }
                for(let i=0; i<200; i++) layer.window.engine.audio.freq[i] = fakeAudio[i];
                layer.window.engine.audio.level = -20; 
                layer.window.engine.audio.density = 0.5;
            }
        });

        const w = this.width;
        const h = this.height;
        this.ctx.fillStyle = "#000"; // Clear logic is handled by CSS bg, but canvas needs wipe
        this.ctx.clearRect(0,0,w,h);

        this.layers.forEach((l, i) => {
            if (!l.canvas) {
                const cans = l.window.document.getElementsByTagName('canvas');
                if(cans.length) l.canvas = cans[0];
            }
            if (l.canvas) {
                const r = l.rect;
                this.ctx.globalAlpha = l.opacity;
                this.ctx.globalCompositeOperation = l.blend === 'source-over' ? 'source-over' : l.blend;
                try { this.ctx.drawImage(l.canvas, r.x, r.y, r.w, r.h); } catch(e) {}
            }
        });
        requestAnimationFrame(this.loop);
    }

    renderUI() {
        const container = document.getElementById('layer-list');
        container.innerHTML = '';
        this.layers.forEach((layer, idx) => {
            const div = document.createElement('div');
            div.className = 'control-group';
            const propsList = layer.props.map(p => p.label).join(', ');
            
            div.innerHTML = `
                <div class="card-header">
                    <span class="layer-title">${idx + 1}. ${layer.name.substring(0, 15)}...</span>
                    <div class="actions">
                        <button class="icon-btn" onclick="compositor.moveLayer(${idx}, -1)">▲</button>
                        <button class="icon-btn" onclick="compositor.moveLayer(${idx}, 1)">▼</button>
                        <button class="icon-btn btn-close" onclick="compositor.removeLayer(${idx})">✖</button>
                    </div>
                </div>
                <label>
                    <input type="checkbox" ${layer.enabled ? 'checked' : ''} 
                    onchange="compositor.updateLayerProp(${idx}, 'enabled', this.checked); compositor.renderUI();"> Enabled
                </label>
                <label>Opacity: <span id="op-val-${idx}">${Math.round(layer.opacity*100)}%</span></label>
                <input type="range" min="0" max="1" step="0.05" value="${layer.opacity}" 
                    oninput="compositor.updateLayerProp(${idx}, 'opacity', parseFloat(this.value)); document.getElementById('op-val-${idx}').innerText = Math.round(this.value*100) + '%'">
                <label>Blend Mode</label>
                <select onchange="compositor.updateLayerProp(${idx}, 'blend', this.value)">
                    <option value="source-over" ${layer.blend === 'source-over'?'selected':''}>Normal</option>
                    <option value="screen" ${layer.blend === 'screen'?'selected':''}>Screen</option>
                    <option value="overlay" ${layer.blend === 'overlay'?'selected':''}>Overlay</option>
                    <option value="multiply" ${layer.blend === 'multiply'?'selected':''}>Multiply</option>
                    <option value="difference" ${layer.blend === 'difference'?'selected':''}>Difference</option>
                    <option value="lighter" ${layer.blend === 'lighter'?'selected':''}>Lighter</option>
                </select>
                <div style="margin-top:8px; border-top:1px solid #444; padding-top:5px;">
                    <span style="font-size:0.7rem; color:#888;">Detected Controls:</span><br>
                    <span class="prop-badge">${propsList || "None"}</span>
                </div>
            `;
            container.appendChild(div);
        });
    }
}

// --- EXPORTER ---
const exporter = {
    async download() {
        if (typeof JSZip === 'undefined') {
            alert("JSZip library not loaded.");
            return;
        }

        const title = document.getElementById('meta-title').value;
        const pub = document.getElementById('meta-publisher').value;
        const desc = document.getElementById('meta-desc').value;
        
        const layoutMap = { 'LAYERED': 'Layered', 'SIDE_BY_SIDE': 'Side by Side', 'VERTICAL': 'Vertical', 'GRID': 'Grid', 'PIP': 'PiP' };
        const currentLayoutName = layoutMap[compositor.layout] || 'Layered';
        const filenameBase = title.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        
        const previewBlob = await new Promise(resolve => {
            document.getElementById('master-canvas').toBlob(blob => resolve(blob), 'image/png');
        });

        // 1. Meta Tags
        let metaTags = `
    <title>${title}</title>
    <meta name="description" content="${desc}" />
    <meta name="publisher" content="${pub}" />
    <meta property="layoutMode" label="Layout Mode" type="combobox" values="Layered,Side by Side,Vertical,Grid,PiP" default="${currentLayoutName}">`;

        compositor.layers.forEach((l, i) => {
            metaTags += `\n    `;
            metaTags += `\n    <meta property="layer_${i}_opacity" label="[${i+1}] Opacity" type="number" min="0" max="100" default="${l.opacity*100}">`;
            metaTags += `\n    <meta property="layer_${i}_blend" label="[${i+1}] Blend Mode" type="combobox" values="Normal,Screen,Overlay,Multiply,Difference,Lighter" default="${this.mapBlend(l.blend)}">`;
            
            if (l.props.length > 0) {
                 metaTags += `\n    `;
                 l.props.forEach(p => {
                     const uniqueName = `layer_${i}_${p.name}`;
                     const uniqueLabel = `[${i+1}] ${p.label}`;
                     let tag = `\n    <meta property="${uniqueName}" label="${uniqueLabel}" type="${p.type}"`;
                     if(p.min) tag += ` min="${p.min}"`;
                     if(p.max) tag += ` max="${p.max}"`;
                     if(p.default) tag += ` default="${p.default}"`;
                     if(p.values) tag += ` values="${p.values}"`;
                     tag += `>`;
                     metaTags += tag;
                 });
            }
        });

        const layerData = compositor.layers.map(l => {
            return {
                name: l.name,
                propNames: l.props.map(p => p.name),
                content: btoa(unescape(encodeURIComponent(l.content))) 
            };
        });

        const htmlContent = `<!DOCTYPE html>
<html>
<head>
    ${metaTags}
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background: #000; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #sandbox { position: absolute; visibility: hidden; }
        iframe { border: none; width: 100vw; height: 100vh; } 
    </style>
</head>
<body>
    <canvas id="master"></canvas>
    <div id="sandbox"></div>

<script>
    // BROWSER COMPATIBILITY
    if (typeof window.engine === 'undefined') {
        const metaTags = document.querySelectorAll('meta[property]');
        metaTags.forEach(meta => {
            const propName = meta.getAttribute('property');
            const propType = meta.getAttribute('type');
            const defaultVal = meta.getAttribute('default');
            if (propName) {
                let finalValue = defaultVal;
                if (propType === 'number') finalValue = parseFloat(defaultVal);
                else if (propType === 'boolean') finalValue = (defaultVal === 'true' || defaultVal === '1');
                window[propName] = finalValue;
            }
        });
        window.engine = { 
            audio: { freq: new Array(200).fill(0), level: -20, density: 0.5 },
            getSensorValue: () => 0 
        };
        function simulateAudio() {
            const time = Date.now() / 1000; 
            const dataArray = new Array(200).fill(0);
            const beat = (Math.sin(time * Math.PI * 4) + 1) / 2; 
            const bassVal = Math.pow(beat, 4) * 255; 
            dataArray[0] = bassVal; dataArray[1] = bassVal; dataArray[2] = bassVal;
            for (let i = 10; i < 40; i++) {
                const wave = (Math.sin(time * 8 + i * 0.5) + 1) / 2;
                dataArray[i] = wave * 150 + (Math.random() * 50); 
            }
            window.engine.audio.freq = dataArray;
            requestAnimationFrame(simulateAudio);
        }
        simulateAudio();
    }

    const RAW_LAYERS = ${JSON.stringify(layerData)};
    
    const app = {
        canvas: document.getElementById('master'),
        ctx: document.getElementById('master').getContext('2d'),
        layers: [],
        
        init() {
            RAW_LAYERS.forEach((lData, i) => {
                const iframe = document.createElement('iframe');
                document.getElementById('sandbox').appendChild(iframe);
                
                // --- FIX FOR EXPORT: Pre-seed complete mock engine ---
                iframe.contentWindow.engine = { 
                    audio: { freq: new Array(200).fill(0), level: -20, density: 0.5 },
                    getSensorValue: () => 0 
                };

                const doc = iframe.contentWindow.document;
                const html = decodeURIComponent(escape(atob(lData.content)));
                doc.open();
                doc.write(html);
                doc.close();
                
                this.layers.push({ 
                    window: iframe.contentWindow, 
                    canvas: null,
                    propNames: lData.propNames
                });
            });
            this.loop();
        },

        getLayoutRect(index, count, mode, w, h) {
            let r = { x: 0, y: 0, w: w, h: h };
            let gridCols = Math.ceil(Math.sqrt(count));
            let gridRows = Math.ceil(count / gridCols);

            if (mode === 'Side by Side' && count > 0) {
                const sw = w / count;
                r = { x: sw * index, y: 0, w: sw, h: h };
            }
            else if (mode === 'Vertical' && count > 0) {
                const sh = h / count;
                r = { x: 0, y: sh * index, w: w, h: sh };
            }
            else if (mode === 'Grid') {
                const col = index % gridCols;
                const row = Math.floor(index / gridCols);
                const cw = w / gridCols;
                const ch = h / gridRows;
                r = { x: col * cw, y: row * ch, w: cw, h: ch };
            }
            else if (mode === 'PiP') {
                if (index > 0) {
                    const pw = w * 0.25, ph = h * 0.25, pad = 10;
                    const si = index - 1;
                    r = { x: w - pw - pad, y: h - ph - pad - (si * (ph + pad)), w: pw, h: ph };
                }
            }
            return r;
        },

        mapBlend(val) {
            if(val === 'Normal') return 'source-over';
            if(val === 'Lighter') return 'lighter';
            return val.toLowerCase();
        },

        loop() {
            if (window.engine && window.engine.audio) {
                const data = window.engine.audio.freq;
                // Sync data to all children
                this.layers.forEach(l => {
                    if (l.window.engine && l.window.engine.audio) {
                        // Safe copy
                        const len = Math.min(data.length, l.window.engine.audio.freq.length);
                        for(let k=0; k<len; k++) l.window.engine.audio.freq[k] = data[k];
                        
                        // Sync extras if available
                        if(window.engine.audio.level !== undefined) l.window.engine.audio.level = window.engine.audio.level;
                        if(window.engine.audio.density !== undefined) l.window.engine.audio.density = window.engine.audio.density;
                    }
                });
            }

            const w = this.canvas.width = window.innerWidth;
            const h = this.canvas.height = window.innerHeight;
            let mode = "${currentLayoutName}"; 
            if (window.layoutMode) mode = window.layoutMode;
            
            this.ctx.fillStyle = "#000";
            this.ctx.fillRect(0,0,w,h);

            this.layers.forEach((l, i) => {
                const opacity = (window["layer_" + i + "_opacity"] ?? 100) / 100.0;
                let blend = window["layer_" + i + "_blend"] || "Normal";
                
                if (mode === 'Side by Side' || mode === 'Vertical' || mode === 'Grid') {
                    blend = 'Normal';
                }

                if(l.propNames) {
                    l.propNames.forEach(prop => {
                        const globalName = "layer_" + i + "_" + prop;
                        if(window[globalName] !== undefined) {
                            l.window[prop] = window[globalName];
                        }
                    });
                }

                if (!l.canvas) {
                    const cans = l.window.document.getElementsByTagName('canvas');
                    if(cans.length) l.canvas = cans[0];
                }

                if (l.canvas) {
                    const r = this.getLayoutRect(i, this.layers.length, mode, w, h);
                    this.ctx.globalAlpha = opacity;
                    this.ctx.globalCompositeOperation = this.mapBlend(blend);
                    this.ctx.drawImage(l.canvas, r.x, r.y, r.w, r.h);
                }
            });

            requestAnimationFrame(() => this.loop());
        }
    };
    
    window.onload = () => app.init();
<\/script>
</body>
</html>`;

        const zip = new JSZip();
        zip.file(`${filenameBase}.html`, htmlContent);
        zip.file(`${filenameBase}.png`, previewBlob);

        zip.generateAsync({type:"blob"}).then(function(content) {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(content);
            a.download = `${filenameBase}.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });
    },

    mapBlend(val) {
        if(val === 'source-over') return 'Normal';
        if(val === 'lighter') return 'Lighter';
        return val.charAt(0).toUpperCase() + val.slice(1);
    },
};

const compositor = new Compositor();

// Initial Load from Storage
window.onload = () => {
    Persistence.load();
};
</script>
</body>
</html>