<!DOCTYPE html><html>
<head>
    <title>ORGB: Rotating Beam</title>
    <meta description="A beam that rotates in different ways.">
    <meta publisher="JosÃ© Miranda (Port and improvements)">

    <meta property="speed" label="Speed" type="number" min="1" max="100" default="50">
    <meta property="glow" label="Glow" type="number" min="1" max="50" default="10"> <meta property="thickness" label="Thickness (%)" type="number" min="0" max="100" default="5"> <meta property="mode" label="Mode" type="list" values="Clockwise,Counter Clockwise,Pendulum,Wipers,Swing H,Swing V" default="Clockwise">
    <meta property="random_colors" label="Random Colors" type="boolean" default="false">
    <meta property="color1" label="Beam Color" type="color" default="#ff0000">
    <meta property="color2" label="Background Color" type="color" default="#0000ff">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="rotatingbeam-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('rotatingbeam-canvas');
const ctx = canvas.getContext('2d');

// --- ADDED: Disable image smoothing ---
ctx.imageSmoothingEnabled = false;
ctx.mozImageSmoothingEnabled = false;
ctx.webkitImageSmoothingEnabled = false;

const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
// --- ADDED: ImageData buffer ---
const imageData = ctx.createImageData(canvasWidth, canvasHeight);
const pixels = imageData.data;

// Effect state variables
let progress = 0.0; // Angle in radians
let hsv1 = { h: 0, s: 1, v: 1 };
let hsv2 = { h: 240/360, s: 1, v: 1 }; // Store HSV with H as 0-1
// --- MODIFIED: Initialize with defaults ---
let lastColor1 = typeof color1 !== 'undefined' ? color1 : "#ff0000";
let lastColor2 = typeof color2 !== 'undefined' ? color2 : "#0000ff";
let lastRandomColors = typeof random_colors !== 'undefined' ? random_colors : false;
let initialized = false; // Flag for initial setup

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToHsv(hex) {
    if (!hex || hex.length < 7) return { h: 0, s: 0, v: 1 };
    try {
        let r = parseInt(hex.slice(1, 3), 16) / 255;
        let g = parseInt(hex.slice(3, 5), 16) / 255;
        let b = parseInt(hex.slice(5, 7), 16) / 255;
        let max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, v = max;
        let d = max - min;
        s = max === 0 ? 0 : d / max;
        if (max === min) { h = 0; }
        else {
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6; // Normalize H to 0-1
        }
        return { h: h, s: s, v: v }; // Return H as 0-1
     } catch(e) {
         console.error("Invalid hex:", hex, e);
         return { h: 0, s: 0, v: 1 }; // White fallback
     }
}

function hsvToRgb(h, s, v) { // h(0-1), s(0-1), v(0-1)
    let r, g, b;
    const i = Math.floor(h * 6); const f = h * 6 - i;
    const p = v * (1 - s); const q = v * (1 - f * s); const t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v, g = t, b = p; break; case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break; case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break; case 5: r = v, g = p, b = q; break;
    }
    return [r * 255, g * 255, b * 255];
}

function lerpColor(c1, c2, f) {
    const factor = Math.max(0, Math.min(1, f));
    return [
        c1[0] * (1 - factor) + c2[0] * factor,
        c1[1] * (1 - factor) + c2[1] * factor,
        c1[2] * (1 - factor) + c2[2] * factor
    ];
}

// -------------------------------------------------------------------
// EFFECT LOGIC
// -------------------------------------------------------------------

/** Calculates the start and end points of the beam for the current frame */
function getBeamEndpoints(currentMode) {
    let p1 = { x: 0, y: 0 }, p2 = { x: 1, y: 1 }; // Default values
    const angle = progress; // Use progress directly as angle in radians

    switch(currentMode) {
        case "Clockwise": {
            // Circle center (0.5, 0.5), radius 0.5
            const x = 0.5 + 0.5 * Math.cos(angle);
            const y = 0.5 + 0.5 * Math.sin(angle);
            p1 = { x: x, y: y }; p2 = { x: 1 - x, y: 1 - y }; // Points opposite through center
            break;
        }
        case "Counter Clockwise": {
             // Just reverse the angle
            const x = 0.5 + 0.5 * Math.cos(-angle);
            const y = 0.5 + 0.5 * Math.sin(-angle);
            p1 = { x: x, y: y }; p2 = { x: 1 - x, y: 1 - y };
            break;
        }
        case "Pendulum": {
             // Anchor at top-center (0.5, 0), swings side to side
             // Use sin for x-motion (0 at center, +/-1 at edges) scaled to fit width
            const swingAngle = Math.PI/2 * Math.sin(angle); // Swing +/- 90 degrees
            p1 = { x: 0.5, y: 0 };
            p2 = { x: 0.5 + 0.5 * Math.sin(swingAngle), y: 1.0 }; // End point moves horizontally along bottom edge? Or full swing? Let's try full.
             //p2 = { x: 0.5 + 0.5 * Math.sin(swingAngle), y: 0.5 + 0.5 * Math.cos(swingAngle) }; // Full swing
              p2 = { x: 0.5 + Math.sin(swingAngle) * 0.5, y: Math.cos(swingAngle) }; // Swings from top center

            break;
        }
        case "Wipers": {
             // Anchored bottom-center, sweeps side-to-side along top? Or two wipers?
             // Let's do one wiper anchored bottom center
             const swingAngle = Math.PI/2 * Math.sin(angle); // Swing +/- 90 degrees
             p1 = { x: 0.5, y: 1.0 }; // Anchor bottom-center
             p2 = { x: 0.5 - Math.sin(swingAngle) * 0.5, y: 1.0 - Math.cos(swingAngle) }; // Tip moves in arc
            break;
        }
        case "Swing H": {
             // Horizontal swing, anchored left/right centers?
             // Let's assume pivots at (0, 0.5) and (1, 0.5)
             const swingVal = 0.5 * (1 + Math.sin(angle)); // 0 to 1
             p1 = { x: 0, y: swingVal };
             p2 = { x: 1, y: 1 - swingVal };
            break;
        }
        case "Swing V": {
             // Vertical swing, anchored top/bottom centers?
             // Let's assume pivots at (0.5, 0) and (0.5, 1)
             const swingVal = 0.5 * (1 + Math.sin(angle)); // 0 to 1
             p1 = { x: swingVal, y: 0 };
             p2 = { x: 1 - swingVal, y: 1 };
            break;
        }
    }
    // Clamp points to stay within 0-1 range
    p1.x = Math.max(0, Math.min(1, p1.x)); p1.y = Math.max(0, Math.min(1, p1.y));
    p2.x = Math.max(0, Math.min(1, p2.x)); p2.y = Math.max(0, Math.min(1, p2.y));

    return { p1, p2 };
}


function getPixelColor(x, y, w, h, beam) {
    // --- ADDED: Fallbacks for meta properties ---
    const currentThickness = typeof thickness !== 'undefined' ? thickness : 5;
    const currentGlow = typeof glow !== 'undefined' ? glow : 10;

    // Beam endpoints in canvas coordinates
    const x1 = beam.p1.x * (w - 1), y1 = beam.p1.y * (h - 1);
    const x2 = beam.p2.x * (w - 1), y2 = beam.p2.y * (h - 1);

    // Calculate distance from point (x, y) to the line segment (x1, y1) - (x2, y2)
    const dx = x2 - x1, dy = y2 - y1;
    const lenSq = dx*dx + dy*dy; // Squared length of the beam segment
    let distanceSq;

    if (lenSq === 0) { // If start and end points are the same
        distanceSq = Math.pow(x - x1, 2) + Math.pow(y - y1, 2);
    } else {
        // Project point (x,y) onto the line defined by the segment
        const t = ((x - x1) * dx + (y - y1) * dy) / lenSq;
        const tClamped = Math.max(0, Math.min(1, t)); // Clamp projection to the segment

        // Find the closest point on the segment to (x,y)
        const closestX = x1 + tClamped * dx;
        const closestY = y1 + tClamped * dy;

        // Calculate squared distance to the closest point
        distanceSq = Math.pow(x - closestX, 2) + Math.pow(y - closestY, 2);
    }

    const distance = Math.sqrt(distanceSq);

    // Calculate brightness (value) based on distance
    const thicknessPx = (currentThickness / 100.0) * Math.min(w, h) * 0.5; // Thickness relative to smaller dimension
    const glowFactor = Math.pow(0.95, currentGlow / 5); // Glow 1-50 -> decay 0.95^0.2 to 0.95^10

    let brightness = 0;
    if (distance <= thicknessPx) {
        brightness = 1.0 - (distance / (thicknessPx + 1)); // Linear falloff inside thickness
    } else {
        brightness = Math.pow(glowFactor, distance - thicknessPx); // Exponential decay outside
    }
    brightness = Math.max(0, Math.min(1, brightness)); // Clamp brightness

    // Beam color with calculated brightness
    const color1_rgb = hsvToRgb(hsv1.h * 360, hsv1.s, hsv1.v * brightness); // Convert h back to 0-360
    // Background color (full brightness)
    const color2_rgb = hsvToRgb(hsv2.h * 360, hsv2.s, hsv2.v); // Convert h back to 0-360

    // Blend beam onto background using additive (screen) blending logic
    // We achieve this by lerping towards the beam color based on beam brightness
    const final_color = lerpColor(color2_rgb, color1_rgb, brightness);


    // Return clamped RGB array
    return [
        Math.max(0, Math.min(255, Math.round(final_color[0]))),
        Math.max(0, Math.min(255, Math.round(final_color[1]))),
        Math.max(0, Math.min(255, Math.round(final_color[2])))
    ];
}


// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    // --- MODIFIED: Use performance.now() ---
    const now = performance.now();
    const deltaTime = lastTime === 0 ? 0.016 : (now - lastTime) / 1000; // Delta in seconds
    lastTime = now;


    if (isNaN(deltaTime) || deltaTime <= 0) {
        requestAnimationFrame(update);
        return;
    }

    // --- ADDED: Fallbacks for meta properties ---
    const currentSpeed = typeof speed !== 'undefined' ? speed : 50;
    const currentMode = typeof mode !== 'undefined' ? mode : "Clockwise";
    const currentRandomColors = typeof random_colors !== 'undefined' ? random_colors : false;
    const c1 = typeof color1 !== 'undefined' ? color1 : "#ff0000";
    const c2 = typeof color2 !== 'undefined' ? color2 : "#0000ff";

     // --- ADDED: Initialize colors on first run ---
     if (!initialized) {
        if (currentRandomColors) {
            hsv1 = { h: Math.random(), s: 1, v: 1 }; // Random H, full S, V
            hsv2 = { h: Math.random(), s: 1, v: 1 };
        } else {
            hsv1 = hexToHsv(c1);
            hsv2 = hexToHsv(c2);
        }
        lastRandomColors = currentRandomColors; // Sync initial state
        lastColor1 = c1;                         // Sync initial state
        lastColor2 = c2;                         // Sync initial state
        initialized = true;
    }


    // Update progress (angle) based on speed
    progress += (currentSpeed / 50.0) * deltaTime * Math.PI; // Speed 50 = PI radians/sec (~2 sec rotation)

    // Update colors
    if (currentRandomColors !== lastRandomColors) { // Handle toggle change
        if (currentRandomColors) {
             // Switching TO random: Start with current colors? Or new random? Let's start new.
             hsv1 = { h: Math.random(), s: 1, v: 1 };
             hsv2 = { h: Math.random(), s: 1, v: 1 };
        } else {
             // Switching FROM random: Set user colors
             hsv1 = hexToHsv(c1);
             hsv2 = hexToHsv(c2);
        }
        lastRandomColors = currentRandomColors;
    }

    if (currentRandomColors) {
        hsv1.h = (hsv1.h + 0.001 * currentSpeed * deltaTime) % 1.0; // Slow hue cycle
        hsv2.h = (hsv2.h + 0.001 * currentSpeed * deltaTime * 1.3) % 1.0;
    } else {
        // Update user colors only if they change
        if(c1 !== lastColor1) { hsv1 = hexToHsv(c1); lastColor1 = c1; }
        if(c2 !== lastColor2) { hsv2 = hexToHsv(c2); lastColor2 = c2; }
    }


    const beam = getBeamEndpoints(currentMode); // Use fallback mode

    // Render using ImageData
    for (let y = 0; y < canvasHeight; y++) {
        for (let x = 0; x < canvasWidth; x++) {
            const [r, g, b] = getPixelColor(x, y, canvasWidth, canvasHeight, beam); // Uses fallbacks
            const index = (y * canvasWidth + x) * 4;
            pixels[index] = r;
            pixels[index + 1] = g;
            pixels[index + 2] = b;
            pixels[index + 3] = 255; // Alpha
        }
    }
    ctx.putImageData(imageData, 0, 0); // Draw buffer

    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);

</script>
</html>