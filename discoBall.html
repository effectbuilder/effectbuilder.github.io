<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Disco Ball: Random Lasers</title>
    <style>
        html, body {
            padding: 0;
            margin: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, #2D3436 0%, #000000 100%);
            display: block;
            z-index: 1;
        }

        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        h3 { margin: 0 0 5px 0; color: white; font-size: 0.9rem; text-align: center; text-transform: uppercase; letter-spacing: 1px; }
        .mode-btn {
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); color: #ddd;
            padding: 10px 20px; border-radius: 6px; cursor: pointer; transition: all 0.3s ease;
            font-size: 0.8rem; font-weight: 600;
        }
        .mode-btn:hover { background: rgba(255, 255, 255, 0.25); color: #fff; }
        .mode-btn.active { background: #00d2ff; color: #000; border-color: #00d2ff; box-shadow: 0 0 15px rgba(0, 210, 255, 0.4); }
    </style>
</head>
<body>

    <canvas id="canvas"></canvas>

    <div id="controls">
        <h3>Light Mode</h3>
        <button class="mode-btn active" id="btn-reflect">Reflections</button>
        <button class="mode-btn" id="btn-laser">Random Lasers</button>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.133.1/build/three.module';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.133.1/examples/jsm/controls/OrbitControls';
        import * as BufferGeometryUtils from 'https://cdn.skypack.dev/three@0.133.1/examples/jsm/utils/BufferGeometryUtils.js';

        const canvasEl = document.querySelector('#canvas');
        const btnReflect = document.getElementById('btn-reflect');
        const btnLaser = document.getElementById('btn-laser');

        let renderer, clock, scene, camera, controls;
        let pointLights = []; 
        let discoBallMesh; 
        
        const laserCount = 12; // Increased count slightly
        const laserObjs = []; 
        const raycaster = new THREE.Raycaster();
        let lasersActive = false;

        const objectConfig = {
            geometry: new THREE.IcosahedronGeometry(1.25, 4), 
            mirrorSize: .2, 
        };

        init();
        window.addEventListener('resize', updateSize);

        btnReflect.addEventListener('click', () => setMode('reflect'));
        btnLaser.addEventListener('click', () => setMode('laser'));

        function init() {
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true, canvas: canvasEl });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            clock = new THREE.Clock();

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 100);
            camera.position.z = 5; 
            camera.position.y = 1;

            controls = new OrbitControls(camera, canvasEl);
            controls.minDistance = 2; controls.maxDistance = 10;  
            controls.autoRotate = false; controls.enableDamping = true;

            // Slightly brighter ambient light to keep mirrors white
            scene.add(new THREE.AmbientLight(0x444444)); 

            const lightColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00]; 
            for (let i = 0; i < 4; i++) { 
                const pointLight = new THREE.PointLight(lightColors[i], 1, 20, 2);
                scene.add(pointLight);
                pointLights.push(pointLight);
            }

            const ballGroup = createDiscoBall();
            scene.add(ballGroup);
            
            initLasers();

            setMode('reflect'); 
            updateSize();
            render();
        }

        function createDiscoBall() {
            const dummy = new THREE.Object3D();
            // Added small emissive to ensure it stays white even in shadows
            const mirrorMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff, 
                emissive: 0x222222,
                specular: 0xffffff, 
                shininess: 300, 
                combine: THREE.MultiplyOperation
            });

            let geometryOriginal = objectConfig.geometry;
            geometryOriginal.deleteAttribute('normal');
            geometryOriginal.deleteAttribute('uv');
            geometryOriginal = BufferGeometryUtils.mergeVertices(geometryOriginal);
            geometryOriginal.computeVertexNormals();

            const mirrorGeometry = new THREE.PlaneGeometry(objectConfig.mirrorSize, objectConfig.mirrorSize);
            const count = geometryOriginal.attributes.position.count;
            
            discoBallMesh = new THREE.InstancedMesh(mirrorGeometry, mirrorMaterial, count);

            const positions = geometryOriginal.attributes.position.array;
            const normals = geometryOriginal.attributes.normal.array;
            
            for (let i = 0; i < positions.length; i += 3) {
                dummy.position.set(positions[i], positions[i + 1], positions[i + 2]);
                dummy.lookAt(
                    positions[i] + normals[i], 
                    positions[i + 1] + normals[i + 1], 
                    positions[i + 2] + normals[i + 2]
                );
                dummy.updateMatrix();
                discoBallMesh.setMatrixAt(i / 3, dummy.matrix);
            }

            const obj = new THREE.Group();
            const innerGeometry = geometryOriginal.clone();
            const ballInnerMaterial = new THREE.MeshPhongMaterial({ color: 0x111111, specular: 0x111111, shininess: 10 });
            const innerMesh = new THREE.Mesh(innerGeometry, ballInnerMaterial);
            
            obj.add(innerMesh);
            obj.add(discoBallMesh);

            return obj;
        }

        function initLasers() {
            // 1. Updated Geometry: 16 radial segments for round cylinders
            const geometry = new THREE.CylinderGeometry(0.04, 0.04, 1, 16);
            geometry.rotateX(-Math.PI / 2); 
            geometry.translate(0, 0, 0.5); 

            for (let i = 0; i < laserCount; i++) {
                
                // 2. Random Color per laser
                const hue = Math.random();
                const laserColor = new THREE.Color().setHSL(hue, 1.0, 0.5);

                const material = new THREE.MeshBasicMaterial({
                    color: laserColor,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                const sourceBeam = new THREE.Mesh(geometry, material);
                scene.add(sourceBeam);
                sourceBeam.visible = false;

                const bounceBeam = new THREE.Mesh(geometry, material);
                scene.add(bounceBeam);
                bounceBeam.visible = false;

                // 3. Random Source Position (Spherical Distribution)
                const r = 14; // Distance away
                const theta = Math.random() * Math.PI * 2; // Around Y
                const phi = Math.acos((Math.random() * 2) - 1); // Up/Down distribution

                const sourcePos = new THREE.Vector3(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta), // Random height
                    r * Math.cos(phi)
                );

                // Random Target (near center, but offset)
                const targetPos = new THREE.Vector3(
                    (Math.random() - 0.5) * 2.0,
                    (Math.random() - 0.5) * 2.0,
                    (Math.random() - 0.5) * 2.0
                );

                laserObjs.push({
                    sourceBeam,
                    bounceBeam,
                    sourcePos: sourcePos,
                    targetPos: targetPos
                });
            }
        }

        function updateLasers(time) {
            if (!lasersActive) return;

            laserObjs.forEach((laser, i) => {
                const sPos = laser.sourcePos.clone();
                // Gentle bobbing of the source
                sPos.y += Math.sin(time + i * 0.5) * 1.0; 

                const direction = new THREE.Vector3().subVectors(laser.targetPos, sPos).normalize();
                raycaster.set(sPos, direction);

                const intersects = raycaster.intersectObject(discoBallMesh);

                if (intersects.length > 0) {
                    const hit = intersects[0];
                    const normal = hit.point.clone().normalize();

                    // Incoming
                    laser.sourceBeam.position.copy(sPos);
                    laser.sourceBeam.lookAt(hit.point);
                    laser.sourceBeam.scale.z = hit.distance;
                    laser.sourceBeam.visible = true;

                    // Reflection
                    const reflectVector = direction.clone().reflect(normal).normalize();

                    // Outgoing
                    const startPoint = hit.point.clone().add(normal.multiplyScalar(0.05));
                    
                    laser.bounceBeam.position.copy(startPoint);
                    const endPoint = startPoint.clone().add(reflectVector.multiplyScalar(30)); 
                    
                    laser.bounceBeam.lookAt(endPoint);
                    laser.bounceBeam.scale.z = 30;
                    laser.bounceBeam.visible = true;

                } else {
                    laser.sourceBeam.visible = false;
                    laser.bounceBeam.visible = false;
                }
            });
        }

        function setMode(mode) {
            if (mode === 'reflect') {
                btnReflect.classList.add('active');
                btnLaser.classList.remove('active');
                lasersActive = false;
                scene.fog.density = 0.005; 
                
                laserObjs.forEach(l => { l.sourceBeam.visible = false; l.bounceBeam.visible = false; });
                
                // 4. Lights stay consistent now
                pointLights.forEach(pl => pl.intensity = 1.0);

            } else {
                btnReflect.classList.remove('active');
                btnLaser.classList.add('active');
                lasersActive = true;
                scene.fog.density = 0.04; 
                
                // 4. Lights stay consistent (Mirrors remain white)
                pointLights.forEach(pl => pl.intensity = 1.0);
            }
        }

        function render() {
            const time = clock.getElapsedTime();
            controls.update(); 
            
            const ball = scene.children.find(c => c.type === 'Group');
            if(ball) {
                ball.rotateY(0.005); 
                ball.rotateX(0.002); 
            }

            pointLights.forEach((light, index) => {
                const angle = time * 0.5 + (index * Math.PI / 2); 
                light.position.x = Math.cos(angle * 0.8) * 5; 
                light.position.y = Math.sin(angle * 1.2) * 5; 
                light.position.z = Math.sin(angle * 0.5) * 2; 
            });

            updateLasers(time);

            renderer.render(scene, camera);
            requestAnimationFrame(render);
        }

        function updateSize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>