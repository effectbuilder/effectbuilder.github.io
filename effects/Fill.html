<!DOCTYPE html><html>
<head>
    <title>ORGB: Fill</title>
    <meta description="Progressively fills your devices with a defined color.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="speed" label="Speed" type="number" min="1" max="20" default="5"> <meta property="random_colors" label="Random Colors" type="boolean" default="true">
    <meta property="user_color" label="Color" type="color" min="0" max="360" default="#ffffff">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="fill-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('fill-canvas');
const ctx = canvas.getContext('2d');

// --- ADDED: Disable image smoothing ---
ctx.imageSmoothingEnabled = false;
ctx.mozImageSmoothingEnabled = false;
ctx.webkitImageSmoothingEnabled = false;

const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
const imageData = ctx.createImageData(canvasWidth, canvasHeight);
const pixels = imageData.data;

// Effect state variables
let time = 0.0;
let activeColor = [255, 255, 255]; // The color used for the current fill cycle
// --- MODIFIED: Initialize with defaults ---
let lastRandomColors = typeof random_colors !== 'undefined' ? random_colors : true;
let lastUserColor = typeof user_color !== 'undefined' ? user_color : "#ffffff";
let initialized = false; // Flag for initial color setup

// -------------------------------------------------------------------
// HELPER FUNCTIONS
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex || hex.length < 7) return [255, 255, 255]; // Basic validation + fallback
     try {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return [r, g, b];
     } catch(e) {
         console.error("Invalid hex color:", hex, e);
         return [255, 255, 255]; // Fallback
     }
}

function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

function applyBrightness(rgb, brightness) {
    // Clamp brightness between 0 and 1
    const clampedBrightness = Math.max(0, Math.min(1, brightness));
    return [rgb[0] * clampedBrightness, rgb[1] * clampedBrightness, rgb[2] * clampedBrightness];
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    // --- ADDED: Fallbacks for meta properties ---
    const currentSpeed = typeof speed !== 'undefined' ? speed : 5;
    const currentRandomColors = typeof random_colors !== 'undefined' ? random_colors : true;
    const currentUserColor = typeof user_color !== 'undefined' ? user_color : "#ffffff";

    // --- ADDED: Initialize color on first run ---
    if (!initialized) {
        activeColor = currentRandomColors ? randomRgb() : hexToRgb(currentUserColor);
        lastRandomColors = currentRandomColors; // Sync initial state
        lastUserColor = currentUserColor;     // Sync initial state
        initialized = true;
    }


    // --- Update State ---
    const old_time = time;
    // Speed range 1-20 -> time increment adjust
    time = (time + (currentSpeed / 10) * deltaTime * 2) % 2; // Adjusted speed scaling
    const progress = time % 1.0;

    // A cycle completes when progress wraps around
    if (time < old_time) { // Cycle just completed
        if (currentRandomColors) {
            activeColor = randomRgb();
        } else {
            activeColor = hexToRgb(currentUserColor);
        }
        lastRandomColors = currentRandomColors; // Update state after potential change
        lastUserColor = currentUserColor;
    }
    // Handle changes during a cycle
    else if (currentRandomColors !== lastRandomColors || currentUserColor !== lastUserColor) {
        if (currentRandomColors) {
            // Switch to random immediately if toggled on mid-cycle
             if (!lastRandomColors) activeColor = randomRgb();
        } else {
            activeColor = hexToRgb(currentUserColor);
        }
        lastRandomColors = currentRandomColors;
        lastUserColor = currentUserColor;
    }


    const isFilling = Math.floor(time) % 2 === 0;

    // --- Render ---
    for (let x = 0; x < canvasWidth; x++) {
        // Position relative to the current progress (0 to canvasWidth)
        const position = progress * canvasWidth;
        // Distance from the current pixel to the leading edge of the fill/wipe
        const distance = position - x;

        let finalColor;

        if (isFilling) { // Filling phase (left to right)
            if (x < position) { // Pixel is behind or at the leading edge
                // Calculate brightness based on proximity to the edge (fade in)
                const brightness = Math.min(1.0, (position - x)); // Simple linear fade over 1 pixel
                finalColor = applyBrightness(activeColor, brightness);
            } else { // Pixel is ahead of the fill
                finalColor = [0, 0, 0];
            }
        } else { // Wiping phase (color fades out uniformly)
             // Brightness decreases from 1 to 0 over the wipe phase
            const brightness = 1.0 - progress;
            finalColor = applyBrightness(activeColor, brightness);
        }


        // Apply color to the full vertical column
        for (let y = 0; y < canvasHeight; y++) {
            const index = (y * canvasWidth + x) * 4;
            pixels[index] = Math.round(finalColor[0]);
            pixels[index + 1] = Math.round(finalColor[1]);
            pixels[index + 2] = Math.round(finalColor[2]);
            pixels[index + 3] = 255; // Alpha
        }
    }

    ctx.putImageData(imageData, 0, 0);

    requestAnimationFrame(update);
}

// --- REMOVED: Initial color setup moved inside update ---
// activeColor = random_colors ? randomRgb() : hexToRgb(user_color);
requestAnimationFrame(update);
</script>
</html>