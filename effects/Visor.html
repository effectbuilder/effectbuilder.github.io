<!DOCTYPE html><html>
<head>
    <title>ORGB: Visor</title>
    <meta description="Alternate two colors on your devices from left to right.">
    <meta publisher="JosÃ© Miranda (Port and improvements)">

    <meta property="speed" label="Speed" type="number" min="1" max="20" default="10">
    <meta property="random_colors" label="Random Colors" type="boolean" default="false">
    <meta property="color1" label="Color 1" type="color" default="#ff0000">
    <meta property="color2" label="Color 2" type="color" default="#0000ff">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="visor-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

// --- MODIFIED: Corrected ID ---
const canvas = document.getElementById('visor-canvas');
const ctx = canvas.getContext('2d');

// --- ADDED: Disable image smoothing ---
ctx.imageSmoothingEnabled = false;
ctx.mozImageSmoothingEnabled = false;
ctx.webkitImageSmoothingEnabled = false;

const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

// Effect state variables
let time = 0.0;
// --- MODIFIED: Initialize with defaults ---
let color_a = hexToRgb(typeof color1 !== 'undefined' ? color1 : "#ff0000");
let color_b = hexToRgb(typeof color2 !== 'undefined' ? color2 : "#0000ff");
let last_direction = false;
let last_random_colors = typeof random_colors !== 'undefined' ? random_colors : false;
let last_color1 = typeof color1 !== 'undefined' ? color1 : "#ff0000";
let last_color2 = typeof color2 !== 'undefined' ? color2 : "#0000ff";
let initialized = false; // Flag for initial setup

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex || hex.length < 7) return [0, 0, 0];
     try {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return [r, g, b];
     } catch(e) {
         console.error("Invalid hex:", hex, e);
         return [0,0,0];
     }
}

function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

// -------------------------------------------------------------------
// EFFECT LOGIC
// -------------------------------------------------------------------

function getColumnColor(x, w, progress, direction) {
    // Determine the position of the wipe's edge (0.0 to 1.0)
    const wipe_position = direction ? progress : 1.0 - progress;
    const x_norm = x / w; // Normalized x position (0.0 to 1.0)

    // Return color A if pixel is before the wipe, color B otherwise
    const final_color = x_norm <= wipe_position ? color_a : color_b;

    // Return RGB array for fillStyle
    return `rgb(${Math.round(final_color[0])}, ${Math.round(final_color[1])}, ${Math.round(final_color[2])})`;
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    // --- MODIFIED: Use performance.now() ---
    const now = performance.now();
    const deltaTime = lastTime === 0 ? 0.016 : (now - lastTime) / 1000; // Delta in seconds
    lastTime = now;

    if (isNaN(deltaTime) || deltaTime <= 0) {
        requestAnimationFrame(update);
        return;
    }

    // --- ADDED: Fallbacks for meta properties ---
    const currentSpeed = typeof speed !== 'undefined' ? speed : 10;
    const currentRandomColors = typeof random_colors !== 'undefined' ? random_colors : false;
    const c1 = typeof color1 !== 'undefined' ? color1 : "#ff0000";
    const c2 = typeof color2 !== 'undefined' ? color2 : "#0000ff";

    // --- ADDED: Initialize on first run ---
     if (!initialized) {
        if (currentRandomColors) {
            color_a = randomRgb();
            color_b = randomRgb();
        } else {
            color_a = hexToRgb(c1);
            color_b = hexToRgb(c2);
        }
        last_random_colors = currentRandomColors; // Sync initial state
        last_color1 = c1;                         // Sync initial state
        last_color2 = c2;                         // Sync initial state
        initialized = true;
    }


    // --- Update State ---
    const old_time_int = Math.floor(time); // Store integer part before incrementing
    time += 0.1 * currentSpeed * deltaTime; // Scale speed

    const progress = time % 1.0; // Fractional part (0.0 to 1.0) for wipe position
    const direction = Math.floor(time) % 2 === 0; // Wipe direction (true = L->R, false = R->L)

    // Check if direction just changed (integer part of time changed)
    if (Math.floor(time) !== old_time_int) {
        if (currentRandomColors) {
            // Pick a new random color for the side that will be revealed next
            if (direction) { // Just finished wiping R->L, next wipe L->R reveals color_b
                color_b = randomRgb();
            } else { // Just finished wiping L->R, next wipe R->L reveals color_a
                color_a = randomRgb();
            }
        }
        last_direction = direction; // Update direction tracker
    }

    // Update colors if controls change mid-cycle
    if (currentRandomColors !== last_random_colors) {
        if (currentRandomColors) { // Switching TO random
             if (!last_random_colors) { // Only pick new if wasn't random before
                 color_a = randomRgb();
                 color_b = randomRgb();
             }
        } else { // Switching FROM random
            color_a = hexToRgb(c1);
            color_b = hexToRgb(c2);
        }
        last_random_colors = currentRandomColors;
    } else if (!currentRandomColors) { // If not random, check if user colors changed
        if (c1 !== last_color1) {
            color_a = hexToRgb(c1);
            last_color1 = c1;
        }
        if (c2 !== last_color2) {
            color_b = hexToRgb(c2);
            last_color2 = c2;
        }
    }


    // --- Render ---
    // Calculate color for each column once and fill
    for (let x = 0; x < canvasWidth; x++) {
        const colColor = getColumnColor(x, canvasWidth, progress, direction); // Uses updated color_a/color_b
        ctx.fillStyle = colColor;
        ctx.fillRect(x, 0, 1, canvasHeight);
    }

    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);

</script>
</html>