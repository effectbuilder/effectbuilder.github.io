<!DOCTYPE html><html>
<head>
    <title>ORGB: Sequence</title>
    <meta description="Alternates colors with a fade effect.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="speed" label="Speed" type="number" min="1" max="20" default="10">
    <meta property="fade_time" label="Fade Time (%)" type="number" min="1" max="100" default="50"> <meta property="color1" label="Color 1" type="color" min="0" max="360" default="#ff0000">
    <meta property="color2" label="Color 2" type="color" min="0" max="360" default="#00ff00">
    <meta property="color3" label="Color 3" type="color" min="0" max="360" default="#0000ff">
    <meta property="color4" label="Color 4" type="color" min="0" max="360" default="#ffff00">
    <meta property="color5" label="Color 5" type="color" min="0" max="360" default="#000000">
    <meta property="color6" label="Color 6" type="color" min="0" max="360" default="#000000">
    <meta property="color7" label="Color 7" type="color" min="0" max="360" default="#000000">
    <meta property="color8" label="Color 8" type="color" min="0" max="360" default="#000000">

    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="sequence-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('sequence-canvas');
const ctx = canvas.getContext('2d');

// --- ADDED: Disable image smoothing ---
ctx.imageSmoothingEnabled = false;
ctx.mozImageSmoothingEnabled = false;
ctx.webkitImageSmoothingEnabled = false;

const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

// Effect state variables
let progress = 0.0; // Represents position within the color sequence (0 to N)
let lastColors = []; // Stores RGB arrays of user colors
// --- MODIFIED: Initialize with defaults ---
let lastSpeed = typeof speed !== 'undefined' ? speed : 10;
let lastFadeTime = typeof fade_time !== 'undefined' ? fade_time : 50;
let lastColorSettingsString = ""; // Store combined hex string for easy change detection


// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex || hex.length < 7) return null; // Return null for invalid/empty
    try {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        // Exclude pure black unless it's the *only* color
        if (r === 0 && g === 0 && b === 0) return null; // Treat black as empty slot
        return [r, g, b];
     } catch(e) {
         console.error("Invalid hex:", hex, e);
         return null;
     }
}

/** Linearly interpolates between two colors */
function lerpColor(c1, c2, factor) {
    const f = Math.max(0, Math.min(1, factor));
    const r = c1[0] * (1 - f) + c2[0] * f;
    const g = c1[1] * (1 - f) + c2[1] * f;
    const b = c1[2] * (1 - f) + c2[2] * f;
    return [r, g, b];
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

     // --- ADDED: Fallbacks for meta properties ---
    const currentSpeed = typeof speed !== 'undefined' ? speed : 10;
    const currentFadeTime = typeof fade_time !== 'undefined' ? fade_time : 50;
    const c1 = typeof color1 !== 'undefined' ? color1 : "#ff0000";
    const c2 = typeof color2 !== 'undefined' ? color2 : "#00ff00";
    const c3 = typeof color3 !== 'undefined' ? color3 : "#0000ff";
    const c4 = typeof color4 !== 'undefined' ? color4 : "#ffff00";
    const c5 = typeof color5 !== 'undefined' ? color5 : "#000000";
    const c6 = typeof color6 !== 'undefined' ? color6 : "#000000";
    const c7 = typeof color7 !== 'undefined' ? color7 : "#000000";
    const c8 = typeof color8 !== 'undefined' ? color8 : "#000000";

    // Check for changes in meta properties and update colors
    const currentMetaColors = [c1, c2, c3, c4, c5, c6, c7, c8];
    const currentColorSettingsString = currentMetaColors.join(''); // Simple string comparison

    if (currentColorSettingsString !== lastColorSettingsString || currentSpeed !== lastSpeed || currentFadeTime !== lastFadeTime) {
         // Filter out nulls (invalid/black) and map valid hex to RGB
        let newColors = currentMetaColors.map(hexToRgb).filter(rgb => rgb !== null);

        // If filtering results in no colors, add black as a fallback
        if (newColors.length === 0) {
            newColors.push([0, 0, 0]);
        }

        lastColors = newColors;
        lastSpeed = currentSpeed;
        lastFadeTime = currentFadeTime;
        lastColorSettingsString = currentColorSettingsString;
        progress = 0.0; // Restart animation on change
    }


    if (lastColors.length === 0) {
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        requestAnimationFrame(update);
        return; // Should not happen due to fallback, but good practice
    }

    // --- Update State ---
    const color_count = lastColors.length;
    // Progress increases by 'speed' units per second (scaled)
    const increment = (currentSpeed / 10.0) * deltaTime;
    progress = (progress + increment) % color_count; // Wrap progress based on number of colors

    const current_color_index = Math.floor(progress);
    const frac = progress % 1.0; // Fractional part for fading

    let final_color;

    // Fade time is a percentage of the *hold* time for one color (which is 1.0 unit of progress)
    const fade_threshold_percent = Math.max(1, Math.min(100, currentFadeTime)) / 100.0; // Clamp 1-100%
    const hold_duration = 1.0 - fade_threshold_percent; // The portion of time spent holding the color

    if (frac >= hold_duration && fade_threshold_percent < 1.0) { // Check fade isn't 100%
       // Currently in the fade phase
       const next_color_index = (current_color_index + 1) % color_count;
       // Calculate progress within the fade duration (0 to 1)
       const fade_progress = (frac - hold_duration) / fade_threshold_percent;
       final_color = lerpColor(lastColors[current_color_index], lastColors[next_color_index], fade_progress);
    } else {
        // Currently holding the color or fade is 100% (instant switch)
        final_color = lastColors[current_color_index];
    }

    // --- Render ---
    ctx.fillStyle = `rgb(${Math.round(final_color[0])}, ${Math.round(final_color[1])}, ${Math.round(final_color[2])})`;
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);

    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);

</script>
</html>